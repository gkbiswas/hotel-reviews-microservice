
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gkbiswas/hotel-reviews-microservice/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/gkbiswas/hotel-reviews-microservice/internal/application/handlers.go (74.8%)</option>
				
				<option value="file2">github.com/gkbiswas/hotel-reviews-microservice/internal/application/processor.go (77.4%)</option>
				
				<option value="file3">github.com/gkbiswas/hotel-reviews-microservice/internal/domain/services.go (82.3%)</option>
				
				<option value="file4">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/database.go (0.0%)</option>
				
				<option value="file5">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/jsonlines.go (0.0%)</option>
				
				<option value="file6">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/repository.go (0.0%)</option>
				
				<option value="file7">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/s3client.go (0.0%)</option>
				
				<option value="file8">github.com/gkbiswas/hotel-reviews-microservice/pkg/config/config.go (0.0%)</option>
				
				<option value="file9">github.com/gkbiswas/hotel-reviews-microservice/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/gorilla/mux"
        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/application"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// Application represents the main application
type Application struct {
        config            *config.Config
        logger            *logger.Logger
        database          *infrastructure.Database
        s3Client          *infrastructure.S3Client
        reviewRepository  domain.ReviewRepository
        jsonProcessor     domain.JSONProcessor
        reviewService     domain.ReviewService
        processingEngine  *application.ProcessingEngine
        handlers          *application.Handlers
        server            *http.Server
}

// CLI flags
var (
        configFile    = flag.String("config", "", "Path to configuration file")
        mode          = flag.String("mode", "server", "Application mode: server, cli, migrate, process-files")
        logLevel      = flag.String("log-level", "", "Log level override (debug, info, warn, error)")
        host          = flag.String("host", "", "Server host override")
        port          = flag.Int("port", 0, "Server port override")
        
        // CLI specific flags
        fileURL       = flag.String("file-url", "", "S3 URL of the file to process")
        providerName  = flag.String("provider", "", "Provider name for file processing")
        resetDB       = flag.Bool("reset-db", false, "Reset database (drop all tables)")
        seedDB        = flag.Bool("seed-db", false, "Seed database with initial data")
        
        // Migration flags
        migrateUp     = flag.Bool("migrate-up", false, "Run database migrations")
        migrateDown   = flag.Bool("migrate-down", false, "Rollback database migrations")
        
        // Display flags
        version       = flag.Bool("version", false, "Show version information")
        help          = flag.Bool("help", false, "Show help information")
)

const (
        AppName    = "hotel-reviews-microservice"
        AppVersion = "1.0.0"
)

func main() <span class="cov0" title="0">{
        flag.Parse()
        
        // Handle help and version flags
        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>
        
        <span class="cov0" title="0">if *version </span><span class="cov0" title="0">{
                printVersion()
                os.Exit(0)
        }</span>
        
        // Initialize application
        <span class="cov0" title="0">app, err := initializeApplication()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize application: %v\n", err)
                os.Exit(1)
        }</span>
        
        // Run application based on mode
        <span class="cov0" title="0">switch *mode </span>{
        case "server":<span class="cov0" title="0">
                err = app.runServer()</span>
        case "cli":<span class="cov0" title="0">
                err = app.runCLI()</span>
        case "migrate":<span class="cov0" title="0">
                err = app.runMigrations()</span>
        case "process-files":<span class="cov0" title="0">
                err = app.processFiles()</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown mode: %s", *mode)</span>
        }
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                app.logger.Error("Application failed", "error", err)
                os.Exit(1)
        }</span>
}

// initializeApplication initializes the application with all dependencies
func initializeApplication() (*Application, error) <span class="cov0" title="0">{
        // Load configuration
        cfg, err := loadConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        
        // Initialize logger
        <span class="cov0" title="0">loggerConfig := &amp;logger.Config{
                Level:           cfg.Log.Level,
                Format:          cfg.Log.Format,
                Output:          cfg.Log.Output,
                FilePath:        cfg.Log.FilePath,
                MaxSize:         cfg.Log.MaxSize,
                MaxBackups:      cfg.Log.MaxBackups,
                MaxAge:          cfg.Log.MaxAge,
                Compress:        cfg.Log.Compress,
                EnableCaller:    cfg.Log.EnableCaller,
                EnableStacktrace: cfg.Log.EnableStacktrace,
        }
        log, err := logger.New(loggerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize logger: %w", err)
        }</span>
        
        <span class="cov0" title="0">log.Info("Starting application",
                "name", AppName,
                "version", AppVersion,
                "mode", *mode,
        )
        
        // Initialize database
        database, err := infrastructure.NewDatabase(&amp;cfg.Database, log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        
        // Initialize S3 client
        <span class="cov0" title="0">s3Client, err := infrastructure.NewS3Client(&amp;cfg.S3, log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize S3 client: %w", err)
        }</span>
        
        // Initialize repository
        <span class="cov0" title="0">reviewRepository := infrastructure.NewReviewRepository(database, log)
        
        // Initialize JSON processor
        jsonProcessor := infrastructure.NewJSONLinesProcessor(reviewRepository, log)
        
        // Initialize review service
        reviewService := domain.NewReviewService(
                reviewRepository,
                s3Client,
                jsonProcessor,
                nil, // notificationService - TODO: implement
                nil, // cacheService - TODO: implement
                nil, // metricsService - TODO: implement
                nil, // eventPublisher - TODO: implement
                log.Logger,
        )
        
        // Initialize processing engine
        processingConfig := &amp;application.ProcessingConfig{
                MaxWorkers:         cfg.Processing.WorkerCount,
                MaxConcurrentFiles: 10,
                MaxRetries:         cfg.Processing.MaxRetries,
                RetryDelay:         cfg.Processing.RetryDelay,
                ProcessingTimeout:  cfg.Processing.ProcessingTimeout,
                WorkerIdleTimeout:  5 * time.Minute,
                MetricsInterval:    30 * time.Second,
        }
        
        processingEngine := application.NewProcessingEngine(
                reviewService,
                s3Client,
                jsonProcessor,
                log,
                processingConfig,
        )
        
        // Initialize handlers
        handlers := application.NewHandlers(reviewService, log)
        
        app := &amp;Application{
                config:            cfg,
                logger:            log,
                database:          database,
                s3Client:          s3Client,
                reviewRepository:  reviewRepository,
                jsonProcessor:     jsonProcessor,
                reviewService:     reviewService,
                processingEngine:  processingEngine,
                handlers:          handlers,
        }
        
        return app, nil</span>
}

// loadConfiguration loads configuration from file and environment variables
func loadConfiguration() (*config.Config, error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Apply command-line overrides
        <span class="cov0" title="0">if *logLevel != "" </span><span class="cov0" title="0">{
                cfg.Log.Level = *logLevel
        }</span>
        
        <span class="cov0" title="0">if *host != "" </span><span class="cov0" title="0">{
                cfg.Server.Host = *host
        }</span>
        
        <span class="cov0" title="0">if *port != 0 </span><span class="cov0" title="0">{
                cfg.Server.Port = *port
        }</span>
        
        <span class="cov0" title="0">return cfg, nil</span>
}

// runServer runs the application in server mode
func (app *Application) runServer() error <span class="cov0" title="0">{
        ctx := context.Background()
        
        app.logger.Info("Starting server mode")
        
        // Run database migrations
        if err := app.database.Migrate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run database migrations: %w", err)
        }</span>
        
        // Seed database if needed
        <span class="cov0" title="0">if *seedDB </span><span class="cov0" title="0">{
                if err := app.database.Seed(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to seed database: %w", err)
                }</span>
        }
        
        // Start processing engine
        <span class="cov0" title="0">if err := app.processingEngine.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start processing engine: %w", err)
        }</span>
        
        // Setup HTTP server
        <span class="cov0" title="0">router := mux.NewRouter()
        
        // Add middleware
        router.Use(app.handlers.LoggingMiddleware)
        router.Use(app.handlers.RecoveryMiddleware)
        router.Use(app.handlers.CORSMiddleware)
        router.Use(app.handlers.ContentTypeMiddleware)
        
        // Setup routes
        api := router.PathPrefix("/api/v1").Subrouter()
        app.handlers.SetupRoutes(api)
        
        // Create HTTP server
        app.server = &amp;http.Server{
                Addr:           app.config.GetServerAddress(),
                Handler:        router,
                ReadTimeout:    app.config.Server.ReadTimeout,
                WriteTimeout:   app.config.Server.WriteTimeout,
                IdleTimeout:    app.config.Server.IdleTimeout,
                MaxHeaderBytes: app.config.Server.MaxHeaderBytes,
        }
        
        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                app.logger.Info("HTTP server starting",
                        "address", app.server.Addr,
                        "read_timeout", app.config.Server.ReadTimeout,
                        "write_timeout", app.config.Server.WriteTimeout,
                )
                
                var err error
                if app.config.Server.TLSCertFile != "" &amp;&amp; app.config.Server.TLSKeyFile != "" </span><span class="cov0" title="0">{
                        err = app.server.ListenAndServeTLS(app.config.Server.TLSCertFile, app.config.Server.TLSKeyFile)
                }</span> else<span class="cov0" title="0"> {
                        err = app.server.ListenAndServe()
                }</span>
                
                <span class="cov0" title="0">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        app.logger.Error("HTTP server failed", "error", err)
                }</span>
        }()
        
        <span class="cov0" title="0">app.logger.Info("Server started successfully", "address", app.server.Addr)
        
        // Wait for shutdown signal
        return app.waitForShutdown()</span>
}

// runCLI runs the application in CLI mode
func (app *Application) runCLI() error <span class="cov0" title="0">{
        ctx := context.Background()
        
        app.logger.Info("Starting CLI mode")
        
        // Validate CLI flags
        if *fileURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("file-url is required for CLI mode")
        }</span>
        
        <span class="cov0" title="0">if *providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("provider is required for CLI mode")
        }</span>
        
        // Get provider by name
        <span class="cov0" title="0">provider, err := app.reviewService.GetProviderByName(ctx, *providerName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get provider '%s': %w", *providerName, err)
        }</span>
        
        // Start processing engine
        <span class="cov0" title="0">if err := app.processingEngine.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start processing engine: %w", err)
        }</span>
        <span class="cov0" title="0">defer app.processingEngine.Stop()
        
        // Submit job
        job, err := app.processingEngine.SubmitJob(ctx, provider.ID, *fileURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to submit job: %w", err)
        }</span>
        
        <span class="cov0" title="0">app.logger.Info("File processing job submitted",
                "job_id", job.ID,
                "file_url", *fileURL,
                "provider", *providerName,
        )
        
        // Monitor job progress
        return app.monitorJob(ctx, job.ID)</span>
}

// runMigrations runs database migrations
func (app *Application) runMigrations() error <span class="cov0" title="0">{
        ctx := context.Background()
        
        app.logger.Info("Starting migration mode")
        
        if *resetDB </span><span class="cov0" title="0">{
                app.logger.Warn("Resetting database - all data will be lost!")
                if err := app.database.Reset(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reset database: %w", err)
                }</span>
                <span class="cov0" title="0">app.logger.Info("Database reset completed")</span>
        }
        
        <span class="cov0" title="0">if *migrateUp </span><span class="cov0" title="0">{
                app.logger.Info("Running database migrations...")
                if err := app.database.Migrate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run migrations: %w", err)
                }</span>
                <span class="cov0" title="0">app.logger.Info("Database migrations completed")</span>
        }
        
        <span class="cov0" title="0">if *seedDB </span><span class="cov0" title="0">{
                app.logger.Info("Seeding database...")
                if err := app.database.Seed(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to seed database: %w", err)
                }</span>
                <span class="cov0" title="0">app.logger.Info("Database seeding completed")</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// processFiles processes multiple files (batch processing)
func (app *Application) processFiles() error <span class="cov0" title="0">{
        ctx := context.Background()
        
        app.logger.Info("Starting batch file processing mode")
        
        // This is a placeholder for batch processing functionality
        // In a real implementation, you might read a list of files from a config file
        // or accept multiple file URLs as command-line arguments
        
        if *fileURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("file-url is required for process-files mode")
        }</span>
        
        <span class="cov0" title="0">if *providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("provider is required for process-files mode")
        }</span>
        
        // Get provider by name
        <span class="cov0" title="0">provider, err := app.reviewService.GetProviderByName(ctx, *providerName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get provider '%s': %w", *providerName, err)
        }</span>
        
        // Start processing engine
        <span class="cov0" title="0">if err := app.processingEngine.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start processing engine: %w", err)
        }</span>
        <span class="cov0" title="0">defer app.processingEngine.Stop()
        
        // Process files (for now, just one file)
        fileURLs := strings.Split(*fileURL, ",")
        
        var jobs []*application.ProcessingJob
        for _, url := range fileURLs </span><span class="cov0" title="0">{
                url = strings.TrimSpace(url)
                if url == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">job, err := app.processingEngine.SubmitJob(ctx, provider.ID, url)
                if err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("Failed to submit job", "file_url", url, "error", err)
                        continue</span>
                }
                
                <span class="cov0" title="0">jobs = append(jobs, job)
                app.logger.Info("Job submitted", "job_id", job.ID, "file_url", url)</span>
        }
        
        // Monitor all jobs
        <span class="cov0" title="0">return app.monitorJobs(ctx, jobs)</span>
}

// monitorJob monitors a single job until completion
func (app *Application) monitorJob(ctx context.Context, jobID uuid.UUID) error <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        job, exists := app.processingEngine.GetJobStatus(jobID)
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("job not found: %s", jobID)
                        }</span>
                        
                        <span class="cov0" title="0">app.logger.Info("Job status",
                                "job_id", job.ID,
                                "status", job.Status,
                                "records_processed", job.RecordsProcessed,
                                "records_total", job.RecordsTotal,
                        )
                        
                        switch job.Status </span>{
                        case application.StatusCompleted:<span class="cov0" title="0">
                                app.logger.Info("Job completed successfully", "job_id", job.ID)
                                return nil</span>
                        case application.StatusFailed:<span class="cov0" title="0">
                                return fmt.Errorf("job failed: %s", job.ErrorMessage)</span>
                        case application.StatusCancelled:<span class="cov0" title="0">
                                return fmt.Errorf("job was cancelled")</span>
                        }
                }
        }
}

// monitorJobs monitors multiple jobs until all complete
func (app *Application) monitorJobs(ctx context.Context, jobs []*application.ProcessingJob) error <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()
        
        completed := make(map[uuid.UUID]bool)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        allCompleted := true
                        
                        for _, job := range jobs </span><span class="cov0" title="0">{
                                if completed[job.ID] </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                
                                <span class="cov0" title="0">currentJob, exists := app.processingEngine.GetJobStatus(job.ID)
                                if !exists </span><span class="cov0" title="0">{
                                        app.logger.Error("Job not found", "job_id", job.ID)
                                        continue</span>
                                }
                                
                                <span class="cov0" title="0">app.logger.Info("Job status",
                                        "job_id", currentJob.ID,
                                        "status", currentJob.Status,
                                        "records_processed", currentJob.RecordsProcessed,
                                        "records_total", currentJob.RecordsTotal,
                                )
                                
                                switch currentJob.Status </span>{
                                case application.StatusCompleted:<span class="cov0" title="0">
                                        completed[job.ID] = true
                                        app.logger.Info("Job completed", "job_id", job.ID)</span>
                                case application.StatusFailed:<span class="cov0" title="0">
                                        completed[job.ID] = true
                                        app.logger.Error("Job failed", "job_id", job.ID, "error", currentJob.ErrorMessage)</span>
                                case application.StatusCancelled:<span class="cov0" title="0">
                                        completed[job.ID] = true
                                        app.logger.Warn("Job cancelled", "job_id", job.ID)</span>
                                default:<span class="cov0" title="0">
                                        allCompleted = false</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if allCompleted </span><span class="cov0" title="0">{
                                app.logger.Info("All jobs completed")
                                return nil
                        }</span>
                }
        }
}

// waitForShutdown waits for shutdown signal and performs graceful shutdown
func (app *Application) waitForShutdown() error <span class="cov0" title="0">{
        // Create channel to receive OS signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        
        // Wait for signal
        sig := &lt;-sigChan
        app.logger.Info("Received shutdown signal", "signal", sig)
        
        // Create context with timeout for shutdown
        ctx, cancel := context.WithTimeout(context.Background(), app.config.Server.ShutdownTimeout)
        defer cancel()
        
        // Shutdown processing engine
        if err := app.processingEngine.Stop(); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("Failed to stop processing engine", "error", err)
        }</span>
        
        // Shutdown HTTP server
        <span class="cov0" title="0">if app.server != nil </span><span class="cov0" title="0">{
                app.logger.Info("Shutting down HTTP server...")
                if err := app.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("Failed to shutdown HTTP server gracefully", "error", err)
                        return err
                }</span>
        }
        
        // Close database connection
        <span class="cov0" title="0">if err := app.database.Close(); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("Failed to close database connection", "error", err)
        }</span>
        
        <span class="cov0" title="0">app.logger.Info("Shutdown completed successfully")
        return nil</span>
}

// printHelp prints help information
func printHelp() <span class="cov0" title="0">{
        fmt.Printf(`%s - Hotel Reviews Microservice

USAGE:
    %s [OPTIONS]

OPTIONS:
    -mode string
        Application mode: server, cli, migrate, process-files (default "server")
    -config string
        Path to configuration file
    -log-level string
        Log level override (debug, info, warn, error)
    -host string
        Server host override
    -port int
        Server port override

CLI MODE OPTIONS:
    -file-url string
        S3 URL of the file to process
    -provider string
        Provider name for file processing

MIGRATION OPTIONS:
    -reset-db
        Reset database (drop all tables)
    -migrate-up
        Run database migrations
    -seed-db
        Seed database with initial data

PROCESS-FILES OPTIONS:
    -file-url string
        Comma-separated list of S3 URLs to process
    -provider string
        Provider name for file processing

OTHER OPTIONS:
    -version
        Show version information
    -help
        Show this help message

EXAMPLES:
    # Start server
    %s -mode server

    # Process a single file
    %s -mode cli -file-url s3://bucket/file.jsonl -provider booking

    # Run migrations
    %s -mode migrate -migrate-up -seed-db

    # Process multiple files
    %s -mode process-files -file-url "s3://bucket/file1.jsonl,s3://bucket/file2.jsonl" -provider booking

ENVIRONMENT VARIABLES:
    Configuration can also be provided via environment variables with HOTEL_REVIEWS_ prefix.
    For example: HOTEL_REVIEWS_DATABASE_HOST=localhost

`, AppName, AppName, AppName, AppName, AppName, AppName)
}</span>

// printVersion prints version information
func printVersion() <span class="cov0" title="0">{
        fmt.Printf(`%s
Version: %s
Build: %s
`, AppName, AppVersion, time.Now().Format("2006-01-02"))
}</pre>
		
		<pre class="file" id="file1" style="display: none">package application

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// Handlers contains all HTTP handlers for the review system
type Handlers struct {
        reviewService domain.ReviewService
        logger        *logger.Logger
}

// NewHandlers creates a new Handlers instance
func NewHandlers(reviewService domain.ReviewService, logger *logger.Logger) *Handlers <span class="cov8" title="1">{
        return &amp;Handlers{
                reviewService: reviewService,
                logger:        logger,
        }
}</span>

// Response structures
type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Meta    *Meta       `json:"meta,omitempty"`
}

type Meta struct {
        Total  int64 `json:"total,omitempty"`
        Limit  int   `json:"limit,omitempty"`
        Offset int   `json:"offset,omitempty"`
        Page   int   `json:"page,omitempty"`
}

type HealthResponse struct {
        Status    string            `json:"status"`
        Version   string            `json:"version"`
        Timestamp time.Time         `json:"timestamp"`
        Services  map[string]string `json:"services"`
}

// Request structures
type ProcessFileRequest struct {
        FileURL    string `json:"file_url" validate:"required,url"`
        ProviderID string `json:"provider_id" validate:"required,uuid"`
}

type CreateReviewRequest struct {
        ProviderID        string                 `json:"provider_id" validate:"required,uuid"`
        HotelID           string                 `json:"hotel_id" validate:"required,uuid"`
        ReviewerInfoID    string                 `json:"reviewer_info_id" validate:"required,uuid"`
        ExternalID        string                 `json:"external_id"`
        Rating            float64                `json:"rating" validate:"required,min=1,max=5"`
        Title             string                 `json:"title" validate:"max=500"`
        Comment           string                 `json:"comment" validate:"required,max=10000"`
        ReviewDate        time.Time              `json:"review_date" validate:"required"`
        StayDate          *time.Time             `json:"stay_date,omitempty"`
        TripType          string                 `json:"trip_type" validate:"max=50"`
        RoomType          string                 `json:"room_type" validate:"max=100"`
        Language          string                 `json:"language" validate:"max=10"`
        ServiceRating     *float64               `json:"service_rating,omitempty" validate:"omitempty,min=1,max=5"`
        CleanlinessRating *float64               `json:"cleanliness_rating,omitempty" validate:"omitempty,min=1,max=5"`
        LocationRating    *float64               `json:"location_rating,omitempty" validate:"omitempty,min=1,max=5"`
        ValueRating       *float64               `json:"value_rating,omitempty" validate:"omitempty,min=1,max=5"`
        ComfortRating     *float64               `json:"comfort_rating,omitempty" validate:"omitempty,min=1,max=5"`
        FacilitiesRating  *float64               `json:"facilities_rating,omitempty" validate:"omitempty,min=1,max=5"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
}

type CreateHotelRequest struct {
        Name        string   `json:"name" validate:"required,min=1,max=255"`
        Address     string   `json:"address"`
        City        string   `json:"city" validate:"max=100"`
        Country     string   `json:"country" validate:"max=100"`
        PostalCode  string   `json:"postal_code" validate:"max=20"`
        Phone       string   `json:"phone" validate:"max=20"`
        Email       string   `json:"email" validate:"email,max=255"`
        StarRating  int      `json:"star_rating" validate:"min=1,max=5"`
        Description string   `json:"description"`
        Amenities   []string `json:"amenities"`
        Latitude    float64  `json:"latitude" validate:"min=-90,max=90"`
        Longitude   float64  `json:"longitude" validate:"min=-180,max=180"`
}

type CreateProviderRequest struct {
        Name     string `json:"name" validate:"required,min=1,max=100"`
        BaseURL  string `json:"base_url" validate:"url"`
        IsActive bool   `json:"is_active"`
}

// Health check handler
func (h *Handlers) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Check service health
        services := make(map[string]string)
        services["api"] = "healthy"
        
        // TODO: Add database health check
        // TODO: Add S3 health check
        // TODO: Add cache health check
        
        response := HealthResponse{
                Status:    "healthy",
                Version:   "1.0.0",
                Timestamp: time.Now(),
                Services:  services,
        }
        
        h.logger.DebugContext(ctx, "Health check requested")
        h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    response,
        })
}</span>

// File processing handlers
func (h *Handlers) ProcessFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        var req ProcessFileRequest
        if err := h.parseJSONRequest(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format", err)
                return
        }</span>
        
        // Validate request
        <span class="cov8" title="1">if err := h.validateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Validation failed", err)
                return
        }</span>
        
        // Parse provider ID
        <span class="cov8" title="1">providerID, err := uuid.Parse(req.ProviderID)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid provider ID", err)
                return
        }</span>
        
        // Start file processing
        <span class="cov8" title="1">processingStatus, err := h.reviewService.ProcessReviewFile(ctx, req.FileURL, providerID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to start file processing",
                        "file_url", req.FileURL,
                        "provider_id", providerID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to start file processing", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.logger.InfoContext(ctx, "File processing started",
                "processing_id", processingStatus.ID,
                "file_url", req.FileURL,
                "provider_id", providerID,
        )
        
        h.writeJSONResponse(w, http.StatusAccepted, APIResponse{
                Success: true,
                Data:    processingStatus,
        })</span>
}

func (h *Handlers) GetProcessingStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get processing ID from URL
        vars := mux.Vars(r)
        processingID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid processing ID", err)
                return
        }</span>
        
        // Get processing status
        <span class="cov8" title="1">status, err := h.reviewService.GetProcessingStatus(ctx, processingID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get processing status",
                        "processing_id", processingID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusNotFound, "Processing status not found", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    status,
        })</span>
}

func (h *Handlers) GetProcessingHistory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get provider ID from URL
        vars := mux.Vars(r)
        providerID, err := uuid.Parse(vars["provider_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid provider ID", err)
                return
        }</span>
        
        // Get pagination parameters
        <span class="cov8" title="1">limit, offset := h.getPaginationParams(r)
        
        // Get processing history
        history, err := h.reviewService.GetProcessingHistory(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get processing history",
                        "provider_id", providerID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to get processing history", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    history,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

// Review handlers
func (h *Handlers) CreateReview(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        var req CreateReviewRequest
        if err := h.parseJSONRequest(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format", err)
                return
        }</span>
        
        // Validate request
        <span class="cov8" title="1">if err := h.validateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Validation failed", err)
                return
        }</span>
        
        // Convert request to domain model
        <span class="cov8" title="1">review, err := h.convertToReview(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request data", err)
                return
        }</span>
        
        // Create review
        <span class="cov8" title="1">if err := h.reviewService.CreateReview(ctx, review); err != nil </span><span class="cov8" title="1">{
                h.logger.ErrorContext(ctx, "Failed to create review",
                        "review_id", review.ID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to create review", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.logger.InfoContext(ctx, "Review created successfully",
                "review_id", review.ID,
                "hotel_id", review.HotelID,
                "provider_id", review.ProviderID,
        )
        
        h.writeJSONResponse(w, http.StatusCreated, APIResponse{
                Success: true,
                Data:    review,
        })</span>
}

func (h *Handlers) GetReview(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get review ID from URL
        vars := mux.Vars(r)
        reviewID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid review ID", err)
                return
        }</span>
        
        // Get review
        <span class="cov8" title="1">review, err := h.reviewService.GetReviewByID(ctx, reviewID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.ErrorContext(ctx, "Failed to get review",
                        "review_id", reviewID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusNotFound, "Review not found", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    review,
        })</span>
}

func (h *Handlers) GetReviewsByHotel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get hotel ID from URL
        vars := mux.Vars(r)
        hotelID, err := uuid.Parse(vars["hotel_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid hotel ID", err)
                return
        }</span>
        
        // Get pagination parameters
        <span class="cov8" title="1">limit, offset := h.getPaginationParams(r)
        
        // Get reviews
        reviews, err := h.reviewService.GetReviewsByHotel(ctx, hotelID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get reviews by hotel",
                        "hotel_id", hotelID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to get reviews", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    reviews,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

func (h *Handlers) GetReviewsByProvider(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get provider ID from URL
        vars := mux.Vars(r)
        providerID, err := uuid.Parse(vars["provider_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid provider ID", err)
                return
        }</span>
        
        // Get pagination parameters
        <span class="cov8" title="1">limit, offset := h.getPaginationParams(r)
        
        // Get reviews
        reviews, err := h.reviewService.GetReviewsByProvider(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get reviews by provider",
                        "provider_id", providerID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to get reviews", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    reviews,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

func (h *Handlers) SearchReviews(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get search parameters
        query := r.URL.Query().Get("q")
        filters := h.buildFilters(r)
        limit, offset := h.getPaginationParams(r)
        
        // Search reviews
        reviews, err := h.reviewService.SearchReviews(ctx, query, filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to search reviews",
                        "query", query,
                        "filters", filters,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to search reviews", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    reviews,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

// Hotel handlers
func (h *Handlers) CreateHotel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        var req CreateHotelRequest
        if err := h.parseJSONRequest(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format", err)
                return
        }</span>
        
        // Validate request
        <span class="cov8" title="1">if err := h.validateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Validation failed", err)
                return
        }</span>
        
        // Convert request to domain model
        <span class="cov8" title="1">hotel := &amp;domain.Hotel{
                ID:          uuid.New(),
                Name:        req.Name,
                Address:     req.Address,
                City:        req.City,
                Country:     req.Country,
                PostalCode:  req.PostalCode,
                Phone:       req.Phone,
                Email:       req.Email,
                StarRating:  req.StarRating,
                Description: req.Description,
                Amenities:   req.Amenities,
                Latitude:    req.Latitude,
                Longitude:   req.Longitude,
        }
        
        // Create hotel
        if err := h.reviewService.CreateHotel(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to create hotel",
                        "hotel_id", hotel.ID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to create hotel", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.logger.InfoContext(ctx, "Hotel created successfully",
                "hotel_id", hotel.ID,
                "name", hotel.Name,
        )
        
        h.writeJSONResponse(w, http.StatusCreated, APIResponse{
                Success: true,
                Data:    hotel,
        })</span>
}

func (h *Handlers) GetHotel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get hotel ID from URL
        vars := mux.Vars(r)
        hotelID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid hotel ID", err)
                return
        }</span>
        
        // Get hotel
        <span class="cov8" title="1">hotel, err := h.reviewService.GetHotelByID(ctx, hotelID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get hotel",
                        "hotel_id", hotelID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusNotFound, "Hotel not found", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    hotel,
        })</span>
}

func (h *Handlers) ListHotels(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get pagination parameters
        limit, offset := h.getPaginationParams(r)
        
        // List hotels
        hotels, err := h.reviewService.ListHotels(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to list hotels", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to list hotels", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    hotels,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

// Provider handlers
func (h *Handlers) CreateProvider(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        var req CreateProviderRequest
        if err := h.parseJSONRequest(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid request format", err)
                return
        }</span>
        
        // Validate request
        <span class="cov8" title="1">if err := h.validateRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Validation failed", err)
                return
        }</span>
        
        // Convert request to domain model
        <span class="cov8" title="1">provider := &amp;domain.Provider{
                ID:       uuid.New(),
                Name:     req.Name,
                BaseURL:  req.BaseURL,
                IsActive: req.IsActive,
        }
        
        // Create provider
        if err := h.reviewService.CreateProvider(ctx, provider); err != nil </span><span class="cov8" title="1">{
                h.logger.ErrorContext(ctx, "Failed to create provider",
                        "provider_id", provider.ID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to create provider", err)
                return
        }</span>
        
        <span class="cov0" title="0">h.logger.InfoContext(ctx, "Provider created successfully",
                "provider_id", provider.ID,
                "name", provider.Name,
        )
        
        h.writeJSONResponse(w, http.StatusCreated, APIResponse{
                Success: true,
                Data:    provider,
        })</span>
}

func (h *Handlers) GetProvider(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get provider ID from URL
        vars := mux.Vars(r)
        providerID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid provider ID", err)
                return
        }</span>
        
        // Get provider
        <span class="cov8" title="1">provider, err := h.reviewService.GetProviderByID(ctx, providerID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get provider",
                        "provider_id", providerID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusNotFound, "Provider not found", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    provider,
        })</span>
}

func (h *Handlers) ListProviders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get pagination parameters
        limit, offset := h.getPaginationParams(r)
        
        // List providers
        providers, err := h.reviewService.ListProviders(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to list providers", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to list providers", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    providers,
                Meta: &amp;Meta{
                        Limit:  limit,
                        Offset: offset,
                },
        })</span>
}

// Analytics handlers
func (h *Handlers) GetReviewSummary(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get hotel ID from URL
        vars := mux.Vars(r)
        hotelID, err := uuid.Parse(vars["hotel_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid hotel ID", err)
                return
        }</span>
        
        // Get review summary
        <span class="cov8" title="1">summary, err := h.reviewService.GetReviewSummary(ctx, hotelID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get review summary",
                        "hotel_id", hotelID,
                        "error", err,
                )
                h.writeErrorResponse(w, http.StatusNotFound, "Review summary not found", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    summary,
        })</span>
}

func (h *Handlers) GetTopRatedHotels(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get limit parameter
        limitStr := r.URL.Query().Get("limit")
        limit := 10
        if limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }
        
        // Get top rated hotels
        <span class="cov8" title="1">hotels, err := h.reviewService.GetTopRatedHotels(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get top rated hotels", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to get top rated hotels", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    hotels,
                Meta: &amp;Meta{
                        Limit: limit,
                },
        })</span>
}

func (h *Handlers) GetRecentReviews(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        
        // Get limit parameter
        limitStr := r.URL.Query().Get("limit")
        limit := 20
        if limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }
        
        // Get recent reviews
        <span class="cov8" title="1">reviews, err := h.reviewService.GetRecentReviews(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(ctx, "Failed to get recent reviews", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "Failed to get recent reviews", err)
                return
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, APIResponse{
                Success: true,
                Data:    reviews,
                Meta: &amp;Meta{
                        Limit: limit,
                },
        })</span>
}

// Helper methods
func (h *Handlers) parseJSONRequest(r *http.Request, target interface{}) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(r.Body)
        decoder.DisallowUnknownFields()
        return decoder.Decode(target)
}</span>

func (h *Handlers) validateRequest(req interface{}) error <span class="cov8" title="1">{
        // TODO: Implement request validation using a validation library
        // For now, return nil (basic validation should be implemented)
        return nil
}</span>

func (h *Handlers) writeJSONResponse(w http.ResponseWriter, statusCode int, response APIResponse) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(response)
}</span>

func (h *Handlers) writeErrorResponse(w http.ResponseWriter, statusCode int, message string, err error) <span class="cov8" title="1">{
        response := APIResponse{
                Success: false,
                Error:   message,
        }
        
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("API error", "message", message, "error", err)
        }</span>
        
        <span class="cov8" title="1">h.writeJSONResponse(w, statusCode, response)</span>
}

func (h *Handlers) getPaginationParams(r *http.Request) (limit, offset int) <span class="cov8" title="1">{
        limit = 20 // default limit
        offset = 0 // default offset
        
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }
        
        <span class="cov8" title="1">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov8" title="1">{
                        offset = o
                }</span>
        }
        
        // Support page-based pagination
        <span class="cov8" title="1">if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(pageStr); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        offset = (p - 1) * limit
                }</span>
        }
        
        <span class="cov8" title="1">return limit, offset</span>
}

func (h *Handlers) buildFilters(r *http.Request) map[string]interface{} <span class="cov8" title="1">{
        filters := make(map[string]interface{})
        
        if rating := r.URL.Query().Get("rating"); rating != "" </span><span class="cov0" title="0">{
                if r, err := strconv.ParseFloat(rating, 64); err == nil </span><span class="cov0" title="0">{
                        filters["rating"] = r
                }</span>
        }
        
        <span class="cov8" title="1">if minRating := r.URL.Query().Get("min_rating"); minRating != "" </span><span class="cov0" title="0">{
                if r, err := strconv.ParseFloat(minRating, 64); err == nil </span><span class="cov0" title="0">{
                        filters["min_rating"] = r
                }</span>
        }
        
        <span class="cov8" title="1">if maxRating := r.URL.Query().Get("max_rating"); maxRating != "" </span><span class="cov0" title="0">{
                if r, err := strconv.ParseFloat(maxRating, 64); err == nil </span><span class="cov0" title="0">{
                        filters["max_rating"] = r
                }</span>
        }
        
        <span class="cov8" title="1">if providerID := r.URL.Query().Get("provider_id"); providerID != "" </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(providerID); err == nil </span><span class="cov0" title="0">{
                        filters["provider_id"] = id
                }</span>
        }
        
        <span class="cov8" title="1">if hotelID := r.URL.Query().Get("hotel_id"); hotelID != "" </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(hotelID); err == nil </span><span class="cov0" title="0">{
                        filters["hotel_id"] = id
                }</span>
        }
        
        <span class="cov8" title="1">if language := r.URL.Query().Get("language"); language != "" </span><span class="cov0" title="0">{
                filters["language"] = language
        }</span>
        
        <span class="cov8" title="1">if sentiment := r.URL.Query().Get("sentiment"); sentiment != "" </span><span class="cov0" title="0">{
                filters["sentiment"] = sentiment
        }</span>
        
        <span class="cov8" title="1">if isVerified := r.URL.Query().Get("is_verified"); isVerified != "" </span><span class="cov0" title="0">{
                if verified, err := strconv.ParseBool(isVerified); err == nil </span><span class="cov0" title="0">{
                        filters["is_verified"] = verified
                }</span>
        }
        
        <span class="cov8" title="1">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters["start_date"] = date
                }</span>
        }
        
        <span class="cov8" title="1">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters["end_date"] = date
                }</span>
        }
        
        <span class="cov8" title="1">return filters</span>
}

func (h *Handlers) convertToReview(req *CreateReviewRequest) (*domain.Review, error) <span class="cov8" title="1">{
        providerID, err := uuid.Parse(req.ProviderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid provider ID: %w", err)
        }</span>
        
        <span class="cov8" title="1">hotelID, err := uuid.Parse(req.HotelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid hotel ID: %w", err)
        }</span>
        
        <span class="cov8" title="1">reviewerInfoID, err := uuid.Parse(req.ReviewerInfoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid reviewer info ID: %w", err)
        }</span>
        
        <span class="cov8" title="1">review := &amp;domain.Review{
                ID:                uuid.New(),
                ProviderID:        providerID,
                HotelID:           hotelID,
                ReviewerInfoID:    reviewerInfoID,
                ExternalID:        req.ExternalID,
                Rating:            req.Rating,
                Title:             req.Title,
                Comment:           req.Comment,
                ReviewDate:        req.ReviewDate,
                StayDate:          req.StayDate,
                TripType:          req.TripType,
                RoomType:          req.RoomType,
                Language:          req.Language,
                ServiceRating:     req.ServiceRating,
                CleanlinessRating: req.CleanlinessRating,
                LocationRating:    req.LocationRating,
                ValueRating:       req.ValueRating,
                ComfortRating:     req.ComfortRating,
                FacilitiesRating:  req.FacilitiesRating,
                Metadata:          req.Metadata,
        }
        
        return review, nil</span>
}

// SetupRoutes sets up all HTTP routes
func (h *Handlers) SetupRoutes(router *mux.Router) <span class="cov8" title="1">{
        // Health check
        router.HandleFunc("/health", h.HealthCheck).Methods("GET")
        
        // File processing
        router.HandleFunc("/process", h.ProcessFile).Methods("POST")
        router.HandleFunc("/processing/{id}", h.GetProcessingStatus).Methods("GET")
        router.HandleFunc("/processing/history/{provider_id}", h.GetProcessingHistory).Methods("GET")
        
        // Reviews
        router.HandleFunc("/reviews", h.CreateReview).Methods("POST")
        router.HandleFunc("/reviews/{id}", h.GetReview).Methods("GET")
        router.HandleFunc("/reviews", h.SearchReviews).Methods("GET")
        router.HandleFunc("/hotels/{hotel_id}/reviews", h.GetReviewsByHotel).Methods("GET")
        router.HandleFunc("/providers/{provider_id}/reviews", h.GetReviewsByProvider).Methods("GET")
        
        // Hotels
        router.HandleFunc("/hotels", h.CreateHotel).Methods("POST")
        router.HandleFunc("/hotels/{id}", h.GetHotel).Methods("GET")
        router.HandleFunc("/hotels", h.ListHotels).Methods("GET")
        
        // Providers
        router.HandleFunc("/providers", h.CreateProvider).Methods("POST")
        router.HandleFunc("/providers/{id}", h.GetProvider).Methods("GET")
        router.HandleFunc("/providers", h.ListProviders).Methods("GET")
        
        // Analytics
        router.HandleFunc("/hotels/{hotel_id}/summary", h.GetReviewSummary).Methods("GET")
        router.HandleFunc("/analytics/top-hotels", h.GetTopRatedHotels).Methods("GET")
        router.HandleFunc("/analytics/recent-reviews", h.GetRecentReviews).Methods("GET")
}</span>

// Middleware
func (h *Handlers) LoggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return logger.RequestLoggerMiddleware(h.logger)(next)
}</span>

func (h *Handlers) RecoveryMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return logger.RecoveryMiddleware(h.logger)(next)
}</span>

func (h *Handlers) CORSMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID, X-Correlation-ID")
                
                if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>
                
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func (h *Handlers) ContentTypeMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method == "POST" || r.Method == "PUT" </span><span class="cov8" title="1">{
                        contentType := r.Header.Get("Content-Type")
                        if !strings.HasPrefix(contentType, "application/json") </span><span class="cov8" title="1">{
                                h.writeErrorResponse(w, http.StatusUnsupportedMediaType, "Content-Type must be application/json", nil)
                                return
                        }</span>
                }
                
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}</pre>
		
		<pre class="file" id="file2" style="display: none">package application

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ProcessingEngine orchestrates file processing with worker pools and concurrency control
type ProcessingEngine struct {
        reviewService       domain.ReviewService
        s3Client           domain.S3Client
        jsonProcessor      domain.JSONProcessor
        logger             *logger.Logger
        
        // Worker pool configuration
        maxWorkers         int
        maxConcurrentFiles int
        workerPool         chan *worker
        fileQueue          chan *ProcessingJob
        
        // Processing state
        activeJobs         map[uuid.UUID]*ProcessingJob
        jobsMutex          sync.RWMutex
        
        // Metrics and monitoring
        metrics            *ProcessingMetrics
        
        // Lifecycle management
        ctx                context.Context
        cancel             context.CancelFunc
        wg                 sync.WaitGroup
        started            bool
        shutdown           chan struct{}
}

// ProcessingJob represents a file processing job
type ProcessingJob struct {
        mu               sync.RWMutex
        ID               uuid.UUID
        ProviderID       uuid.UUID
        FileURL          string
        Status           ProcessingStatus
        StartTime        time.Time
        EndTime          time.Time
        RecordsTotal     int64
        RecordsProcessed int64
        ErrorCount       int64
        ErrorMessage     string
        RetryCount       int
        MaxRetries       int
        Worker           *worker
        Context          context.Context
        Cancel           context.CancelFunc
}

// ProcessingStatus represents the status of a processing job
type ProcessingStatus string

const (
        StatusPending    ProcessingStatus = "pending"
        StatusRunning    ProcessingStatus = "running"
        StatusCompleted  ProcessingStatus = "completed"
        StatusFailed     ProcessingStatus = "failed"
        StatusCancelled  ProcessingStatus = "cancelled"
        StatusRetrying   ProcessingStatus = "retrying"
)

// worker represents a processing worker
type worker struct {
        mu           sync.RWMutex
        id           int
        engine       *ProcessingEngine
        busy         bool
        currentJob   *ProcessingJob
        lastActivity time.Time
}

// ProcessingMetrics tracks processing statistics
type ProcessingMetrics struct {
        mu                    sync.RWMutex
        TotalJobsProcessed    int64
        TotalRecordsProcessed int64
        TotalErrors           int64
        ActiveWorkers         int
        QueuedJobs            int
        ProcessingRate        float64
        AverageProcessingTime time.Duration
        LastProcessingTime    time.Time
}

// ProcessingConfig contains configuration for the processing engine
type ProcessingConfig struct {
        MaxWorkers         int
        MaxConcurrentFiles int
        MaxRetries         int
        RetryDelay         time.Duration
        ProcessingTimeout  time.Duration
        WorkerIdleTimeout  time.Duration
        MetricsInterval    time.Duration
}

// NewProcessingEngine creates a new processing engine
func NewProcessingEngine(
        reviewService domain.ReviewService,
        s3Client domain.S3Client,
        jsonProcessor domain.JSONProcessor,
        logger *logger.Logger,
        config *ProcessingConfig,
) *ProcessingEngine <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        
        engine := &amp;ProcessingEngine{
                reviewService:       reviewService,
                s3Client:           s3Client,
                jsonProcessor:      jsonProcessor,
                logger:             logger,
                maxWorkers:         config.MaxWorkers,
                maxConcurrentFiles: config.MaxConcurrentFiles,
                workerPool:         make(chan *worker, config.MaxWorkers),
                fileQueue:          make(chan *ProcessingJob, config.MaxConcurrentFiles*2),
                activeJobs:         make(map[uuid.UUID]*ProcessingJob),
                metrics:            &amp;ProcessingMetrics{},
                ctx:                ctx,
                cancel:             cancel,
                shutdown:           make(chan struct{}),
        }
        
        return engine
}</span>

// Start starts the processing engine
func (e *ProcessingEngine) Start() error <span class="cov8" title="1">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()
        
        if e.started </span><span class="cov8" title="1">{
                return fmt.Errorf("processing engine already started")
        }</span>
        
        <span class="cov8" title="1">e.logger.Info("Starting processing engine",
                "max_workers", e.maxWorkers,
                "max_concurrent_files", e.maxConcurrentFiles,
        )
        
        // Start worker pool
        e.startWorkerPool()
        
        // Start job dispatcher
        e.wg.Add(1)
        go e.jobDispatcher()
        
        // Start metrics collector
        e.wg.Add(1)
        go e.metricsCollector()
        
        e.started = true
        e.logger.Info("Processing engine started successfully")
        
        return nil</span>
}

// Stop stops the processing engine gracefully
func (e *ProcessingEngine) Stop() error <span class="cov8" title="1">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()
        
        if !e.started </span><span class="cov8" title="1">{
                return fmt.Errorf("processing engine not started")
        }</span>
        
        <span class="cov8" title="1">e.logger.Info("Stopping processing engine...")
        
        // Cancel all active jobs
        for _, job := range e.activeJobs </span><span class="cov8" title="1">{
                if job.Cancel != nil </span><span class="cov8" title="1">{
                        job.Cancel()
                }</span>
        }
        
        // Signal shutdown
        <span class="cov8" title="1">e.cancel()
        close(e.shutdown)
        
        // Wait for all goroutines to finish
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                e.wg.Wait()
                close(done)
        }</span>()
        
        // Mark as stopped first to prevent double stopping
        <span class="cov8" title="1">e.started = false
        
        // Wait for graceful shutdown with timeout
        select </span>{
        case &lt;-done:<span class="cov8" title="1">
                e.logger.Info("Processing engine stopped gracefully")
                return nil</span>
        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                e.logger.Warn("Processing engine shutdown timeout, forcing stop")
                return fmt.Errorf("shutdown timeout")</span>
        }
}

// SubmitJob submits a new file processing job
func (e *ProcessingEngine) SubmitJob(ctx context.Context, providerID uuid.UUID, fileURL string) (*ProcessingJob, error) <span class="cov8" title="1">{
        // Check if engine is started
        if !e.started </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("processing engine not started")
        }</span>
        
        // Validate file URL format
        <span class="cov8" title="1">_, _, err := e.parseS3URL(fileURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid file URL: %w", err)
        }</span>
        
        // Check for idempotency
        <span class="cov8" title="1">if existingJob, exists := e.checkIdempotency(providerID, fileURL); exists </span><span class="cov8" title="1">{
                e.logger.InfoContext(ctx, "Idempotent job found, returning existing job",
                        "job_id", existingJob.ID,
                        "provider_id", providerID,
                        "file_url", fileURL,
                )
                return existingJob, nil
        }</span>
        
        // Create new job
        <span class="cov8" title="1">jobCtx, jobCancel := context.WithCancel(ctx)
        job := &amp;ProcessingJob{
                ID:           uuid.New(),
                ProviderID:   providerID,
                FileURL:      fileURL,
                Status:       StatusPending,
                StartTime:    time.Now(),
                MaxRetries:   3,
                Context:      jobCtx,
                Cancel:       jobCancel,
        }
        
        // Register job
        e.jobsMutex.Lock()
        e.activeJobs[job.ID] = job
        e.jobsMutex.Unlock()
        
        // Submit to queue
        select </span>{
        case e.fileQueue &lt;- job:<span class="cov8" title="1">
                e.logger.InfoContext(ctx, "Job submitted successfully",
                        "job_id", job.ID,
                        "provider_id", providerID,
                        "file_url", fileURL,
                )
                return job, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                e.removeJob(job.ID)
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                e.removeJob(job.ID)
                return nil, fmt.Errorf("processing queue full, try again later")</span>
        }
}

// GetJobStatus returns the status of a processing job
func (e *ProcessingEngine) GetJobStatus(jobID uuid.UUID) (*ProcessingJob, bool) <span class="cov8" title="1">{
        e.jobsMutex.RLock()
        defer e.jobsMutex.RUnlock()
        
        job, exists := e.activeJobs[jobID]
        return job, exists
}</span>

// CancelJob cancels a processing job
func (e *ProcessingEngine) CancelJob(jobID uuid.UUID) error <span class="cov8" title="1">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()
        
        job, exists := e.activeJobs[jobID]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("job not found")
        }</span>
        
        <span class="cov8" title="1">if job.Cancel != nil </span><span class="cov8" title="1">{
                job.Cancel()
        }</span>
        
        <span class="cov8" title="1">job.mu.Lock()
        job.Status = StatusCancelled
        job.EndTime = time.Now()
        job.mu.Unlock()
        
        e.logger.Info("Job cancelled", "job_id", jobID)
        return nil</span>
}

// GetMetrics returns current processing metrics
func (e *ProcessingEngine) GetMetrics() *ProcessingMetrics <span class="cov8" title="1">{
        e.metrics.mu.RLock()
        defer e.metrics.mu.RUnlock()
        
        // Create a copy to avoid race conditions
        metrics := &amp;ProcessingMetrics{
                TotalJobsProcessed:    e.metrics.TotalJobsProcessed,
                TotalRecordsProcessed: e.metrics.TotalRecordsProcessed,
                TotalErrors:           e.metrics.TotalErrors,
                ActiveWorkers:         e.metrics.ActiveWorkers,
                QueuedJobs:            e.metrics.QueuedJobs,
                ProcessingRate:        e.metrics.ProcessingRate,
                AverageProcessingTime: e.metrics.AverageProcessingTime,
                LastProcessingTime:    e.metrics.LastProcessingTime,
        }
        
        return metrics
}</span>

// startWorkerPool initializes and starts the worker pool
func (e *ProcessingEngine) startWorkerPool() <span class="cov8" title="1">{
        for i := 0; i &lt; e.maxWorkers; i++ </span><span class="cov8" title="1">{
                worker := &amp;worker{
                        id:           i,
                        engine:       e,
                        lastActivity: time.Now(),
                }
                
                e.workerPool &lt;- worker
                
                e.wg.Add(1)
                go e.workerLoop(worker)
        }</span>
        
        <span class="cov8" title="1">e.logger.Info("Worker pool started", "workers", e.maxWorkers)</span>
}

// workerLoop is the main loop for a worker
func (e *ProcessingEngine) workerLoop(w *worker) <span class="cov8" title="1">{
        defer e.wg.Done()
        
        e.logger.Debug("Worker started", "worker_id", w.id)
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        e.logger.Debug("Worker stopping", "worker_id", w.id)
                        return</span>
                default:<span class="cov8" title="1">
                        // Worker is available, put it back in pool
                        select </span>{
                        case e.workerPool &lt;- w:<span class="cov8" title="1">
                                w.mu.Lock()
                                w.busy = false
                                w.lastActivity = time.Now()
                                w.mu.Unlock()</span>
                        case &lt;-e.ctx.Done():<span class="cov8" title="1">
                                return</span>
                        }
                }
        }
}

// jobDispatcher dispatches jobs to available workers
func (e *ProcessingEngine) jobDispatcher() <span class="cov8" title="1">{
        defer e.wg.Done()
        
        e.logger.Info("Job dispatcher started")
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov8" title="1">
                        e.logger.Info("Job dispatcher stopping")
                        return</span>
                case job := &lt;-e.fileQueue:<span class="cov8" title="1">
                        e.dispatchJob(job)</span>
                }
        }
}

// dispatchJob dispatches a single job to an available worker
func (e *ProcessingEngine) dispatchJob(job *ProcessingJob) <span class="cov8" title="1">{
        select </span>{
        case &lt;-e.ctx.Done():<span class="cov0" title="0">
                e.updateJobStatus(job, StatusCancelled, "System shutdown")
                return</span>
        case worker := &lt;-e.workerPool:<span class="cov8" title="1">
                worker.mu.Lock()
                worker.busy = true
                worker.currentJob = job
                worker.mu.Unlock()
                job.Worker = worker
                
                e.wg.Add(1)
                go e.processJobWithWorker(worker, job)
                
                e.logger.Info("Job dispatched to worker",
                        "job_id", job.ID,
                        "worker_id", worker.id,
                        "file_url", job.FileURL,
                )</span>
        }
}

// processJobWithWorker processes a job with a specific worker
func (e *ProcessingEngine) processJobWithWorker(w *worker, job *ProcessingJob) <span class="cov8" title="1">{
        defer e.wg.Done()
        
        e.updateJobStatus(job, StatusRunning, "")
        
        // Process the job
        err := e.processFile(job)
        
        // Handle job completion
        if err != nil </span><span class="cov8" title="1">{
                job.mu.Lock()
                retryCount := job.RetryCount
                maxRetries := job.MaxRetries
                if retryCount &lt; maxRetries </span><span class="cov8" title="1">{
                        job.RetryCount++
                        retryCount = job.RetryCount
                        job.mu.Unlock()
                        
                        e.updateJobStatus(job, StatusRetrying, fmt.Sprintf("Retry %d/%d: %v", retryCount, maxRetries, err))
                        
                        // Retry with exponential backoff
                        retryDelay := time.Duration(retryCount) * time.Second
                        time.Sleep(retryDelay)
                        
                        // Requeue the job
                        select </span>{
                        case e.fileQueue &lt;- job:<span class="cov8" title="1">
                                e.logger.Info("Job requeued for retry",
                                        "job_id", job.ID,
                                        "retry_count", retryCount,
                                )</span>
                        default:<span class="cov0" title="0">
                                e.updateJobStatus(job, StatusFailed, "Failed to requeue for retry")</span>
                        }
                } else<span class="cov0" title="0"> {
                        job.mu.Unlock()
                        e.updateJobStatus(job, StatusFailed, err.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                e.updateJobStatus(job, StatusCompleted, "")
        }</span>
        
        // Clean up worker
        <span class="cov8" title="1">w.mu.Lock()
        w.currentJob = nil
        w.lastActivity = time.Now()
        w.mu.Unlock()</span>
}

// processFile processes a single file
func (e *ProcessingEngine) processFile(job *ProcessingJob) error <span class="cov8" title="1">{
        ctx := job.Context
        
        e.logger.InfoContext(ctx, "Starting file processing",
                "job_id", job.ID,
                "file_url", job.FileURL,
                "provider_id", job.ProviderID,
        )
        
        // Download file from S3
        bucket, key, err := e.parseS3URL(job.FileURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid S3 URL: %w", err)
        }</span>
        
        // Check if file exists
        <span class="cov8" title="1">exists, err := e.s3Client.FileExists(ctx, bucket, key)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check file existence: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("file does not exist: %s", job.FileURL)
        }</span>
        
        // Get file size for progress tracking
        <span class="cov8" title="1">fileSize, err := e.s3Client.GetFileSize(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.WarnContext(ctx, "Failed to get file size", "error", err)
        }</span>
        
        // Download file
        <span class="cov8" title="1">reader, err := e.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()
        
        // Count records for progress tracking
        recordCount, err := e.jsonProcessor.CountRecords(ctx, reader)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.WarnContext(ctx, "Failed to count records", "error", err)
        }</span> else<span class="cov8" title="1"> {
                job.RecordsTotal = int64(recordCount)
        }</span>
        
        // Re-download for processing (since we consumed the reader)
        <span class="cov8" title="1">reader, err = e.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to re-download file: %w", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()
        
        // Process the file
        err = e.jsonProcessor.ProcessFile(ctx, reader, job.ProviderID, job.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process file: %w", err)
        }</span>
        
        <span class="cov8" title="1">e.logger.InfoContext(ctx, "File processing completed successfully",
                "job_id", job.ID,
                "file_url", job.FileURL,
                "file_size", fileSize,
                "records_total", job.RecordsTotal,
        )
        
        return nil</span>
}

// updateJobStatus updates the status of a job
func (e *ProcessingEngine) updateJobStatus(job *ProcessingJob, status ProcessingStatus, errorMessage string) <span class="cov8" title="1">{
        job.mu.Lock()
        job.Status = status
        job.ErrorMessage = errorMessage
        job.mu.Unlock()
        
        if status == StatusCompleted || status == StatusFailed || status == StatusCancelled </span><span class="cov0" title="0">{
                job.EndTime = time.Now()
                
                // Update metrics
                e.metrics.mu.Lock()
                e.metrics.TotalJobsProcessed++
                e.metrics.TotalRecordsProcessed += job.RecordsProcessed
                if status == StatusFailed </span><span class="cov0" title="0">{
                        e.metrics.TotalErrors++
                }</span>
                <span class="cov0" title="0">e.metrics.LastProcessingTime = time.Now()
                e.metrics.mu.Unlock()
                
                // Remove from active jobs after a delay to allow status queries
                go func() </span><span class="cov0" title="0">{
                        time.Sleep(5 * time.Minute)
                        e.removeJob(job.ID)
                }</span>()
        }
        
        // Note: Processing status updates are handled by the ReviewService layer
        
        <span class="cov8" title="1">e.logger.InfoContext(job.Context, "Job status updated",
                "job_id", job.ID,
                "status", status,
                "error_message", errorMessage,
        )</span>
}

// checkIdempotency checks if a similar job is already running
func (e *ProcessingEngine) checkIdempotency(providerID uuid.UUID, fileURL string) (*ProcessingJob, bool) <span class="cov8" title="1">{
        e.jobsMutex.RLock()
        defer e.jobsMutex.RUnlock()
        
        for _, job := range e.activeJobs </span><span class="cov8" title="1">{
                if job.ProviderID == providerID &amp;&amp; job.FileURL == fileURL </span><span class="cov8" title="1">{
                        job.mu.RLock()
                        status := job.Status
                        job.mu.RUnlock()
                        if status == StatusPending || status == StatusRunning || status == StatusRetrying </span><span class="cov8" title="1">{
                                return job, true
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return nil, false</span>
}

// removeJob removes a job from active jobs
func (e *ProcessingEngine) removeJob(jobID uuid.UUID) <span class="cov0" title="0">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()
        
        delete(e.activeJobs, jobID)
}</span>

// metricsCollector collects and updates processing metrics
func (e *ProcessingEngine) metricsCollector() <span class="cov8" title="1">{
        defer e.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        e.updateMetrics()</span>
                }
        }
}

// updateMetrics updates processing metrics
func (e *ProcessingEngine) updateMetrics() <span class="cov0" title="0">{
        e.metrics.mu.Lock()
        defer e.metrics.mu.Unlock()
        
        e.jobsMutex.RLock()
        activeJobs := len(e.activeJobs)
        e.jobsMutex.RUnlock()
        
        e.metrics.QueuedJobs = len(e.fileQueue)
        e.metrics.ActiveWorkers = e.maxWorkers - len(e.workerPool)
        
        // Calculate processing rate (jobs per minute)
        if e.metrics.TotalJobsProcessed &gt; 0 </span><span class="cov0" title="0">{
                duration := time.Since(e.metrics.LastProcessingTime)
                if duration &gt; 0 </span><span class="cov0" title="0">{
                        e.metrics.ProcessingRate = float64(e.metrics.TotalJobsProcessed) / duration.Minutes()
                }</span>
        }
        
        <span class="cov0" title="0">e.logger.Debug("Metrics updated",
                "total_jobs_processed", e.metrics.TotalJobsProcessed,
                "total_records_processed", e.metrics.TotalRecordsProcessed,
                "total_errors", e.metrics.TotalErrors,
                "active_workers", e.metrics.ActiveWorkers,
                "queued_jobs", e.metrics.QueuedJobs,
                "processing_rate", e.metrics.ProcessingRate,
                "active_jobs", activeJobs,
        )</span>
}

// parseS3URL parses an S3 URL into bucket and key components
func (e *ProcessingEngine) parseS3URL(url string) (bucket, key string, err error) <span class="cov8" title="1">{
        var path string
        
        // Handle different S3 URL formats
        if strings.HasPrefix(url, "s3://") </span><span class="cov0" title="0">{
                // s3://bucket/key format
                path = strings.TrimPrefix(url, "s3://")
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(url, "https://") </span><span class="cov8" title="1">{
                // Handle HTTPS S3 URLs
                if strings.Contains(url, ".s3.amazonaws.com/") </span><span class="cov8" title="1">{
                        // https://bucket.s3.amazonaws.com/key format
                        url = strings.TrimPrefix(url, "https://")
                        parts := strings.SplitN(url, ".s3.amazonaws.com/", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                        }</span>
                        <span class="cov8" title="1">return parts[0], parts[1], nil</span>
                } else<span class="cov8" title="1"> if strings.Contains(url, "s3.amazonaws.com/") </span><span class="cov8" title="1">{
                        // https://s3.amazonaws.com/bucket/key format
                        url = strings.TrimPrefix(url, "https://s3.amazonaws.com/")
                        parts := strings.SplitN(url, "/", 2)
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                        }</span>
                        <span class="cov8" title="1">return parts[0], parts[1], nil</span>
                } else<span class="cov0" title="0"> {
                        return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                }</span>
        } else<span class="cov8" title="1"> {
                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
        }</span>
        
        // For s3:// format
        <span class="cov0" title="0">parts := strings.SplitN(path, "/", 2)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
        }</span>
        
        <span class="cov0" title="0">return parts[0], parts[1], nil</span>
}

// BackpressureController manages backpressure for the processing engine
type BackpressureController struct {
        engine           *ProcessingEngine
        maxQueueSize     int
        maxMemoryUsage   int64
        currentMemoryUsage int64
        mu               sync.RWMutex
}

// NewBackpressureController creates a new backpressure controller
func NewBackpressureController(engine *ProcessingEngine, maxQueueSize int, maxMemoryUsage int64) *BackpressureController <span class="cov8" title="1">{
        return &amp;BackpressureController{
                engine:         engine,
                maxQueueSize:   maxQueueSize,
                maxMemoryUsage: maxMemoryUsage,
        }
}</span>

// ShouldAcceptJob determines if a new job should be accepted based on backpressure
func (bc *BackpressureController) ShouldAcceptJob() bool <span class="cov8" title="1">{
        bc.mu.RLock()
        defer bc.mu.RUnlock()
        
        // Check queue size
        if len(bc.engine.fileQueue) &gt;= bc.maxQueueSize </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check memory usage
        <span class="cov8" title="1">if bc.currentMemoryUsage &gt;= bc.maxMemoryUsage </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">return true</span>
}

// UpdateMemoryUsage updates the current memory usage
func (bc *BackpressureController) UpdateMemoryUsage(usage int64) <span class="cov8" title="1">{
        bc.mu.Lock()
        defer bc.mu.Unlock()
        
        bc.currentMemoryUsage = usage
}</span>

// JobProgressTracker tracks the progress of individual jobs
type JobProgressTracker struct {
        job       *ProcessingJob
        logger    *logger.Logger
        lastUpdate time.Time
        mu        sync.RWMutex
}

// NewJobProgressTracker creates a new job progress tracker
func NewJobProgressTracker(job *ProcessingJob, logger *logger.Logger) *JobProgressTracker <span class="cov8" title="1">{
        return &amp;JobProgressTracker{
                job:       job,
                logger:    logger,
                lastUpdate: time.Now(),
        }
}</span>

// UpdateProgress updates the progress of a job
func (jpt *JobProgressTracker) UpdateProgress(recordsProcessed int64) <span class="cov8" title="1">{
        jpt.mu.Lock()
        defer jpt.mu.Unlock()
        
        jpt.job.RecordsProcessed = recordsProcessed
        
        // Log progress every 10 seconds
        if time.Since(jpt.lastUpdate) &gt; 10*time.Second </span><span class="cov0" title="0">{
                progress := float64(recordsProcessed) / float64(jpt.job.RecordsTotal) * 100
                jpt.logger.InfoContext(jpt.job.Context, "Job progress update",
                        "job_id", jpt.job.ID,
                        "records_processed", recordsProcessed,
                        "records_total", jpt.job.RecordsTotal,
                        "progress_percent", fmt.Sprintf("%.2f%%", progress),
                )
                jpt.lastUpdate = time.Now()
        }</span>
}

// GetProgress returns the current progress of a job
func (jpt *JobProgressTracker) GetProgress() (int64, int64, float64) <span class="cov8" title="1">{
        jpt.mu.RLock()
        defer jpt.mu.RUnlock()
        
        processed := jpt.job.RecordsProcessed
        total := jpt.job.RecordsTotal
        
        var progress float64
        if total &gt; 0 </span><span class="cov8" title="1">{
                progress = float64(processed) / float64(total) * 100
        }</span>
        
        <span class="cov8" title="1">return processed, total, progress</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/google/uuid"
)

// ReviewServiceImpl implements the ReviewService interface
type ReviewServiceImpl struct {
        reviewRepo          ReviewRepository
        s3Client            S3Client
        jsonProcessor       JSONProcessor
        notificationService NotificationService
        cacheService        CacheService
        metricsService      MetricsService
        eventPublisher      EventPublisher
        logger              *slog.Logger
}

// NewReviewService creates a new ReviewService instance
func NewReviewService(
        reviewRepo ReviewRepository,
        s3Client S3Client,
        jsonProcessor JSONProcessor,
        notificationService NotificationService,
        cacheService CacheService,
        metricsService MetricsService,
        eventPublisher EventPublisher,
        logger *slog.Logger,
) ReviewService <span class="cov8" title="1">{
        return &amp;ReviewServiceImpl{
                reviewRepo:          reviewRepo,
                s3Client:            s3Client,
                jsonProcessor:       jsonProcessor,
                notificationService: notificationService,
                cacheService:        cacheService,
                metricsService:      metricsService,
                eventPublisher:      eventPublisher,
                logger:              logger,
        }
}</span>

// Review operations
func (s *ReviewServiceImpl) CreateReview(ctx context.Context, review *Review) error <span class="cov8" title="1">{
        if err := s.ValidateReviewData(ctx, review); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.EnrichReviewData(ctx, review); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to enrich review data", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.CreateBatch(ctx, []Review{*review}); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishReviewCreated(ctx, review); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to publish review created event", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov8" title="1">if err := s.cacheService.InvalidateReviewSummary(ctx, review.HotelID); err != nil </span><span class="cov8" title="1">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", review.HotelID)
        }</span>

        <span class="cov8" title="1">s.metricsService.IncrementCounter(ctx, "reviews_created", map[string]string{
                "provider_id": review.ProviderID.String(),
                "hotel_id":    review.HotelID.String(),
        })

        return nil</span>
}

func (s *ReviewServiceImpl) GetReviewByID(ctx context.Context, id uuid.UUID) (*Review, error) <span class="cov8" title="1">{
        review, err := s.reviewRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get review: %w", err)
        }</span>
        <span class="cov8" title="1">return review, nil</span>
}

func (s *ReviewServiceImpl) GetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]Review, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.GetByHotel(ctx, hotelID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>
        <span class="cov8" title="1">return reviews, nil</span>
}

func (s *ReviewServiceImpl) GetReviewsByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]Review, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.GetByProvider(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by provider: %w", err)
        }</span>
        <span class="cov8" title="1">return reviews, nil</span>
}

func (s *ReviewServiceImpl) UpdateReview(ctx context.Context, review *Review) error <span class="cov8" title="1">{
        if err := s.ValidateReviewData(ctx, review); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">existingReview, err := s.reviewRepo.GetByID(ctx, review.ID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get existing review: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.CreateBatch(ctx, []Review{*review}); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update review: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishReviewUpdated(ctx, review); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to publish review updated event", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov8" title="1">if existingReview.HotelID != review.HotelID </span><span class="cov8" title="1">{
                s.cacheService.InvalidateReviewSummary(ctx, existingReview.HotelID)
        }</span>
        <span class="cov8" title="1">s.cacheService.InvalidateReviewSummary(ctx, review.HotelID)

        return nil</span>
}

func (s *ReviewServiceImpl) DeleteReview(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        review, err := s.reviewRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get review: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.DeleteByID(ctx, id); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete review: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishReviewDeleted(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish review deleted event", "error", err, "review_id", id)
        }</span>

        <span class="cov8" title="1">if err := s.cacheService.InvalidateReviewSummary(ctx, review.HotelID); err != nil </span><span class="cov8" title="1">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", review.HotelID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) SearchReviews(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]Review, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.Search(ctx, query, filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search reviews: %w", err)
        }</span>
        <span class="cov8" title="1">return reviews, nil</span>
}

// Hotel operations
func (s *ReviewServiceImpl) CreateHotel(ctx context.Context, hotel *Hotel) error <span class="cov8" title="1">{
        if err := s.validateHotel(ctx, hotel); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.CreateHotel(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create hotel: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishHotelCreated(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish hotel created event", "error", err, "hotel_id", hotel.ID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) GetHotelByID(ctx context.Context, id uuid.UUID) (*Hotel, error) <span class="cov8" title="1">{
        hotel, err := s.reviewRepo.GetHotelByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get hotel: %w", err)
        }</span>
        <span class="cov8" title="1">return hotel, nil</span>
}

func (s *ReviewServiceImpl) UpdateHotel(ctx context.Context, hotel *Hotel) error <span class="cov8" title="1">{
        if err := s.validateHotel(ctx, hotel); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.UpdateHotel(ctx, hotel); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update hotel: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishHotelUpdated(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish hotel updated event", "error", err, "hotel_id", hotel.ID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) DeleteHotel(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        if err := s.reviewRepo.DeleteHotel(ctx, id); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete hotel: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.cacheService.InvalidateReviewSummary(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) ListHotels(ctx context.Context, limit, offset int) ([]Hotel, error) <span class="cov8" title="1">{
        hotels, err := s.reviewRepo.ListHotels(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list hotels: %w", err)
        }</span>
        <span class="cov8" title="1">return hotels, nil</span>
}

// Provider operations
func (s *ReviewServiceImpl) CreateProvider(ctx context.Context, provider *Provider) error <span class="cov8" title="1">{
        if err := s.validateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.CreateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create provider: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) GetProviderByID(ctx context.Context, id uuid.UUID) (*Provider, error) <span class="cov8" title="1">{
        provider, err := s.reviewRepo.GetProviderByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider: %w", err)
        }</span>
        <span class="cov8" title="1">return provider, nil</span>
}

func (s *ReviewServiceImpl) GetProviderByName(ctx context.Context, name string) (*Provider, error) <span class="cov8" title="1">{
        provider, err := s.reviewRepo.GetProviderByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider by name: %w", err)
        }</span>
        <span class="cov8" title="1">return provider, nil</span>
}

func (s *ReviewServiceImpl) UpdateProvider(ctx context.Context, provider *Provider) error <span class="cov8" title="1">{
        if err := s.validateProvider(ctx, provider); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.reviewRepo.UpdateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update provider: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) DeleteProvider(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        if err := s.reviewRepo.DeleteProvider(ctx, id); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete provider: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) ListProviders(ctx context.Context, limit, offset int) ([]Provider, error) <span class="cov8" title="1">{
        providers, err := s.reviewRepo.ListProviders(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list providers: %w", err)
        }</span>
        <span class="cov8" title="1">return providers, nil</span>
}

// File processing operations
func (s *ReviewServiceImpl) ProcessReviewFile(ctx context.Context, fileURL string, providerID uuid.UUID) (*ReviewProcessingStatus, error) <span class="cov8" title="1">{
        processingID := uuid.New()
        
        processingStatus := &amp;ReviewProcessingStatus{
                ID:               processingID,
                ProviderID:       providerID,
                Status:           "pending",
                FileURL:          fileURL,
                RecordsProcessed: 0,
                RecordsTotal:     0,
        }

        if err := s.reviewRepo.CreateProcessingStatus(ctx, processingStatus); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create processing status: %w", err)
        }</span>

        <span class="cov8" title="1">go s.processFileAsync(context.Background(), processingID, fileURL, providerID)

        return processingStatus, nil</span>
}

func (s *ReviewServiceImpl) processFileAsync(ctx context.Context, processingID uuid.UUID, fileURL string, providerID uuid.UUID) <span class="cov8" title="1">{
        startTime := time.Now()
        
        if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "processing", 0, ""); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status", "error", err, "processing_id", processingID)
                return
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishProcessingStarted(ctx, processingID, providerID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing started event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov8" title="1">bucket, key, err := s.parseS3URL(fileURL)
        if err != nil </span><span class="cov0" title="0">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Invalid S3 URL: %v", err))
                return
        }</span>

        <span class="cov8" title="1">reader, err := s.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov8" title="1">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Failed to download file: %v", err))
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        if err := s.jsonProcessor.ProcessFile(ctx, reader, providerID, processingID); err != nil </span><span class="cov0" title="0">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Failed to process file: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "completed", 0, ""); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status to completed", "error", err, "processing_id", processingID)
                return
        }</span>

        <span class="cov0" title="0">if err := s.eventPublisher.PublishProcessingCompleted(ctx, processingID, 0); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing completed event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov0" title="0">if err := s.notificationService.SendProcessingComplete(ctx, processingID, "completed", 0); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to send processing complete notification", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov0" title="0">s.metricsService.RecordProcessingTime(ctx, processingID, time.Since(startTime))</span>
}

func (s *ReviewServiceImpl) handleProcessingError(ctx context.Context, processingID uuid.UUID, errorMsg string) <span class="cov8" title="1">{
        s.logger.Error("Processing failed", "processing_id", processingID, "error", errorMsg)
        
        if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "failed", 0, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status to failed", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov8" title="1">if err := s.eventPublisher.PublishProcessingFailed(ctx, processingID, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing failed event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov8" title="1">if err := s.notificationService.SendProcessingFailed(ctx, processingID, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to send processing failed notification", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov8" title="1">s.metricsService.IncrementCounter(ctx, "processing_errors", map[string]string{
                "processing_id": processingID.String(),
        })</span>
}

func (s *ReviewServiceImpl) GetProcessingStatus(ctx context.Context, id uuid.UUID) (*ReviewProcessingStatus, error) <span class="cov8" title="1">{
        status, err := s.reviewRepo.GetProcessingStatusByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing status: %w", err)
        }</span>
        <span class="cov8" title="1">return status, nil</span>
}

func (s *ReviewServiceImpl) GetProcessingHistory(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]ReviewProcessingStatus, error) <span class="cov8" title="1">{
        history, err := s.reviewRepo.GetProcessingStatusByProvider(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing history: %w", err)
        }</span>
        <span class="cov8" title="1">return history, nil</span>
}

func (s *ReviewServiceImpl) CancelProcessing(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        if err := s.reviewRepo.UpdateProcessingStatus(ctx, id, "cancelled", 0, "Processing cancelled by user"); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to cancel processing: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Analytics operations
func (s *ReviewServiceImpl) GetReviewSummary(ctx context.Context, hotelID uuid.UUID) (*ReviewSummary, error) <span class="cov8" title="1">{
        if summary, err := s.cacheService.GetReviewSummary(ctx, hotelID); err == nil </span><span class="cov8" title="1">{
                return summary, nil
        }</span>

        <span class="cov8" title="1">summary, err := s.reviewRepo.GetReviewSummaryByHotelID(ctx, hotelID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get review summary: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.cacheService.SetReviewSummary(ctx, hotelID, summary, 1*time.Hour); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache review summary", "error", err, "hotel_id", hotelID)
        }</span>

        <span class="cov8" title="1">return summary, nil</span>
}

func (s *ReviewServiceImpl) GetReviewStatsByProvider(ctx context.Context, providerID uuid.UUID, startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.GetByDateRange(ctx, startDate, endDate, 1000, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get reviews by date range: %w", err)
        }</span>

        <span class="cov8" title="1">stats := make(map[string]interface{})
        var totalReviews int
        var totalRating float64

        for _, review := range reviews </span><span class="cov8" title="1">{
                if review.ProviderID == providerID </span><span class="cov8" title="1">{
                        totalReviews++
                        totalRating += review.Rating
                }</span>
        }

        <span class="cov8" title="1">if totalReviews &gt; 0 </span><span class="cov8" title="1">{
                stats["total_reviews"] = totalReviews
                stats["average_rating"] = totalRating / float64(totalReviews)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

func (s *ReviewServiceImpl) GetReviewStatsByHotel(ctx context.Context, hotelID uuid.UUID, startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.GetByHotel(ctx, hotelID, 1000, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>

        <span class="cov8" title="1">stats := make(map[string]interface{})
        var totalReviews int
        var totalRating float64

        for _, review := range reviews </span><span class="cov8" title="1">{
                if review.ReviewDate.After(startDate) &amp;&amp; review.ReviewDate.Before(endDate) </span><span class="cov8" title="1">{
                        totalReviews++
                        totalRating += review.Rating
                }</span>
        }

        <span class="cov8" title="1">if totalReviews &gt; 0 </span><span class="cov8" title="1">{
                stats["total_reviews"] = totalReviews
                stats["average_rating"] = totalRating / float64(totalReviews)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

func (s *ReviewServiceImpl) GetTopRatedHotels(ctx context.Context, limit int) ([]Hotel, error) <span class="cov8" title="1">{
        hotels, err := s.reviewRepo.ListHotels(ctx, limit*2, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get hotels: %w", err)
        }</span>

        <span class="cov8" title="1">if len(hotels) &lt; limit </span><span class="cov8" title="1">{
                return hotels, nil
        }</span>
        <span class="cov0" title="0">return hotels[:limit], nil</span>
}

func (s *ReviewServiceImpl) GetRecentReviews(ctx context.Context, limit int) ([]Review, error) <span class="cov8" title="1">{
        reviews, err := s.reviewRepo.GetByDateRange(ctx, time.Now().AddDate(0, 0, -30), time.Now(), limit, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get recent reviews: %w", err)
        }</span>
        <span class="cov8" title="1">return reviews, nil</span>
}

// Review validation and enrichment
func (s *ReviewServiceImpl) ValidateReviewData(ctx context.Context, review *Review) error <span class="cov8" title="1">{
        if review.Rating &lt; 1.0 || review.Rating &gt; 5.0 </span><span class="cov8" title="1">{
                return fmt.Errorf("rating must be between 1.0 and 5.0")
        }</span>

        <span class="cov8" title="1">if review.Comment == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("comment cannot be empty")
        }</span>

        <span class="cov8" title="1">if review.ReviewDate.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("review date cannot be empty")
        }</span>

        <span class="cov8" title="1">if review.ReviewDate.After(time.Now()) </span><span class="cov8" title="1">{
                return fmt.Errorf("review date cannot be in the future")
        }</span>

        <span class="cov8" title="1">if review.ProviderID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("provider ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if review.HotelID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("hotel ID cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) EnrichReviewData(ctx context.Context, review *Review) error <span class="cov8" title="1">{
        if review.Language == "" </span><span class="cov8" title="1">{
                review.Language = "en"
        }</span>

        <span class="cov8" title="1">if review.Sentiment == "" </span><span class="cov8" title="1">{
                review.Sentiment = s.detectSentiment(review.Comment)
        }</span>

        <span class="cov8" title="1">if review.ProcessingHash == "" </span><span class="cov8" title="1">{
                review.ProcessingHash = s.generateProcessingHash(review)
        }</span>

        <span class="cov8" title="1">now := time.Now()
        review.ProcessedAt = &amp;now

        return nil</span>
}

func (s *ReviewServiceImpl) DetectDuplicateReviews(ctx context.Context, review *Review) ([]Review, error) <span class="cov8" title="1">{
        filters := map[string]interface{}{
                "hotel_id":    review.HotelID,
                "provider_id": review.ProviderID,
                "rating":      review.Rating,
        }

        duplicates, err := s.reviewRepo.Search(ctx, review.Comment, filters, 10, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to search for duplicates: %w", err)
        }</span>

        <span class="cov8" title="1">return duplicates, nil</span>
}

// Batch operations
func (s *ReviewServiceImpl) ProcessReviewBatch(ctx context.Context, reviews []Review) error <span class="cov8" title="1">{
        for i := range reviews </span><span class="cov8" title="1">{
                if err := s.ValidateReviewData(ctx, &amp;reviews[i]); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("validation failed for review %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">if err := s.EnrichReviewData(ctx, &amp;reviews[i]); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to enrich review data", "error", err, "review_index", i)
                }</span>
        }

        <span class="cov8" title="1">if err := s.reviewRepo.CreateBatch(ctx, reviews); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create review batch: %w", err)
        }</span>

        <span class="cov8" title="1">for _, review := range reviews </span><span class="cov8" title="1">{
                if err := s.eventPublisher.PublishReviewCreated(ctx, &amp;review); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to publish review created event", "error", err, "review_id", review.ID)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) ImportReviewsFromFile(ctx context.Context, fileURL string, providerID uuid.UUID) error <span class="cov8" title="1">{
        _, err := s.ProcessReviewFile(ctx, fileURL, providerID)
        return err
}</span>

func (s *ReviewServiceImpl) ExportReviewsToFile(ctx context.Context, filters map[string]interface{}, format string) (string, error) <span class="cov8" title="1">{
        return "", fmt.Errorf("export functionality not implemented yet")
}</span>

// Helper methods
func (s *ReviewServiceImpl) validateHotel(ctx context.Context, hotel *Hotel) error <span class="cov8" title="1">{
        if hotel.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("hotel name cannot be empty")
        }</span>

        <span class="cov8" title="1">if hotel.StarRating &lt; 1 || hotel.StarRating &gt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("star rating must be between 1 and 5")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) validateProvider(ctx context.Context, provider *Provider) error <span class="cov8" title="1">{
        if provider.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("provider name cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ReviewServiceImpl) parseS3URL(url string) (bucket, key string, err error) <span class="cov8" title="1">{
        parts := strings.Split(strings.TrimPrefix(url, "s3://"), "/")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid S3 URL format")
        }</span>
        <span class="cov8" title="1">return parts[0], strings.Join(parts[1:], "/"), nil</span>
}

func (s *ReviewServiceImpl) detectSentiment(comment string) string <span class="cov8" title="1">{
        comment = strings.ToLower(comment)
        
        positiveWords := []string{"good", "great", "excellent", "amazing", "wonderful", "perfect", "love", "fantastic"}
        negativeWords := []string{"bad", "terrible", "awful", "horrible", "worst", "hate", "disappointing", "poor"}
        
        positiveCount := 0
        negativeCount := 0
        
        for _, word := range positiveWords </span><span class="cov8" title="1">{
                if strings.Contains(comment, word) </span><span class="cov8" title="1">{
                        positiveCount++
                }</span>
        }
        
        <span class="cov8" title="1">for _, word := range negativeWords </span><span class="cov8" title="1">{
                if strings.Contains(comment, word) </span><span class="cov8" title="1">{
                        negativeCount++
                }</span>
        }
        
        <span class="cov8" title="1">if positiveCount &gt; negativeCount </span><span class="cov8" title="1">{
                return "positive"
        }</span> else<span class="cov8" title="1"> if negativeCount &gt; positiveCount </span><span class="cov8" title="1">{
                return "negative"
        }</span>
        
        <span class="cov8" title="1">return "neutral"</span>
}

func (s *ReviewServiceImpl) generateProcessingHash(review *Review) string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", review.ID)[0:32] // Take first 32 characters
}</pre>
		
		<pre class="file" id="file4" style="display: none">package infrastructure

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

// Database represents the database connection wrapper
type Database struct {
        DB     *gorm.DB
        config *config.DatabaseConfig
        logger *logger.Logger
}

// NewDatabase creates a new database connection
func NewDatabase(cfg *config.DatabaseConfig, log *logger.Logger) (*Database, error) <span class="cov0" title="0">{
        db := &amp;Database{
                config: cfg,
                logger: log,
        }

        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// connect establishes the database connection with retry logic
func (d *Database) connect() error <span class="cov0" title="0">{
        dsn := d.buildDSN()
        
        var gormDB *gorm.DB
        var err error
        
        maxRetries := 5
        retryDelay := 2 * time.Second
        
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                gormDB, err = d.attemptConnection(dsn)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">d.logger.Warn("Database connection failed, retrying...",
                        "attempt", i+1,
                        "max_retries", maxRetries,
                        "error", err,
                )
                
                if i &lt; maxRetries-1 </span><span class="cov0" title="0">{
                        time.Sleep(retryDelay)
                        retryDelay *= 2 // Exponential backoff
                }</span>
        }
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect after %d attempts: %w", maxRetries, err)
        }</span>
        
        <span class="cov0" title="0">d.DB = gormDB
        
        // Configure connection pool
        if err := d.configureConnectionPool(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure connection pool: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.logger.Info("Database connection established successfully",
                "host", d.config.Host,
                "port", d.config.Port,
                "database", d.config.Name,
        )
        
        return nil</span>
}

// attemptConnection attempts to establish a database connection
func (d *Database) attemptConnection(dsn string) (*gorm.DB, error) <span class="cov0" title="0">{
        // Configure GORM logger
        gormLogLevel := d.getGormLogLevel()
        gormConfig := &amp;gorm.Config{
                Logger: gormLogger.New(
                        log.New(os.Stdout, "\r\n", log.LstdFlags),
                        gormLogger.Config{
                                SlowThreshold:             200 * time.Millisecond,
                                LogLevel:                  gormLogLevel,
                                IgnoreRecordNotFoundError: true,
                                Colorful:                  false,
                        },
                ),
                NowFunc: func() time.Time </span><span class="cov0" title="0">{
                        return time.Now().UTC()
                }</span>,
                PrepareStmt:                              true,
                DisableForeignKeyConstraintWhenMigrating: false,
        }
        
        <span class="cov0" title="0">return gorm.Open(postgres.Open(dsn), gormConfig)</span>
}

// buildDSN builds the database connection string
func (d *Database) buildDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s user=%s password=%s dbname=%s port=%d sslmode=%s TimeZone=%s",
                d.config.Host,
                d.config.User,
                d.config.Password,
                d.config.Name,
                d.config.Port,
                d.config.SSLMode,
                d.config.TimeZone,
        )
}</span>

// configureConnectionPool configures the database connection pool
func (d *Database) configureConnectionPool() error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        
        // Set connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(d.config.MaxOpenConns)
        sqlDB.SetMaxIdleConns(d.config.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(d.config.ConnMaxLifetime)
        sqlDB.SetConnMaxIdleTime(d.config.ConnMaxIdleTime)
        
        d.logger.Info("Database connection pool configured",
                "max_open_conns", d.config.MaxOpenConns,
                "max_idle_conns", d.config.MaxIdleConns,
                "conn_max_lifetime", d.config.ConnMaxLifetime,
                "conn_max_idle_time", d.config.ConnMaxIdleTime,
        )
        
        return nil</span>
}

// getGormLogLevel converts string log level to GORM log level
func (d *Database) getGormLogLevel() gormLogger.LogLevel <span class="cov0" title="0">{
        switch d.config.LogLevel </span>{
        case "debug":<span class="cov0" title="0">
                return gormLogger.Info</span>
        case "info":<span class="cov0" title="0">
                return gormLogger.Warn</span>
        case "warn":<span class="cov0" title="0">
                return gormLogger.Warn</span>
        case "error":<span class="cov0" title="0">
                return gormLogger.Error</span>
        default:<span class="cov0" title="0">
                return gormLogger.Warn</span>
        }
}

// Migrate runs database migrations
func (d *Database) Migrate() error <span class="cov0" title="0">{
        d.logger.Info("Starting database migration...")
        
        entities := []interface{}{
                &amp;domain.Provider{},
                &amp;domain.Hotel{},
                &amp;domain.ReviewerInfo{},
                &amp;domain.Review{},
                &amp;domain.ReviewSummary{},
                &amp;domain.ReviewProcessingStatus{},
        }
        
        for _, entity := range entities </span><span class="cov0" title="0">{
                if err := d.DB.AutoMigrate(entity); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to migrate %T: %w", entity, err)
                }</span>
        }
        
        // Create indexes
        <span class="cov0" title="0">if err := d.createIndexes(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.logger.Info("Database migration completed successfully")
        return nil</span>
}

// createIndexes creates additional database indexes for performance
func (d *Database) createIndexes() error <span class="cov0" title="0">{
        indexes := []struct {
                table string
                index string
        }{
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_hotel_id_rating ON reviews(hotel_id, rating)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_provider_id_review_date ON reviews(provider_id, review_date)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_review_date ON reviews(review_date)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_rating ON reviews(rating)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_external_id ON reviews(external_id)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_processing_hash ON reviews(processing_hash)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_name ON hotels(name)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_city_country ON hotels(city, country)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_star_rating ON hotels(star_rating)"},
                {"providers", "CREATE INDEX IF NOT EXISTS idx_providers_name ON providers(name)"},
                {"providers", "CREATE INDEX IF NOT EXISTS idx_providers_is_active ON providers(is_active)"},
                {"reviewer_infos", "CREATE INDEX IF NOT EXISTS idx_reviewer_infos_email ON reviewer_infos(email)"},
                {"reviewer_infos", "CREATE INDEX IF NOT EXISTS idx_reviewer_infos_is_verified ON reviewer_infos(is_verified)"},
                {"review_summaries", "CREATE INDEX IF NOT EXISTS idx_review_summaries_hotel_id ON review_summaries(hotel_id)"},
                {"review_processing_statuses", "CREATE INDEX IF NOT EXISTS idx_review_processing_statuses_provider_id_status ON review_processing_statuses(provider_id, status)"},
                {"review_processing_statuses", "CREATE INDEX IF NOT EXISTS idx_review_processing_statuses_created_at ON review_processing_statuses(created_at)"},
        }
        
        for _, idx := range indexes </span><span class="cov0" title="0">{
                if err := d.DB.Exec(idx.index).Error; err != nil </span><span class="cov0" title="0">{
                        d.logger.Warn("Failed to create index", "table", idx.table, "error", err)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// HealthCheck performs a database health check
func (d *Database) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database ping failed: %w", err)
        }</span>
        
        // Test a simple query
        <span class="cov0" title="0">var result int
        if err := d.DB.WithContext(ctx).Raw("SELECT 1").Scan(&amp;result).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("test query failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetStats returns database connection statistics
func (d *Database) GetStats() (*sql.DBStats, error) <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        
        <span class="cov0" title="0">stats := sqlDB.Stats()
        return &amp;stats, nil</span>
}

// LogStats logs database connection statistics
func (d *Database) LogStats(ctx context.Context) <span class="cov0" title="0">{
        stats, err := d.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                d.logger.ErrorContext(ctx, "Failed to get database stats", "error", err)
                return
        }</span>
        
        <span class="cov0" title="0">d.logger.InfoContext(ctx, "Database connection statistics",
                "open_connections", stats.OpenConnections,
                "in_use", stats.InUse,
                "idle", stats.Idle,
                "wait_count", stats.WaitCount,
                "wait_duration", stats.WaitDuration,
                "max_idle_closed", stats.MaxIdleClosed,
                "max_idle_time_closed", stats.MaxIdleTimeClosed,
                "max_lifetime_closed", stats.MaxLifetimeClosed,
        )</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov0" title="0">{
        if d.DB == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close database connection: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.logger.Info("Database connection closed successfully")
        return nil</span>
}

// WithContext returns a new GORM DB instance with context
func (d *Database) WithContext(ctx context.Context) *gorm.DB <span class="cov0" title="0">{
        return d.DB.WithContext(ctx)
}</span>

// Transaction executes a function within a database transaction
func (d *Database) Transaction(ctx context.Context, fn func(*gorm.DB) error) error <span class="cov0" title="0">{
        return d.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                return fn(tx)
        }</span>)
}

// BeginTransaction starts a new database transaction
func (d *Database) BeginTransaction(ctx context.Context) *gorm.DB <span class="cov0" title="0">{
        return d.DB.WithContext(ctx).Begin()
}</span>

// Seed seeds the database with initial data
func (d *Database) Seed(ctx context.Context) error <span class="cov0" title="0">{
        d.logger.InfoContext(ctx, "Seeding database with initial data...")
        
        // Create default providers
        providers := []domain.Provider{
                {
                        Name:     "Booking.com",
                        BaseURL:  "https://www.booking.com",
                        IsActive: true,
                },
                {
                        Name:     "Expedia",
                        BaseURL:  "https://www.expedia.com",
                        IsActive: true,
                },
                {
                        Name:     "Hotels.com",
                        BaseURL:  "https://www.hotels.com",
                        IsActive: true,
                },
                {
                        Name:     "Agoda",
                        BaseURL:  "https://www.agoda.com",
                        IsActive: true,
                },
                {
                        Name:     "TripAdvisor",
                        BaseURL:  "https://www.tripadvisor.com",
                        IsActive: true,
                },
        }
        
        for _, provider := range providers </span><span class="cov0" title="0">{
                var existingProvider domain.Provider
                if err := d.DB.WithContext(ctx).Where("name = ?", provider.Name).First(&amp;existingProvider).Error; err != nil </span><span class="cov0" title="0">{
                        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                                if err := d.DB.WithContext(ctx).Create(&amp;provider).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create provider %s: %w", provider.Name, err)
                                }</span>
                                <span class="cov0" title="0">d.logger.InfoContext(ctx, "Created provider", "name", provider.Name)</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("failed to check provider existence: %w", err)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">d.logger.InfoContext(ctx, "Database seeding completed successfully")
        return nil</span>
}

// Reset resets the database (drops all tables and recreates them)
func (d *Database) Reset(ctx context.Context) error <span class="cov0" title="0">{
        d.logger.WarnContext(ctx, "Resetting database - all data will be lost!")
        
        entities := []interface{}{
                &amp;domain.ReviewProcessingStatus{},
                &amp;domain.ReviewSummary{},
                &amp;domain.Review{},
                &amp;domain.ReviewerInfo{},
                &amp;domain.Hotel{},
                &amp;domain.Provider{},
        }
        
        // Drop tables in reverse order to handle foreign keys
        for i := len(entities) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if err := d.DB.WithContext(ctx).Migrator().DropTable(entities[i]); err != nil </span><span class="cov0" title="0">{
                        d.logger.WarnContext(ctx, "Failed to drop table", "entity", entities[i], "error", err)
                }</span>
        }
        
        // Run migrations to recreate tables
        <span class="cov0" title="0">if err := d.Migrate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations after reset: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.logger.InfoContext(ctx, "Database reset completed successfully")
        return nil</span>
}

// GetConnectionURL returns the database connection URL (without password)
func (d *Database) GetConnectionURL() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "postgres://%s:***@%s:%d/%s?sslmode=%s&amp;TimeZone=%s",
                d.config.User,
                d.config.Host,
                d.config.Port,
                d.config.Name,
                d.config.SSLMode,
                d.config.TimeZone,
        )
}</span>

// IsHealthy checks if the database is healthy
func (d *Database) IsHealthy(ctx context.Context) bool <span class="cov0" title="0">{
        return d.HealthCheck(ctx) == nil
}</span>

// WaitForConnection waits for database connection to be available
func (d *Database) WaitForConnection(ctx context.Context, timeout time.Duration) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for database connection: %w", ctx.Err())</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := d.HealthCheck(ctx); err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

// StartStatsLogger starts a goroutine that periodically logs database statistics
func (d *Database) StartStatsLogger(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        
        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                d.LogStats(ctx)</span>
                        }
                }
        }()
}

// CreateBackup creates a database backup (PostgreSQL specific)
func (d *Database) CreateBackup(ctx context.Context, backupPath string) error <span class="cov0" title="0">{
        // This is a placeholder for backup functionality
        // In production, you would implement pg_dump or similar
        d.logger.InfoContext(ctx, "Database backup requested", "path", backupPath)
        return fmt.Errorf("backup functionality not implemented")
}</span>

// RestoreBackup restores a database backup (PostgreSQL specific)
func (d *Database) RestoreBackup(ctx context.Context, backupPath string) error <span class="cov0" title="0">{
        // This is a placeholder for restore functionality
        // In production, you would implement pg_restore or similar
        d.logger.InfoContext(ctx, "Database restore requested", "path", backupPath)
        return fmt.Errorf("restore functionality not implemented")
}</pre>
		
		<pre class="file" id="file5" style="display: none">package infrastructure

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// JSONLinesProcessor implements the domain.JSONProcessor interface
type JSONLinesProcessor struct {
        repository domain.ReviewRepository
        logger     *logger.Logger
        batchSize  int
        workerPool int
        validator  *ReviewValidator
}

// ReviewValidator handles validation of review data
type ReviewValidator struct {
        requiredFields []string
        maxCommentLen  int
        maxTitleLen    int
}

// ProcessingStats tracks processing statistics
type ProcessingStats struct {
        TotalLines     int64
        ProcessedLines int64
        ErrorLines     int64
        SkippedLines   int64
        StartTime      time.Time
        EndTime        time.Time
}

// LineError represents an error that occurred while processing a line
type LineError struct {
        LineNumber int64
        Content    string
        Error      error
}

// BatchJob represents a batch of lines to process
type BatchJob struct {
        Lines      []string
        StartLine  int64
        ProviderID uuid.UUID
}

// ProcessingResult represents the result of processing a batch
type ProcessingResult struct {
        Reviews      []domain.Review
        Hotels       []domain.Hotel
        ReviewerInfo []domain.ReviewerInfo
        Errors       []LineError
}

// ReviewJSON represents the JSON structure for reviews
type ReviewJSON struct {
        ID           string                 `json:"id"`
        HotelID      string                 `json:"hotel_id"`
        HotelName    string                 `json:"hotel_name"`
        Rating       interface{}            `json:"rating"`
        Title        string                 `json:"title"`
        Comment      string                 `json:"comment"`
        ReviewDate   string                 `json:"review_date"`
        StayDate     string                 `json:"stay_date,omitempty"`
        TripType     string                 `json:"trip_type,omitempty"`
        RoomType     string                 `json:"room_type,omitempty"`
        Language     string                 `json:"language,omitempty"`
        IsVerified   interface{}            `json:"is_verified,omitempty"`
        HelpfulVotes interface{}            `json:"helpful_votes,omitempty"`
        TotalVotes   interface{}            `json:"total_votes,omitempty"`
        
        // Reviewer information
        ReviewerName    string `json:"reviewer_name,omitempty"`
        ReviewerEmail   string `json:"reviewer_email,omitempty"`
        ReviewerCountry string `json:"reviewer_country,omitempty"`
        
        // Hotel information
        HotelAddress    string   `json:"hotel_address,omitempty"`
        HotelCity       string   `json:"hotel_city,omitempty"`
        HotelCountry    string   `json:"hotel_country,omitempty"`
        HotelPostalCode string   `json:"hotel_postal_code,omitempty"`
        HotelPhone      string   `json:"hotel_phone,omitempty"`
        HotelEmail      string   `json:"hotel_email,omitempty"`
        HotelStarRating interface{} `json:"hotel_star_rating,omitempty"`
        HotelAmenities  []string `json:"hotel_amenities,omitempty"`
        HotelLatitude   interface{} `json:"hotel_latitude,omitempty"`
        HotelLongitude  interface{} `json:"hotel_longitude,omitempty"`
        
        // Detailed ratings
        ServiceRating     interface{} `json:"service_rating,omitempty"`
        CleanlinessRating interface{} `json:"cleanliness_rating,omitempty"`
        LocationRating    interface{} `json:"location_rating,omitempty"`
        ValueRating       interface{} `json:"value_rating,omitempty"`
        ComfortRating     interface{} `json:"comfort_rating,omitempty"`
        FacilitiesRating  interface{} `json:"facilities_rating,omitempty"`
        
        // Additional metadata
        Source   string                 `json:"source,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// NewJSONLinesProcessor creates a new JSON Lines processor
func NewJSONLinesProcessor(repository domain.ReviewRepository, logger *logger.Logger) domain.JSONProcessor <span class="cov0" title="0">{
        validator := &amp;ReviewValidator{
                requiredFields: []string{"id", "hotel_id", "hotel_name", "rating", "comment", "review_date"},
                maxCommentLen:  10000,
                maxTitleLen:    500,
        }
        
        return &amp;JSONLinesProcessor{
                repository: repository,
                logger:     logger,
                batchSize:  1000,
                workerPool: 4,
                validator:  validator,
        }
}</span>

// ProcessFile processes a JSON Lines file
func (j *JSONLinesProcessor) ProcessFile(ctx context.Context, reader io.Reader, providerID uuid.UUID, processingID uuid.UUID) error <span class="cov0" title="0">{
        start := time.Now()
        stats := &amp;ProcessingStats{
                StartTime: start,
        }
        
        j.logger.InfoContext(ctx, "Starting JSON Lines file processing",
                "provider_id", providerID,
                "processing_id", processingID,
        )
        
        // Create buffered reader for efficient line-by-line reading
        scanner := bufio.NewScanner(reader)
        
        // Increase buffer size for large lines
        const maxCapacity = 1024 * 1024 // 1MB per line
        buf := make([]byte, maxCapacity)
        scanner.Buffer(buf, maxCapacity)
        
        // Process lines in batches using worker pool
        batchChan := make(chan BatchJob, j.workerPool)
        resultChan := make(chan ProcessingResult, j.workerPool)
        
        // Start worker goroutines
        var wg sync.WaitGroup
        for i := 0; i &lt; j.workerPool; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go j.worker(ctx, batchChan, resultChan, &amp;wg)
        }</span>
        
        // Start result collector
        <span class="cov0" title="0">go j.resultCollector(ctx, resultChan, stats, processingID)
        
        // Read and batch lines
        var batch []string
        var lineNumber int64
        var batchStartLine int64
        
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNumber++
                line := strings.TrimSpace(scanner.Text())
                
                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        stats.SkippedLines++
                        continue</span>
                }
                
                // Add line to batch
                <span class="cov0" title="0">if len(batch) == 0 </span><span class="cov0" title="0">{
                        batchStartLine = lineNumber
                }</span>
                <span class="cov0" title="0">batch = append(batch, line)
                
                // Send batch when full
                if len(batch) &gt;= j.batchSize </span><span class="cov0" title="0">{
                        select </span>{
                        case batchChan &lt;- BatchJob{
                                Lines:      batch,
                                StartLine:  batchStartLine,
                                ProviderID: providerID,
                        }:<span class="cov0" title="0">
                                batch = make([]string, 0, j.batchSize)</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                close(batchChan)
                                return ctx.Err()</span>
                        }
                }
        }
        
        // Send remaining batch
        <span class="cov0" title="0">if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case batchChan &lt;- BatchJob{
                        Lines:      batch,
                        StartLine:  batchStartLine,
                        ProviderID: providerID,
                }:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(batchChan)
                        return ctx.Err()</span>
                }
        }
        
        // Check for scanner errors
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                close(batchChan)
                return fmt.Errorf("error reading file: %w", err)
        }</span>
        
        <span class="cov0" title="0">stats.TotalLines = lineNumber
        
        // Close batch channel and wait for workers
        close(batchChan)
        wg.Wait()
        close(resultChan)
        
        // Wait for result collector to finish
        time.Sleep(100 * time.Millisecond)
        
        stats.EndTime = time.Now()
        duration := stats.EndTime.Sub(stats.StartTime)
        
        j.logger.InfoContext(ctx, "JSON Lines file processing completed",
                "provider_id", providerID,
                "processing_id", processingID,
                "total_lines", stats.TotalLines,
                "processed_lines", stats.ProcessedLines,
                "error_lines", stats.ErrorLines,
                "skipped_lines", stats.SkippedLines,
                "duration_ms", duration.Milliseconds(),
                "lines_per_second", float64(stats.TotalLines)/duration.Seconds(),
        )
        
        return nil</span>
}

// worker processes batches of lines
func (j *JSONLinesProcessor) worker(ctx context.Context, batchChan &lt;-chan BatchJob, resultChan chan&lt;- ProcessingResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        
        for batch := range batchChan </span><span class="cov0" title="0">{
                result := j.processBatch(ctx, batch)
                
                select </span>{
                case resultChan &lt;- result:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// processBatch processes a batch of lines
func (j *JSONLinesProcessor) processBatch(ctx context.Context, batch BatchJob) ProcessingResult <span class="cov0" title="0">{
        result := ProcessingResult{
                Reviews:      make([]domain.Review, 0, len(batch.Lines)),
                Hotels:       make([]domain.Hotel, 0),
                ReviewerInfo: make([]domain.ReviewerInfo, 0),
                Errors:       make([]LineError, 0),
        }
        
        hotelMap := make(map[string]*domain.Hotel)
        reviewerMap := make(map[string]*domain.ReviewerInfo)
        
        for i, line := range batch.Lines </span><span class="cov0" title="0">{
                lineNumber := batch.StartLine + int64(i)
                
                review, hotel, reviewer, err := j.parseLine(ctx, line, batch.ProviderID)
                if err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, LineError{
                                LineNumber: lineNumber,
                                Content:    line,
                                Error:      err,
                        })
                        continue</span>
                }
                
                <span class="cov0" title="0">result.Reviews = append(result.Reviews, *review)
                
                // Collect unique hotels
                if hotel != nil </span><span class="cov0" title="0">{
                        if _, exists := hotelMap[hotel.Name]; !exists </span><span class="cov0" title="0">{
                                hotelMap[hotel.Name] = hotel
                        }</span>
                }
                
                // Collect unique reviewers
                <span class="cov0" title="0">if reviewer != nil &amp;&amp; reviewer.Email != "" </span><span class="cov0" title="0">{
                        if _, exists := reviewerMap[reviewer.Email]; !exists </span><span class="cov0" title="0">{
                                reviewerMap[reviewer.Email] = reviewer
                        }</span>
                }
        }
        
        // Convert maps to slices
        <span class="cov0" title="0">for _, hotel := range hotelMap </span><span class="cov0" title="0">{
                result.Hotels = append(result.Hotels, *hotel)
        }</span>
        <span class="cov0" title="0">for _, reviewer := range reviewerMap </span><span class="cov0" title="0">{
                result.ReviewerInfo = append(result.ReviewerInfo, *reviewer)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// resultCollector collects processing results and saves to database
func (j *JSONLinesProcessor) resultCollector(ctx context.Context, resultChan &lt;-chan ProcessingResult, stats *ProcessingStats, processingID uuid.UUID) <span class="cov0" title="0">{
        for result := range resultChan </span><span class="cov0" title="0">{
                // Save hotels first (upsert to handle duplicates)
                if len(result.Hotels) &gt; 0 </span><span class="cov0" title="0">{
                        for _, hotel := range result.Hotels </span><span class="cov0" title="0">{
                                if err := j.repository.CreateHotel(ctx, &amp;hotel); err != nil </span><span class="cov0" title="0">{
                                        j.logger.WarnContext(ctx, "Failed to upsert hotel",
                                                "hotel_name", hotel.Name,
                                                "error", err,
                                        )
                                }</span>
                        }
                }
                
                // Save reviewer info (upsert to handle duplicates)
                <span class="cov0" title="0">if len(result.ReviewerInfo) &gt; 0 </span><span class="cov0" title="0">{
                        for _, reviewer := range result.ReviewerInfo </span><span class="cov0" title="0">{
                                if err := j.repository.CreateReviewerInfo(ctx, &amp;reviewer); err != nil </span><span class="cov0" title="0">{
                                        j.logger.WarnContext(ctx, "Failed to upsert reviewer info",
                                                "reviewer_email", reviewer.Email,
                                                "error", err,
                                        )
                                }</span>
                        }
                }
                
                // Save reviews in batch
                <span class="cov0" title="0">if len(result.Reviews) &gt; 0 </span><span class="cov0" title="0">{
                        if err := j.repository.CreateBatch(ctx, result.Reviews); err != nil </span><span class="cov0" title="0">{
                                j.logger.ErrorContext(ctx, "Failed to save review batch",
                                        "batch_size", len(result.Reviews),
                                        "error", err,
                                )
                                stats.ErrorLines += int64(len(result.Reviews))
                        }</span> else<span class="cov0" title="0"> {
                                stats.ProcessedLines += int64(len(result.Reviews))
                        }</span>
                }
                
                // Log errors
                <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, lineError := range result.Errors </span><span class="cov0" title="0">{
                                j.logger.WarnContext(ctx, "Line processing error",
                                        "line_number", lineError.LineNumber,
                                        "error", lineError.Error,
                                )
                        }</span>
                        <span class="cov0" title="0">stats.ErrorLines += int64(len(result.Errors))</span>
                }
                
                // Update processing status periodically
                <span class="cov0" title="0">if err := j.repository.UpdateProcessingStatus(ctx, processingID, "processing", int(stats.ProcessedLines), ""); err != nil </span><span class="cov0" title="0">{
                        j.logger.WarnContext(ctx, "Failed to update processing status", "error", err)
                }</span>
        }
}

// parseLine parses a single JSON line
func (j *JSONLinesProcessor) parseLine(ctx context.Context, line string, providerID uuid.UUID) (*domain.Review, *domain.Hotel, *domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal([]byte(line), &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>
        
        // Validate required fields
        <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("validation failed: %w", err)
        }</span>
        
        // Parse review
        <span class="cov0" title="0">review, err := j.parseReview(ctx, &amp;reviewJSON, providerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to parse review: %w", err)
        }</span>
        
        // Parse hotel
        <span class="cov0" title="0">hotel, err := j.parseHotel(ctx, &amp;reviewJSON)
        if err != nil </span><span class="cov0" title="0">{
                j.logger.WarnContext(ctx, "Failed to parse hotel", "error", err)
                hotel = nil
        }</span>
        
        // Parse reviewer info
        <span class="cov0" title="0">reviewer, err := j.parseReviewerInfo(ctx, &amp;reviewJSON)
        if err != nil </span><span class="cov0" title="0">{
                j.logger.WarnContext(ctx, "Failed to parse reviewer info", "error", err)
                reviewer = nil
        }</span>
        
        <span class="cov0" title="0">return review, hotel, reviewer, nil</span>
}

// parseReview parses a review from JSON
func (j *JSONLinesProcessor) parseReview(ctx context.Context, reviewJSON *ReviewJSON, providerID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        // Parse rating
        rating, err := j.parseFloat(reviewJSON.Rating)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid rating: %w", err)
        }</span>
        
        // Parse review date
        <span class="cov0" title="0">reviewDate, err := j.parseDate(reviewJSON.ReviewDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid review date: %w", err)
        }</span>
        
        // Parse hotel ID
        <span class="cov0" title="0">hotelID, err := uuid.Parse(reviewJSON.HotelID)
        if err != nil </span><span class="cov0" title="0">{
                // Generate UUID from hotel name if not provided
                hotelID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.HotelName))
        }</span>
        
        // Parse reviewer ID (generate from email if available)
        <span class="cov0" title="0">reviewerID := uuid.New()
        if reviewJSON.ReviewerEmail != "" </span><span class="cov0" title="0">{
                reviewerID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.ReviewerEmail))
        }</span>
        
        <span class="cov0" title="0">review := &amp;domain.Review{
                ID:             uuid.New(),
                ProviderID:     providerID,
                HotelID:        hotelID,
                ReviewerInfoID: reviewerID,
                ExternalID:     reviewJSON.ID,
                Rating:         rating,
                Title:          reviewJSON.Title,
                Comment:        reviewJSON.Comment,
                ReviewDate:     reviewDate,
                Language:       j.getStringOrDefault(reviewJSON.Language, "en"),
                Source:         reviewJSON.Source,
                Metadata:       reviewJSON.Metadata,
        }
        
        // Parse optional fields
        if reviewJSON.StayDate != "" </span><span class="cov0" title="0">{
                if stayDate, err := j.parseDate(reviewJSON.StayDate); err == nil </span><span class="cov0" title="0">{
                        review.StayDate = &amp;stayDate
                }</span>
        }
        
        <span class="cov0" title="0">if reviewJSON.TripType != "" </span><span class="cov0" title="0">{
                review.TripType = reviewJSON.TripType
        }</span>
        
        <span class="cov0" title="0">if reviewJSON.RoomType != "" </span><span class="cov0" title="0">{
                review.RoomType = reviewJSON.RoomType
        }</span>
        
        <span class="cov0" title="0">if isVerified, err := j.parseBool(reviewJSON.IsVerified); err == nil </span><span class="cov0" title="0">{
                review.IsVerified = isVerified
        }</span>
        
        <span class="cov0" title="0">if helpfulVotes, err := j.parseInt(reviewJSON.HelpfulVotes); err == nil </span><span class="cov0" title="0">{
                review.HelpfulVotes = helpfulVotes
        }</span>
        
        <span class="cov0" title="0">if totalVotes, err := j.parseInt(reviewJSON.TotalVotes); err == nil </span><span class="cov0" title="0">{
                review.TotalVotes = totalVotes
        }</span>
        
        // Parse detailed ratings
        <span class="cov0" title="0">if serviceRating, err := j.parseFloat(reviewJSON.ServiceRating); err == nil </span><span class="cov0" title="0">{
                review.ServiceRating = &amp;serviceRating
        }</span>
        
        <span class="cov0" title="0">if cleanlinessRating, err := j.parseFloat(reviewJSON.CleanlinessRating); err == nil </span><span class="cov0" title="0">{
                review.CleanlinessRating = &amp;cleanlinessRating
        }</span>
        
        <span class="cov0" title="0">if locationRating, err := j.parseFloat(reviewJSON.LocationRating); err == nil </span><span class="cov0" title="0">{
                review.LocationRating = &amp;locationRating
        }</span>
        
        <span class="cov0" title="0">if valueRating, err := j.parseFloat(reviewJSON.ValueRating); err == nil </span><span class="cov0" title="0">{
                review.ValueRating = &amp;valueRating
        }</span>
        
        <span class="cov0" title="0">if comfortRating, err := j.parseFloat(reviewJSON.ComfortRating); err == nil </span><span class="cov0" title="0">{
                review.ComfortRating = &amp;comfortRating
        }</span>
        
        <span class="cov0" title="0">if facilitiesRating, err := j.parseFloat(reviewJSON.FacilitiesRating); err == nil </span><span class="cov0" title="0">{
                review.FacilitiesRating = &amp;facilitiesRating
        }</span>
        
        <span class="cov0" title="0">return review, nil</span>
}

// parseHotel parses hotel information from JSON
func (j *JSONLinesProcessor) parseHotel(ctx context.Context, reviewJSON *ReviewJSON) (*domain.Hotel, error) <span class="cov0" title="0">{
        hotelID, err := uuid.Parse(reviewJSON.HotelID)
        if err != nil </span><span class="cov0" title="0">{
                hotelID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.HotelName))
        }</span>
        
        <span class="cov0" title="0">hotel := &amp;domain.Hotel{
                ID:          hotelID,
                Name:        reviewJSON.HotelName,
                Address:     reviewJSON.HotelAddress,
                City:        reviewJSON.HotelCity,
                Country:     reviewJSON.HotelCountry,
                PostalCode:  reviewJSON.HotelPostalCode,
                Phone:       reviewJSON.HotelPhone,
                Email:       reviewJSON.HotelEmail,
                Amenities:   reviewJSON.HotelAmenities,
        }
        
        // Parse optional fields
        if starRating, err := j.parseInt(reviewJSON.HotelStarRating); err == nil </span><span class="cov0" title="0">{
                hotel.StarRating = starRating
        }</span>
        
        <span class="cov0" title="0">if latitude, err := j.parseFloat(reviewJSON.HotelLatitude); err == nil </span><span class="cov0" title="0">{
                hotel.Latitude = latitude
        }</span>
        
        <span class="cov0" title="0">if longitude, err := j.parseFloat(reviewJSON.HotelLongitude); err == nil </span><span class="cov0" title="0">{
                hotel.Longitude = longitude
        }</span>
        
        <span class="cov0" title="0">return hotel, nil</span>
}

// parseReviewerInfo parses reviewer information from JSON
func (j *JSONLinesProcessor) parseReviewerInfo(ctx context.Context, reviewJSON *ReviewJSON) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        if reviewJSON.ReviewerEmail == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reviewer email is required")
        }</span>
        
        <span class="cov0" title="0">reviewerID := uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.ReviewerEmail))
        
        reviewer := &amp;domain.ReviewerInfo{
                ID:      reviewerID,
                Name:    reviewJSON.ReviewerName,
                Email:   reviewJSON.ReviewerEmail,
                Country: reviewJSON.ReviewerCountry,
        }
        
        return reviewer, nil</span>
}

// ValidateFile validates the file format and structure
func (j *JSONLinesProcessor) ValidateFile(ctx context.Context, reader io.Reader) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        lineNumber := 0
        
        // Check first few lines for format validation
        for scanner.Scan() &amp;&amp; lineNumber &lt; 10 </span><span class="cov0" title="0">{
                lineNumber++
                line := strings.TrimSpace(scanner.Text())
                
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">var reviewJSON ReviewJSON
                if err := json.Unmarshal([]byte(line), &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid JSON format at line %d: %w", lineNumber, err)
                }</span>
                
                <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed at line %d: %w", lineNumber, err)
                }</span>
        }
        
        <span class="cov0" title="0">return scanner.Err()</span>
}

// CountRecords counts the number of records in the file
func (j *JSONLinesProcessor) CountRecords(ctx context.Context, reader io.Reader) (int, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        count := 0
        
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line != "" </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        
        <span class="cov0" title="0">return count, scanner.Err()</span>
}

// ParseReview parses a single review from JSON line
func (j *JSONLinesProcessor) ParseReview(ctx context.Context, jsonLine []byte, providerID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">review, _, _, err := j.parseLine(ctx, string(jsonLine), providerID)
        return review, err</span>
}

// ParseHotel parses hotel information from JSON line
func (j *JSONLinesProcessor) ParseHotel(ctx context.Context, jsonLine []byte) (*domain.Hotel, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>
        
        <span class="cov0" title="0">return j.parseHotel(ctx, &amp;reviewJSON)</span>
}

// ParseReviewerInfo parses reviewer information from JSON line
func (j *JSONLinesProcessor) ParseReviewerInfo(ctx context.Context, jsonLine []byte) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>
        
        <span class="cov0" title="0">return j.parseReviewerInfo(ctx, &amp;reviewJSON)</span>
}

// ValidateReview validates a review
func (j *JSONLinesProcessor) ValidateReview(ctx context.Context, review *domain.Review) error <span class="cov0" title="0">{
        if review.Rating &lt; 1.0 || review.Rating &gt; 5.0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rating must be between 1.0 and 5.0")
        }</span>
        
        <span class="cov0" title="0">if review.Comment == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("comment cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if len(review.Comment) &gt; j.validator.maxCommentLen </span><span class="cov0" title="0">{
                return fmt.Errorf("comment exceeds maximum length of %d characters", j.validator.maxCommentLen)
        }</span>
        
        <span class="cov0" title="0">if review.Title != "" &amp;&amp; len(review.Title) &gt; j.validator.maxTitleLen </span><span class="cov0" title="0">{
                return fmt.Errorf("title exceeds maximum length of %d characters", j.validator.maxTitleLen)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateHotel validates a hotel
func (j *JSONLinesProcessor) ValidateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        if hotel.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("hotel name cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if hotel.StarRating &lt; 1 || hotel.StarRating &gt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("star rating must be between 1 and 5")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateReviewerInfo validates reviewer information
func (j *JSONLinesProcessor) ValidateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        if reviewerInfo.Email == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("reviewer email cannot be empty")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ProcessBatch processes a batch of reviews
func (j *JSONLinesProcessor) ProcessBatch(ctx context.Context, reviews []domain.Review) error <span class="cov0" title="0">{
        return j.repository.CreateBatch(ctx, reviews)
}</span>

// GetBatchSize returns the current batch size
func (j *JSONLinesProcessor) GetBatchSize() int <span class="cov0" title="0">{
        return j.batchSize
}</span>

// SetBatchSize sets the batch size
func (j *JSONLinesProcessor) SetBatchSize(size int) <span class="cov0" title="0">{
        j.batchSize = size
}</span>

// Validation methods for ReviewValidator
func (v *ReviewValidator) validateReviewJSON(reviewJSON *ReviewJSON) error <span class="cov0" title="0">{
        for _, field := range v.requiredFields </span><span class="cov0" title="0">{
                if err := v.checkRequiredField(reviewJSON, field); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

func (v *ReviewValidator) checkRequiredField(reviewJSON *ReviewJSON, field string) error <span class="cov0" title="0">{
        switch field </span>{
        case "id":<span class="cov0" title="0">
                if reviewJSON.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "hotel_id":<span class="cov0" title="0">
                if reviewJSON.HotelID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "hotel_name":<span class="cov0" title="0">
                if reviewJSON.HotelName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "rating":<span class="cov0" title="0">
                if reviewJSON.Rating == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "comment":<span class="cov0" title="0">
                if reviewJSON.Comment == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "review_date":<span class="cov0" title="0">
                if reviewJSON.ReviewDate == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Helper parsing methods
func (j *JSONLinesProcessor) parseFloat(value interface{}) (float64, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("value is nil")
        }</span>
        
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseFloat(v, 64)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to float64", v)</span>
        }
}

func (j *JSONLinesProcessor) parseInt(value interface{}) (int, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("value is nil")
        }</span>
        
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case int:<span class="cov0" title="0">
                return v, nil</span>
        case int64:<span class="cov0" title="0">
                return int(v), nil</span>
        case float64:<span class="cov0" title="0">
                return int(v), nil</span>
        case float32:<span class="cov0" title="0">
                return int(v), nil</span>
        case string:<span class="cov0" title="0">
                return strconv.Atoi(v)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to int", v)</span>
        }
}

func (j *JSONLinesProcessor) parseBool(value interface{}) (bool, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("value is nil")
        }</span>
        
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseBool(v)</span>
        case int:<span class="cov0" title="0">
                return v != 0, nil</span>
        case float64:<span class="cov0" title="0">
                return v != 0, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("cannot convert %T to bool", v)</span>
        }
}

func (j *JSONLinesProcessor) parseDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        if dateStr == "" </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("date string is empty")
        }</span>
        
        // Try different date formats
        <span class="cov0" title="0">formats := []string{
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05.000Z",
                "2006-01-02T15:04:05-07:00",
                "2006-01-02 15:04:05",
                "2006-01-02",
                "01/02/2006",
                "02/01/2006",
        }
        
        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, dateStr); err == nil </span><span class="cov0" title="0">{
                        return t, nil
                }</span>
        }
        
        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("cannot parse date: %s", dateStr)</span>
}

func (j *JSONLinesProcessor) getStringOrDefault(value, defaultValue string) string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package infrastructure

import (
        "context"
        "crypto/md5"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ReviewRepository implements the domain.ReviewRepository interface
type ReviewRepository struct {
        db     *Database
        logger *logger.Logger
}

// NewReviewRepository creates a new ReviewRepository instance
func NewReviewRepository(db *Database, logger *logger.Logger) domain.ReviewRepository <span class="cov0" title="0">{
        return &amp;ReviewRepository{
                db:     db,
                logger: logger,
        }
}</span>

// Review operations
func (r *ReviewRepository) CreateBatch(ctx context.Context, reviews []domain.Review) error <span class="cov0" title="0">{
        if len(reviews) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">start := time.Now()
        
        // Use transaction for batch operations
        err := r.db.Transaction(ctx, func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Process in batches to avoid memory issues
                batchSize := 1000
                for i := 0; i &lt; len(reviews); i += batchSize </span><span class="cov0" title="0">{
                        end := i + batchSize
                        if end &gt; len(reviews) </span><span class="cov0" title="0">{
                                end = len(reviews)
                        }</span>
                        
                        <span class="cov0" title="0">batch := reviews[i:end]
                        
                        // Use upsert to handle duplicates
                        if err := tx.Clauses(clause.OnConflict{
                                Columns:   []clause.Column{{Name: "external_id"}, {Name: "provider_id"}},
                                DoUpdates: clause.AssignmentColumns([]string{"rating", "comment", "review_date", "updated_at"}),
                        }).Create(&amp;batch).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create batch %d-%d: %w", i, end, err)
                        }</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "Failed to create review batch",
                        "count", len(reviews),
                        "error", err,
                )
                return fmt.Errorf("failed to create review batch: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        r.logger.InfoContext(ctx, "Review batch created successfully",
                "count", len(reviews),
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

func (r *ReviewRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        var review domain.Review
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                First(&amp;review, "id = ?", id).Error
        
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("review not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get review by ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;review, nil</span>
}

func (r *ReviewRepository) GetByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("provider_id = ?", providerID).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by provider: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("hotel_id = ?", hotelID).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetByDateRange(ctx context.Context, startDate, endDate time.Time, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("review_date BETWEEN ? AND ?", startDate, endDate).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by date range: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("id = ?", id).
                Update("status", status)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update review status: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("review not found for status update")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) DeleteByID(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Review{}, "id = ?", id)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete review: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("review not found for deletion")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) Search(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        db := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo")
        
        // Apply text search if query is provided
        if query != "" </span><span class="cov0" title="0">{
                db = db.Where("comment ILIKE ? OR title ILIKE ?", "%"+query+"%", "%"+query+"%")
        }</span>
        
        // Apply filters
        <span class="cov0" title="0">for key, value := range filters </span><span class="cov0" title="0">{
                switch key </span>{
                case "rating":<span class="cov0" title="0">
                        db = db.Where("rating = ?", value)</span>
                case "min_rating":<span class="cov0" title="0">
                        db = db.Where("rating &gt;= ?", value)</span>
                case "max_rating":<span class="cov0" title="0">
                        db = db.Where("rating &lt;= ?", value)</span>
                case "provider_id":<span class="cov0" title="0">
                        db = db.Where("provider_id = ?", value)</span>
                case "hotel_id":<span class="cov0" title="0">
                        db = db.Where("hotel_id = ?", value)</span>
                case "language":<span class="cov0" title="0">
                        db = db.Where("language = ?", value)</span>
                case "sentiment":<span class="cov0" title="0">
                        db = db.Where("sentiment = ?", value)</span>
                case "is_verified":<span class="cov0" title="0">
                        db = db.Where("is_verified = ?", value)</span>
                case "start_date":<span class="cov0" title="0">
                        db = db.Where("review_date &gt;= ?", value)</span>
                case "end_date":<span class="cov0" title="0">
                        db = db.Where("review_date &lt;= ?", value)</span>
                }
        }
        
        <span class="cov0" title="0">err := db.Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search reviews: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetTotalCount(ctx context.Context, filters map[string]interface{}) (int64, error) <span class="cov0" title="0">{
        var count int64
        
        db := r.db.WithContext(ctx).Model(&amp;domain.Review{})
        
        // Apply filters
        for key, value := range filters </span><span class="cov0" title="0">{
                switch key </span>{
                case "rating":<span class="cov0" title="0">
                        db = db.Where("rating = ?", value)</span>
                case "min_rating":<span class="cov0" title="0">
                        db = db.Where("rating &gt;= ?", value)</span>
                case "max_rating":<span class="cov0" title="0">
                        db = db.Where("rating &lt;= ?", value)</span>
                case "provider_id":<span class="cov0" title="0">
                        db = db.Where("provider_id = ?", value)</span>
                case "hotel_id":<span class="cov0" title="0">
                        db = db.Where("hotel_id = ?", value)</span>
                case "language":<span class="cov0" title="0">
                        db = db.Where("language = ?", value)</span>
                case "sentiment":<span class="cov0" title="0">
                        db = db.Where("sentiment = ?", value)</span>
                case "is_verified":<span class="cov0" title="0">
                        db = db.Where("is_verified = ?", value)</span>
                case "start_date":<span class="cov0" title="0">
                        db = db.Where("review_date &gt;= ?", value)</span>
                case "end_date":<span class="cov0" title="0">
                        db = db.Where("review_date &lt;= ?", value)</span>
                }
        }
        
        <span class="cov0" title="0">err := db.Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get total count: %w", err)
        }</span>
        
        <span class="cov0" title="0">return count, nil</span>
}

// Hotel operations
func (r *ReviewRepository) CreateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(hotel).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Hotel created successfully", "hotel_id", hotel.ID, "name", hotel.Name)
        return nil</span>
}

func (r *ReviewRepository) GetHotelByID(ctx context.Context, id uuid.UUID) (*domain.Hotel, error) <span class="cov0" title="0">{
        var hotel domain.Hotel
        
        err := r.db.WithContext(ctx).First(&amp;hotel, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("hotel not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get hotel by ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;hotel, nil</span>
}

func (r *ReviewRepository) GetHotelByName(ctx context.Context, name string) (*domain.Hotel, error) <span class="cov0" title="0">{
        var hotel domain.Hotel
        
        err := r.db.WithContext(ctx).Where("name = ?", name).First(&amp;hotel).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("hotel not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get hotel by name: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;hotel, nil</span>
}

func (r *ReviewRepository) UpdateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(hotel).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Hotel updated successfully", "hotel_id", hotel.ID, "name", hotel.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteHotel(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Hotel{}, "id = ?", id)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete hotel: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("hotel not found for deletion")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) ListHotels(ctx context.Context, limit, offset int) ([]domain.Hotel, error) <span class="cov0" title="0">{
        var hotels []domain.Hotel
        
        err := r.db.WithContext(ctx).
                Order("name").
                Limit(limit).
                Offset(offset).
                Find(&amp;hotels).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list hotels: %w", err)
        }</span>
        
        <span class="cov0" title="0">return hotels, nil</span>
}

// Provider operations
func (r *ReviewRepository) CreateProvider(ctx context.Context, provider *domain.Provider) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(provider).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create provider: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Provider created successfully", "provider_id", provider.ID, "name", provider.Name)
        return nil</span>
}

func (r *ReviewRepository) GetProviderByID(ctx context.Context, id uuid.UUID) (*domain.Provider, error) <span class="cov0" title="0">{
        var provider domain.Provider
        
        err := r.db.WithContext(ctx).First(&amp;provider, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("provider not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get provider by ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;provider, nil</span>
}

func (r *ReviewRepository) GetProviderByName(ctx context.Context, name string) (*domain.Provider, error) <span class="cov0" title="0">{
        var provider domain.Provider
        
        err := r.db.WithContext(ctx).Where("name = ?", name).First(&amp;provider).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("provider not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get provider by name: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;provider, nil</span>
}

func (r *ReviewRepository) UpdateProvider(ctx context.Context, provider *domain.Provider) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(provider).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update provider: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Provider updated successfully", "provider_id", provider.ID, "name", provider.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteProvider(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Provider{}, "id = ?", id)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete provider: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provider not found for deletion")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) ListProviders(ctx context.Context, limit, offset int) ([]domain.Provider, error) <span class="cov0" title="0">{
        var providers []domain.Provider
        
        err := r.db.WithContext(ctx).
                Order("name").
                Limit(limit).
                Offset(offset).
                Find(&amp;providers).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list providers: %w", err)
        }</span>
        
        <span class="cov0" title="0">return providers, nil</span>
}

// ReviewerInfo operations
func (r *ReviewRepository) CreateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create reviewer info: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Reviewer info created successfully", "reviewer_id", reviewerInfo.ID, "name", reviewerInfo.Name)
        return nil</span>
}

func (r *ReviewRepository) GetReviewerInfoByID(ctx context.Context, id uuid.UUID) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewerInfo domain.ReviewerInfo
        
        err := r.db.WithContext(ctx).First(&amp;reviewerInfo, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reviewer info not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get reviewer info by ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;reviewerInfo, nil</span>
}

func (r *ReviewRepository) GetReviewerInfoByEmail(ctx context.Context, email string) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewerInfo domain.ReviewerInfo
        
        err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reviewer info not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get reviewer info by email: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;reviewerInfo, nil</span>
}

func (r *ReviewRepository) UpdateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update reviewer info: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Reviewer info updated successfully", "reviewer_id", reviewerInfo.ID, "name", reviewerInfo.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteReviewerInfo(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.ReviewerInfo{}, "id = ?", id)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete reviewer info: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("reviewer info not found for deletion")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Review summary operations
func (r *ReviewRepository) CreateOrUpdateReviewSummary(ctx context.Context, summary *domain.ReviewSummary) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "hotel_id"}},
                DoUpdates: clause.AssignmentColumns([]string{"total_reviews", "average_rating", "rating_distribution", "avg_service_rating", "avg_cleanliness_rating", "avg_location_rating", "avg_value_rating", "avg_comfort_rating", "avg_facilities_rating", "last_review_date", "updated_at"}),
        }).Create(summary).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create or update review summary: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Review summary created/updated successfully", "hotel_id", summary.HotelID)
        return nil</span>
}

func (r *ReviewRepository) GetReviewSummaryByHotelID(ctx context.Context, hotelID uuid.UUID) (*domain.ReviewSummary, error) <span class="cov0" title="0">{
        var summary domain.ReviewSummary
        
        err := r.db.WithContext(ctx).
                Preload("Hotel").
                First(&amp;summary, "hotel_id = ?", hotelID).Error
        
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("review summary not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get review summary by hotel ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;summary, nil</span>
}

func (r *ReviewRepository) UpdateReviewSummary(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        // Calculate aggregated statistics
        var stats struct {
                TotalReviews         int64
                AverageRating        float64
                AvgServiceRating     float64
                AvgCleanlinessRating float64
                AvgLocationRating    float64
                AvgValueRating       float64
                AvgComfortRating     float64
                AvgFacilitiesRating  float64
                LastReviewDate       time.Time
        }
        
        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select(`
                        COUNT(*) as total_reviews,
                        AVG(rating) as average_rating,
                        AVG(service_rating) as avg_service_rating,
                        AVG(cleanliness_rating) as avg_cleanliness_rating,
                        AVG(location_rating) as avg_location_rating,
                        AVG(value_rating) as avg_value_rating,
                        AVG(comfort_rating) as avg_comfort_rating,
                        AVG(facilities_rating) as avg_facilities_rating,
                        MAX(review_date) as last_review_date
                `).
                Scan(&amp;stats).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate review statistics: %w", err)
        }</span>
        
        // Get rating distribution
        <span class="cov0" title="0">var ratingDist []struct {
                Rating int
                Count  int64
        }
        
        err = r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select("FLOOR(rating) as rating, COUNT(*) as count").
                Group("FLOOR(rating)").
                Scan(&amp;ratingDist).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rating distribution: %w", err)
        }</span>
        
        // Build rating distribution map
        <span class="cov0" title="0">ratingDistribution := make(map[string]int)
        for _, dist := range ratingDist </span><span class="cov0" title="0">{
                ratingDistribution[fmt.Sprintf("%.0f", float64(dist.Rating))] = int(dist.Count)
        }</span>
        
        // Update or create summary
        <span class="cov0" title="0">summary := &amp;domain.ReviewSummary{
                HotelID:              hotelID,
                TotalReviews:         int(stats.TotalReviews),
                AverageRating:        stats.AverageRating,
                RatingDistribution:   ratingDistribution,
                AvgServiceRating:     stats.AvgServiceRating,
                AvgCleanlinessRating: stats.AvgCleanlinessRating,
                AvgLocationRating:    stats.AvgLocationRating,
                AvgValueRating:       stats.AvgValueRating,
                AvgComfortRating:     stats.AvgComfortRating,
                AvgFacilitiesRating:  stats.AvgFacilitiesRating,
                LastReviewDate:       stats.LastReviewDate,
        }
        
        return r.CreateOrUpdateReviewSummary(ctx, summary)</span>
}

// Review processing status operations
func (r *ReviewRepository) CreateProcessingStatus(ctx context.Context, status *domain.ReviewProcessingStatus) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(status).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create processing status: %w", err)
        }</span>
        
        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Processing status created successfully", "processing_id", status.ID, "provider_id", status.ProviderID)
        return nil</span>
}

func (r *ReviewRepository) GetProcessingStatusByID(ctx context.Context, id uuid.UUID) (*domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        var status domain.ReviewProcessingStatus
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                First(&amp;status, "id = ?", id).Error
        
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("processing status not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get processing status by ID: %w", err)</span>
        }
        
        <span class="cov0" title="0">return &amp;status, nil</span>
}

func (r *ReviewRepository) GetProcessingStatusByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        var statuses []domain.ReviewProcessingStatus
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Where("provider_id = ?", providerID).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;statuses).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing status by provider: %w", err)
        }</span>
        
        <span class="cov0" title="0">return statuses, nil</span>
}

func (r *ReviewRepository) UpdateProcessingStatus(ctx context.Context, id uuid.UUID, status string, recordsProcessed int, errorMsg string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":            status,
                "records_processed": recordsProcessed,
                "error_msg":         errorMsg,
                "updated_at":        time.Now(),
        }
        
        if status == "processing" </span><span class="cov0" title="0">{
                updates["started_at"] = time.Now()
        }</span> else<span class="cov0" title="0"> if status == "completed" || status == "failed" </span><span class="cov0" title="0">{
                updates["completed_at"] = time.Now()
        }</span>
        
        <span class="cov0" title="0">result := r.db.WithContext(ctx).
                Model(&amp;domain.ReviewProcessingStatus{}).
                Where("id = ?", id).
                Updates(updates)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update processing status: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("processing status not found for update")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) DeleteProcessingStatus(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.ReviewProcessingStatus{}, "id = ?", id)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete processing status: %w", result.Error)
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("processing status not found for deletion")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Duplicate prevention methods
func (r *ReviewRepository) FindDuplicateReviews(ctx context.Context, review *domain.Review) ([]domain.Review, error) <span class="cov0" title="0">{
        var duplicates []domain.Review
        
        // Generate content hash for duplicate detection
        contentHash := r.generateContentHash(review)
        
        err := r.db.WithContext(ctx).
                Where("hotel_id = ? AND provider_id = ? AND processing_hash = ?", 
                        review.HotelID, review.ProviderID, contentHash).
                Find(&amp;duplicates).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find duplicate reviews: %w", err)
        }</span>
        
        <span class="cov0" title="0">return duplicates, nil</span>
}

func (r *ReviewRepository) CheckProcessingHashExists(ctx context.Context, hash string) (bool, error) <span class="cov0" title="0">{
        var count int64
        
        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("processing_hash = ?", hash).
                Count(&amp;count).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check processing hash existence: %w", err)
        }</span>
        
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *ReviewRepository) UpsertReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "email"}},
                DoUpdates: clause.AssignmentColumns([]string{"name", "country", "is_verified", "total_reviews", "average_rating", "member_since", "profile_image_url", "bio", "updated_at"}),
        }).Create(reviewerInfo).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert reviewer info: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) UpsertHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "name"}, {Name: "city"}, {Name: "country"}},
                DoUpdates: clause.AssignmentColumns([]string{"address", "postal_code", "phone", "email", "star_rating", "description", "amenities", "latitude", "longitude", "updated_at"}),
        }).Create(hotel).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Helper methods
func (r *ReviewRepository) generateContentHash(review *domain.Review) string <span class="cov0" title="0">{
        content := fmt.Sprintf("%s|%s|%f|%s|%s",
                review.HotelID.String(),
                review.ProviderID.String(),
                review.Rating,
                review.Comment,
                review.ReviewDate.Format("2006-01-02"),
        )
        
        hash := md5.Sum([]byte(content))
        return fmt.Sprintf("%x", hash)
}</span>

func (r *ReviewRepository) GetBatchInsertSize() int <span class="cov0" title="0">{
        return 1000
}</span>

func (r *ReviewRepository) GetReviewsForSummaryUpdate(ctx context.Context, hotelID uuid.UUID, limit int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Where("hotel_id = ?", hotelID).
                Order("review_date DESC").
                Limit(limit).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews for summary update: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetReviewCountByProvider(ctx context.Context, providerID uuid.UUID, startDate, endDate time.Time) (int64, error) <span class="cov0" title="0">{
        var count int64
        
        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("provider_id = ? AND review_date BETWEEN ? AND ?", providerID, startDate, endDate).
                Count(&amp;count).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get review count by provider: %w", err)
        }</span>
        
        <span class="cov0" title="0">return count, nil</span>
}

func (r *ReviewRepository) GetReviewCountByHotel(ctx context.Context, hotelID uuid.UUID, startDate, endDate time.Time) (int64, error) <span class="cov0" title="0">{
        var count int64
        
        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ? AND review_date BETWEEN ? AND ?", hotelID, startDate, endDate).
                Count(&amp;count).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get review count by hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">return count, nil</span>
}

func (r *ReviewRepository) GetAverageRatingByHotel(ctx context.Context, hotelID uuid.UUID) (float64, error) <span class="cov0" title="0">{
        var avgRating float64
        
        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select("AVG(rating)").
                Scan(&amp;avgRating).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get average rating by hotel: %w", err)
        }</span>
        
        <span class="cov0" title="0">return avgRating, nil</span>
}

func (r *ReviewRepository) GetTopRatedHotels(ctx context.Context, limit int) ([]domain.Hotel, error) <span class="cov0" title="0">{
        var hotels []domain.Hotel
        
        err := r.db.WithContext(ctx).
                Table("hotels").
                Select("hotels.*, AVG(reviews.rating) as avg_rating").
                Joins("LEFT JOIN reviews ON hotels.id = reviews.hotel_id").
                Group("hotels.id").
                Order("avg_rating DESC").
                Limit(limit).
                Find(&amp;hotels).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top rated hotels: %w", err)
        }</span>
        
        <span class="cov0" title="0">return hotels, nil</span>
}

func (r *ReviewRepository) GetRecentReviews(ctx context.Context, limit int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Order("review_date DESC").
                Limit(limit).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent reviews: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) BulkUpdateReviewSentiment(ctx context.Context, updates map[uuid.UUID]string) error <span class="cov0" title="0">{
        return r.db.Transaction(ctx, func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                for reviewID, sentiment := range updates </span><span class="cov0" title="0">{
                        if err := tx.Model(&amp;domain.Review{}).
                                Where("id = ?", reviewID).
                                Update("sentiment", sentiment).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update sentiment for review %s: %w", reviewID, err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

func (r *ReviewRepository) GetReviewsWithoutSentiment(ctx context.Context, limit int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review
        
        err := r.db.WithContext(ctx).
                Where("sentiment IS NULL OR sentiment = ''").
                Limit(limit).
                Find(&amp;reviews).Error
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews without sentiment: %w", err)
        }</span>
        
        <span class="cov0" title="0">return reviews, nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package infrastructure

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/feature/s3/manager"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        "github.com/aws/smithy-go"

        pkgConfig "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// S3Client represents the S3 client wrapper
type S3Client struct {
        client     *s3.Client
        uploader   *manager.Uploader
        downloader *manager.Downloader
        config     *pkgConfig.S3Config
        logger     *logger.Logger
}

// ObjectInfo represents S3 object information
type ObjectInfo struct {
        Key          string
        Size         int64
        LastModified time.Time
        ETag         string
        StorageClass string
        ContentType  string
}

// ListObjectsResult represents the result of listing objects
type ListObjectsResult struct {
        Objects       []ObjectInfo
        NextToken     *string
        IsTruncated   bool
        CommonPrefixes []string
}

// DownloadResult represents the result of downloading an object
type DownloadResult struct {
        Body          io.ReadCloser
        ContentLength int64
        ContentType   string
        LastModified  time.Time
        ETag          string
        Metadata      map[string]string
}

// NewS3Client creates a new S3 client
func NewS3Client(cfg *pkgConfig.S3Config, log *logger.Logger) (*S3Client, error) <span class="cov0" title="0">{
        ctx := context.Background()
        
        // Create AWS config
        awsConfig, err := createAWSConfig(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AWS config: %w", err)
        }</span>
        
        // Create S3 client
        <span class="cov0" title="0">s3Client := s3.NewFromConfig(awsConfig, func(o *s3.Options) </span><span class="cov0" title="0">{
                if cfg.Endpoint != "" </span><span class="cov0" title="0">{
                        o.BaseEndpoint = aws.String(cfg.Endpoint)
                }</span>
                <span class="cov0" title="0">o.UsePathStyle = cfg.ForcePathStyle</span>
        })
        
        // Create uploader and downloader with custom configurations
        <span class="cov0" title="0">uploader := manager.NewUploader(s3Client, func(u *manager.Uploader) </span><span class="cov0" title="0">{
                u.PartSize = cfg.UploadPartSize
                u.Concurrency = 5
        }</span>)
        
        <span class="cov0" title="0">downloader := manager.NewDownloader(s3Client, func(d *manager.Downloader) </span><span class="cov0" title="0">{
                d.PartSize = cfg.DownloadPartSize
                d.Concurrency = 5
        }</span>)
        
        <span class="cov0" title="0">client := &amp;S3Client{
                client:     s3Client,
                uploader:   uploader,
                downloader: downloader,
                config:     cfg,
                logger:     log,
        }
        
        // Test connection
        if err := client.testConnection(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("S3 connection test failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">log.Info("S3 client initialized successfully",
                "region", cfg.Region,
                "bucket", cfg.Bucket,
                "endpoint", cfg.Endpoint,
        )
        
        return client, nil</span>
}

// createAWSConfig creates AWS configuration
func createAWSConfig(ctx context.Context, cfg *pkgConfig.S3Config) (aws.Config, error) <span class="cov0" title="0">{
        var awsConfig aws.Config
        var err error
        
        if cfg.AccessKeyID != "" &amp;&amp; cfg.SecretAccessKey != "" </span><span class="cov0" title="0">{
                // Use static credentials
                credProvider := credentials.NewStaticCredentialsProvider(
                        cfg.AccessKeyID,
                        cfg.SecretAccessKey,
                        cfg.SessionToken,
                )
                
                awsConfig, err = config.LoadDefaultConfig(ctx,
                        config.WithRegion(cfg.Region),
                        config.WithCredentialsProvider(credProvider),
                )
        }</span> else<span class="cov0" title="0"> {
                // Use default credential chain (IAM roles, environment variables, etc.)
                awsConfig, err = config.LoadDefaultConfig(ctx,
                        config.WithRegion(cfg.Region),
                )
        }</span>
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return aws.Config{}, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>
        
        <span class="cov0" title="0">return awsConfig, nil</span>
}

// testConnection tests the S3 connection
func (s *S3Client) testConnection(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, s.config.Timeout)
        defer cancel()
        
        // Try to get bucket location
        _, err := s.client.GetBucketLocation(ctx, &amp;s3.GetBucketLocationInput{
                Bucket: aws.String(s.config.Bucket),
        })
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get bucket location: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// UploadFile uploads a file to S3
func (s *S3Client) UploadFile(ctx context.Context, bucket, key string, body io.Reader, contentType string) error <span class="cov0" title="0">{
        start := time.Now()
        
        input := &amp;s3.PutObjectInput{
                Bucket:      aws.String(bucket),
                Key:         aws.String(key),
                Body:        body,
                ContentType: aws.String(contentType),
        }
        
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.uploader.Upload(ctx, input)
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to upload file to S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File uploaded to S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// DownloadFile downloads a file from S3
func (s *S3Client) DownloadFile(ctx context.Context, bucket, key string) (io.ReadCloser, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Get object metadata first
        headOutput, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object metadata: %w", err)
        }</span>
        
        // Create a streaming downloader
        <span class="cov0" title="0">getOutput, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File download from S3 started",
                "bucket", bucket,
                "key", key,
                "size", headOutput.ContentLength,
                "duration_ms", duration.Milliseconds(),
        )
        
        return getOutput.Body, nil</span>
}

// GetFileURL generates a presigned URL for file access
func (s *S3Client) GetFileURL(ctx context.Context, bucket, key string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        presignClient := s3.NewPresignClient(s.client)
        
        request, err := presignClient.PresignGetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        }, func(opts *s3.PresignOptions) </span><span class="cov0" title="0">{
                opts.Expires = expiration
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>
        
        <span class="cov0" title="0">s.logger.DebugContext(ctx, "Generated presigned URL",
                "bucket", bucket,
                "key", key,
                "expiration", expiration,
        )
        
        return request.URL, nil</span>
}

// DeleteFile deletes a file from S3
func (s *S3Client) DeleteFile(ctx context.Context, bucket, key string) error <span class="cov0" title="0">{
        start := time.Now()
        
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to delete file from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File deleted from S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// ListFiles lists files in S3 bucket with pagination support
func (s *S3Client) ListFiles(ctx context.Context, bucket, prefix string, limit int) ([]string, error) <span class="cov0" title="0">{
        result, err := s.ListObjects(ctx, bucket, prefix, "", limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">files := make([]string, len(result.Objects))
        for i, obj := range result.Objects </span><span class="cov0" title="0">{
                files[i] = obj.Key
        }</span>
        
        <span class="cov0" title="0">return files, nil</span>
}

// ListObjects lists objects in S3 bucket with detailed information and pagination
func (s *S3Client) ListObjects(ctx context.Context, bucket, prefix, continuationToken string, maxKeys int) (*ListObjectsResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        input := &amp;s3.ListObjectsV2Input{
                Bucket:  aws.String(bucket),
                Prefix:  aws.String(prefix),
                MaxKeys: aws.Int32(int32(maxKeys)),
        }
        
        if continuationToken != "" </span><span class="cov0" title="0">{
                input.ContinuationToken = aws.String(continuationToken)
        }</span>
        
        <span class="cov0" title="0">var output *s3.ListObjectsV2Output
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                output, err = s.client.ListObjectsV2(ctx, input)
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to list objects in S3",
                        "bucket", bucket,
                        "prefix", prefix,
                        "error", err,
                )
                return nil, fmt.Errorf("failed to list objects: %w", err)
        }</span>
        
        // Convert to ObjectInfo slice
        <span class="cov0" title="0">objects := make([]ObjectInfo, len(output.Contents))
        for i, obj := range output.Contents </span><span class="cov0" title="0">{
                objects[i] = ObjectInfo{
                        Key:          aws.ToString(obj.Key),
                        Size:         aws.ToInt64(obj.Size),
                        LastModified: aws.ToTime(obj.LastModified),
                        ETag:         aws.ToString(obj.ETag),
                        StorageClass: string(obj.StorageClass),
                }
        }</span>
        
        // Extract common prefixes
        <span class="cov0" title="0">commonPrefixes := make([]string, len(output.CommonPrefixes))
        for i, cp := range output.CommonPrefixes </span><span class="cov0" title="0">{
                commonPrefixes[i] = aws.ToString(cp.Prefix)
        }</span>
        
        <span class="cov0" title="0">result := &amp;ListObjectsResult{
                Objects:        objects,
                IsTruncated:    aws.ToBool(output.IsTruncated),
                CommonPrefixes: commonPrefixes,
        }
        
        if output.NextContinuationToken != nil </span><span class="cov0" title="0">{
                result.NextToken = output.NextContinuationToken
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "Objects listed successfully",
                "bucket", bucket,
                "prefix", prefix,
                "count", len(objects),
                "is_truncated", result.IsTruncated,
                "duration_ms", duration.Milliseconds(),
        )
        
        return result, nil</span>
}

// GetFileMetadata gets file metadata from S3
func (s *S3Client) GetFileMetadata(ctx context.Context, bucket, key string) (map[string]string, error) <span class="cov0" title="0">{
        start := time.Now()
        
        var output *s3.HeadObjectOutput
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                output, err = s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to get file metadata from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return nil, fmt.Errorf("failed to get file metadata: %w", err)
        }</span>
        
        <span class="cov0" title="0">metadata := make(map[string]string)
        
        // Add standard metadata
        metadata["content-type"] = aws.ToString(output.ContentType)
        metadata["content-length"] = fmt.Sprintf("%d", output.ContentLength)
        metadata["last-modified"] = aws.ToTime(output.LastModified).Format(time.RFC3339)
        metadata["etag"] = aws.ToString(output.ETag)
        
        if output.StorageClass != "" </span><span class="cov0" title="0">{
                metadata["storage-class"] = string(output.StorageClass)
        }</span>
        
        // Add custom metadata
        <span class="cov0" title="0">for k, v := range output.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.DebugContext(ctx, "File metadata retrieved successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return metadata, nil</span>
}

// UpdateFileMetadata updates file metadata in S3
func (s *S3Client) UpdateFileMetadata(ctx context.Context, bucket, key string, metadata map[string]string) error <span class="cov0" title="0">{
        start := time.Now()
        
        // First get the current object
        getOutput, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get object for metadata update: %w", err)
        }</span>
        <span class="cov0" title="0">defer getOutput.Body.Close()
        
        // Prepare metadata for update
        s3Metadata := make(map[string]string)
        var contentType string
        
        for k, v := range metadata </span><span class="cov0" title="0">{
                if k == "content-type" </span><span class="cov0" title="0">{
                        contentType = v
                }</span> else<span class="cov0" title="0"> {
                        s3Metadata[k] = v
                }</span>
        }
        
        // Copy object with new metadata
        <span class="cov0" title="0">err = s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.CopyObject(ctx, &amp;s3.CopyObjectInput{
                        Bucket:            aws.String(bucket),
                        Key:               aws.String(key),
                        CopySource:        aws.String(fmt.Sprintf("%s/%s", bucket, key)),
                        Metadata:          s3Metadata,
                        MetadataDirective: types.MetadataDirectiveReplace,
                        ContentType:       aws.String(contentType),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to update file metadata in S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to update file metadata: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File metadata updated successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// CreateBucket creates a new S3 bucket
func (s *S3Client) CreateBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        start := time.Now()
        
        input := &amp;s3.CreateBucketInput{
                Bucket: aws.String(bucket),
        }
        
        // Add location constraint if not in us-east-1
        if s.config.Region != "us-east-1" </span><span class="cov0" title="0">{
                input.CreateBucketConfiguration = &amp;types.CreateBucketConfiguration{
                        LocationConstraint: types.BucketLocationConstraint(s.config.Region),
                }
        }</span>
        
        <span class="cov0" title="0">err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.CreateBucket(ctx, input)
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to create S3 bucket",
                        "bucket", bucket,
                        "error", err,
                )
                return fmt.Errorf("failed to create bucket: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "S3 bucket created successfully",
                "bucket", bucket,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// DeleteBucket deletes an S3 bucket
func (s *S3Client) DeleteBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        start := time.Now()
        
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.DeleteBucket(ctx, &amp;s3.DeleteBucketInput{
                        Bucket: aws.String(bucket),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to delete S3 bucket",
                        "bucket", bucket,
                        "error", err,
                )
                return fmt.Errorf("failed to delete bucket: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "S3 bucket deleted successfully",
                "bucket", bucket,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// BucketExists checks if a bucket exists
func (s *S3Client) BucketExists(ctx context.Context, bucket string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadBucket(ctx, &amp;s3.HeadBucketInput{
                Bucket: aws.String(bucket),
        })
        
        if err != nil </span><span class="cov0" title="0">{
                var apiErr smithy.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        if apiErr.ErrorCode() == "NotFound" </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check bucket existence: %w", err)</span>
        }
        
        <span class="cov0" title="0">return true, nil</span>
}

// FileExists checks if a file exists in S3
func (s *S3Client) FileExists(ctx context.Context, bucket, key string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        
        if err != nil </span><span class="cov0" title="0">{
                var apiErr smithy.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        if apiErr.ErrorCode() == "NotFound" </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check file existence: %w", err)</span>
        }
        
        <span class="cov0" title="0">return true, nil</span>
}

// GetFileSize gets the size of a file in S3
func (s *S3Client) GetFileSize(ctx context.Context, bucket, key string) (int64, error) <span class="cov0" title="0">{
        output, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get file size: %w", err)
        }</span>
        
        <span class="cov0" title="0">return aws.ToInt64(output.ContentLength), nil</span>
}

// retryOperation performs an operation with retry logic
func (s *S3Client) retryOperation(ctx context.Context, operation func() error) error <span class="cov0" title="0">{
        var lastErr error
        
        for attempt := 0; attempt &lt;= s.config.RetryCount; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(s.config.RetryDelay * time.Duration(attempt)):<span class="cov0" title="0"></span>
                                // Exponential backoff
                        }
                }
                
                <span class="cov0" title="0">err := operation()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                <span class="cov0" title="0">lastErr = err
                
                // Check if error is retryable
                if !s.isRetryableError(err) </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">s.logger.WarnContext(ctx, "S3 operation failed, retrying...",
                        "attempt", attempt+1,
                        "max_retries", s.config.RetryCount,
                        "error", err,
                )</span>
        }
        
        <span class="cov0" title="0">return lastErr</span>
}

// isRetryableError checks if an error is retryable
func (s *S3Client) isRetryableError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                errorCode := apiErr.ErrorCode()
                
                // Common retryable errors
                retryableErrors := []string{
                        "InternalError",
                        "ServiceUnavailable",
                        "SlowDown",
                        "RequestTimeout",
                        "ThrottlingException",
                }
                
                for _, retryable := range retryableErrors </span><span class="cov0" title="0">{
                        if errorCode == retryable </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                
                // HTTP 5xx errors are generally retryable
                <span class="cov0" title="0">if strings.HasPrefix(errorCode, "5") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// DownloadToWriter downloads a file from S3 to a writer (streaming)
func (s *S3Client) DownloadToWriter(ctx context.Context, bucket, key string, writer io.WriterAt) error <span class="cov0" title="0">{
        start := time.Now()
        
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.downloader.Download(ctx, writer, &amp;s3.GetObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to download file from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to download file: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File downloaded from S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}

// UploadFromReader uploads a file to S3 from a reader (streaming)
func (s *S3Client) UploadFromReader(ctx context.Context, bucket, key string, reader io.Reader, contentType string) error <span class="cov0" title="0">{
        start := time.Now()
        
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.uploader.Upload(ctx, &amp;s3.PutObjectInput{
                        Bucket:      aws.String(bucket),
                        Key:         aws.String(key),
                        Body:        reader,
                        ContentType: aws.String(contentType),
                })
                return err
        }</span>)
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to upload file to S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>
        
        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File uploaded to S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )
        
        return nil</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/spf13/viper"
)

// Config represents the main configuration structure
type Config struct {
        Database     DatabaseConfig     `mapstructure:"database" json:"database"`
        S3           S3Config           `mapstructure:"s3" json:"s3"`
        Server       ServerConfig       `mapstructure:"server" json:"server"`
        Log          LogConfig          `mapstructure:"log" json:"log"`
        Cache        CacheConfig        `mapstructure:"cache" json:"cache"`
        Metrics      MetricsConfig      `mapstructure:"metrics" json:"metrics"`
        Notification NotificationConfig `mapstructure:"notification" json:"notification"`
        Processing   ProcessingConfig   `mapstructure:"processing" json:"processing"`
        Security     SecurityConfig     `mapstructure:"security" json:"security"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Host            string        `mapstructure:"host" json:"host" validate:"required"`
        Port            int           `mapstructure:"port" json:"port" validate:"required,min=1,max=65535"`
        User            string        `mapstructure:"user" json:"user" validate:"required"`
        Password        string        `mapstructure:"password" json:"password" validate:"required"`
        Name            string        `mapstructure:"name" json:"name" validate:"required"`
        SSLMode         string        `mapstructure:"ssl_mode" json:"ssl_mode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns" json:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns" json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime" json:"conn_max_lifetime"`
        ConnMaxIdleTime time.Duration `mapstructure:"conn_max_idle_time" json:"conn_max_idle_time"`
        TimeZone        string        `mapstructure:"timezone" json:"timezone"`
        LogLevel        string        `mapstructure:"log_level" json:"log_level"`
}

// S3Config represents AWS S3 configuration
type S3Config struct {
        Region          string        `mapstructure:"region" json:"region" validate:"required"`
        AccessKeyID     string        `mapstructure:"access_key_id" json:"access_key_id" validate:"required"`
        SecretAccessKey string        `mapstructure:"secret_access_key" json:"secret_access_key" validate:"required"`
        SessionToken    string        `mapstructure:"session_token" json:"session_token"`
        Bucket          string        `mapstructure:"bucket" json:"bucket" validate:"required"`
        Endpoint        string        `mapstructure:"endpoint" json:"endpoint"`
        UseSSL          bool          `mapstructure:"use_ssl" json:"use_ssl"`
        ForcePathStyle  bool          `mapstructure:"force_path_style" json:"force_path_style"`
        Timeout         time.Duration `mapstructure:"timeout" json:"timeout"`
        RetryCount      int           `mapstructure:"retry_count" json:"retry_count"`
        RetryDelay      time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        UploadPartSize  int64         `mapstructure:"upload_part_size" json:"upload_part_size"`
        DownloadPartSize int64        `mapstructure:"download_part_size" json:"download_part_size"`
}

// ServerConfig represents HTTP server configuration
type ServerConfig struct {
        Host            string        `mapstructure:"host" json:"host"`
        Port            int           `mapstructure:"port" json:"port" validate:"required,min=1,max=65535"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout" json:"write_timeout"`
        IdleTimeout     time.Duration `mapstructure:"idle_timeout" json:"idle_timeout"`
        ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout" json:"shutdown_timeout"`
        MaxHeaderBytes  int           `mapstructure:"max_header_bytes" json:"max_header_bytes"`
        EnableCORS      bool          `mapstructure:"enable_cors" json:"enable_cors"`
        EnableGzip      bool          `mapstructure:"enable_gzip" json:"enable_gzip"`
        EnableMetrics   bool          `mapstructure:"enable_metrics" json:"enable_metrics"`
        EnablePprof     bool          `mapstructure:"enable_pprof" json:"enable_pprof"`
        TLSCertFile     string        `mapstructure:"tls_cert_file" json:"tls_cert_file"`
        TLSKeyFile      string        `mapstructure:"tls_key_file" json:"tls_key_file"`
        TrustedProxies  []string      `mapstructure:"trusted_proxies" json:"trusted_proxies"`
}

// LogConfig represents logging configuration
type LogConfig struct {
        Level           string `mapstructure:"level" json:"level" validate:"required,oneof=debug info warn error"`
        Format          string `mapstructure:"format" json:"format" validate:"required,oneof=json text"`
        Output          string `mapstructure:"output" json:"output" validate:"required,oneof=stdout stderr file"`
        FilePath        string `mapstructure:"file_path" json:"file_path"`
        MaxSize         int    `mapstructure:"max_size" json:"max_size"`
        MaxBackups      int    `mapstructure:"max_backups" json:"max_backups"`
        MaxAge          int    `mapstructure:"max_age" json:"max_age"`
        Compress        bool   `mapstructure:"compress" json:"compress"`
        EnableCaller    bool   `mapstructure:"enable_caller" json:"enable_caller"`
        EnableStacktrace bool  `mapstructure:"enable_stacktrace" json:"enable_stacktrace"`
}

// CacheConfig represents cache configuration
type CacheConfig struct {
        Type        string        `mapstructure:"type" json:"type" validate:"required,oneof=redis memory"`
        Host        string        `mapstructure:"host" json:"host"`
        Port        int           `mapstructure:"port" json:"port"`
        Password    string        `mapstructure:"password" json:"password"`
        Database    int           `mapstructure:"database" json:"database"`
        PoolSize    int           `mapstructure:"pool_size" json:"pool_size"`
        MinIdleConns int          `mapstructure:"min_idle_conns" json:"min_idle_conns"`
        DialTimeout time.Duration `mapstructure:"dial_timeout" json:"dial_timeout"`
        ReadTimeout time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
        WriteTimeout time.Duration `mapstructure:"write_timeout" json:"write_timeout"`
        TTL         time.Duration `mapstructure:"ttl" json:"ttl"`
        MaxMemory   int64         `mapstructure:"max_memory" json:"max_memory"`
}

// MetricsConfig represents metrics configuration
type MetricsConfig struct {
        Enabled     bool   `mapstructure:"enabled" json:"enabled"`
        Type        string `mapstructure:"type" json:"type" validate:"oneof=prometheus jaeger"`
        Host        string `mapstructure:"host" json:"host"`
        Port        int    `mapstructure:"port" json:"port"`
        Path        string `mapstructure:"path" json:"path"`
        Namespace   string `mapstructure:"namespace" json:"namespace"`
        ServiceName string `mapstructure:"service_name" json:"service_name"`
        Environment string `mapstructure:"environment" json:"environment"`
        Version     string `mapstructure:"version" json:"version"`
}

// NotificationConfig represents notification configuration
type NotificationConfig struct {
        Email EmailConfig `mapstructure:"email" json:"email"`
        Slack SlackConfig `mapstructure:"slack" json:"slack"`
}

// EmailConfig represents email notification configuration
type EmailConfig struct {
        Enabled  bool   `mapstructure:"enabled" json:"enabled"`
        Host     string `mapstructure:"host" json:"host"`
        Port     int    `mapstructure:"port" json:"port"`
        Username string `mapstructure:"username" json:"username"`
        Password string `mapstructure:"password" json:"password"`
        From     string `mapstructure:"from" json:"from"`
        UseTLS   bool   `mapstructure:"use_tls" json:"use_tls"`
}

// SlackConfig represents Slack notification configuration
type SlackConfig struct {
        Enabled     bool   `mapstructure:"enabled" json:"enabled"`
        WebhookURL  string `mapstructure:"webhook_url" json:"webhook_url"`
        Channel     string `mapstructure:"channel" json:"channel"`
        Username    string `mapstructure:"username" json:"username"`
        IconEmoji   string `mapstructure:"icon_emoji" json:"icon_emoji"`
        IconURL     string `mapstructure:"icon_url" json:"icon_url"`
}

// ProcessingConfig represents file processing configuration
type ProcessingConfig struct {
        BatchSize           int           `mapstructure:"batch_size" json:"batch_size"`
        WorkerCount         int           `mapstructure:"worker_count" json:"worker_count"`
        MaxFileSize         int64         `mapstructure:"max_file_size" json:"max_file_size"`
        ProcessingTimeout   time.Duration `mapstructure:"processing_timeout" json:"processing_timeout"`
        MaxRetries          int           `mapstructure:"max_retries" json:"max_retries"`
        RetryDelay          time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        EnableValidation    bool          `mapstructure:"enable_validation" json:"enable_validation"`
        EnableDuplicateCheck bool         `mapstructure:"enable_duplicate_check" json:"enable_duplicate_check"`
        TempDirectory       string        `mapstructure:"temp_directory" json:"temp_directory"`
}

// SecurityConfig represents security configuration
type SecurityConfig struct {
        JWTSecret        string        `mapstructure:"jwt_secret" json:"jwt_secret" validate:"required"`
        JWTExpiration    time.Duration `mapstructure:"jwt_expiration" json:"jwt_expiration"`
        RateLimit        int           `mapstructure:"rate_limit" json:"rate_limit"`
        RateLimitWindow  time.Duration `mapstructure:"rate_limit_window" json:"rate_limit_window"`
        EnableAPIKey     bool          `mapstructure:"enable_api_key" json:"enable_api_key"`
        APIKeyHeader     string        `mapstructure:"api_key_header" json:"api_key_header"`
        EnableEncryption bool          `mapstructure:"enable_encryption" json:"enable_encryption"`
        EncryptionKey    string        `mapstructure:"encryption_key" json:"encryption_key"`
}

// Load loads configuration from environment variables and config files
func Load() (*Config, error) <span class="cov0" title="0">{
        v := viper.New()
        
        // Set default values
        setDefaults(v)
        
        // Configure viper
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(".")
        v.AddConfigPath("./configs")
        v.AddConfigPath("/etc/hotel-reviews")
        v.AddConfigPath("$HOME/.hotel-reviews")
        
        // Enable environment variable support
        v.SetEnvPrefix("HOTEL_REVIEWS")
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        
        // Read configuration file
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
                // Config file not found, continue with environment variables and defaults
        }
        
        // Unmarshal configuration
        <span class="cov0" title="0">var config Config
        if err := v.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>
        
        // Validate configuration
        <span class="cov0" title="0">if err := validate(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;config, nil</span>
}

// setDefaults sets default configuration values
func setDefaults(v *viper.Viper) <span class="cov0" title="0">{
        // Database defaults
        v.SetDefault("database.host", "localhost")
        v.SetDefault("database.port", 5432)
        v.SetDefault("database.user", "postgres")
        v.SetDefault("database.password", "postgres")
        v.SetDefault("database.name", "hotel_reviews")
        v.SetDefault("database.ssl_mode", "disable")
        v.SetDefault("database.max_open_conns", 25)
        v.SetDefault("database.max_idle_conns", 25)
        v.SetDefault("database.conn_max_lifetime", "5m")
        v.SetDefault("database.conn_max_idle_time", "5m")
        v.SetDefault("database.timezone", "UTC")
        v.SetDefault("database.log_level", "warn")
        
        // S3 defaults
        v.SetDefault("s3.region", "us-east-1")
        v.SetDefault("s3.use_ssl", true)
        v.SetDefault("s3.force_path_style", false)
        v.SetDefault("s3.timeout", "30s")
        v.SetDefault("s3.retry_count", 3)
        v.SetDefault("s3.retry_delay", "1s")
        v.SetDefault("s3.upload_part_size", 5*1024*1024)   // 5MB
        v.SetDefault("s3.download_part_size", 5*1024*1024) // 5MB
        
        // Server defaults
        v.SetDefault("server.host", "0.0.0.0")
        v.SetDefault("server.port", 8080)
        v.SetDefault("server.read_timeout", "10s")
        v.SetDefault("server.write_timeout", "10s")
        v.SetDefault("server.idle_timeout", "60s")
        v.SetDefault("server.shutdown_timeout", "30s")
        v.SetDefault("server.max_header_bytes", 1&lt;&lt;20) // 1MB
        v.SetDefault("server.enable_cors", true)
        v.SetDefault("server.enable_gzip", true)
        v.SetDefault("server.enable_metrics", true)
        v.SetDefault("server.enable_pprof", false)
        v.SetDefault("server.trusted_proxies", []string{})
        
        // Log defaults
        v.SetDefault("log.level", "info")
        v.SetDefault("log.format", "json")
        v.SetDefault("log.output", "stdout")
        v.SetDefault("log.max_size", 100)
        v.SetDefault("log.max_backups", 3)
        v.SetDefault("log.max_age", 28)
        v.SetDefault("log.compress", true)
        v.SetDefault("log.enable_caller", true)
        v.SetDefault("log.enable_stacktrace", false)
        
        // Cache defaults
        v.SetDefault("cache.type", "redis")
        v.SetDefault("cache.host", "localhost")
        v.SetDefault("cache.port", 6379)
        v.SetDefault("cache.database", 0)
        v.SetDefault("cache.pool_size", 10)
        v.SetDefault("cache.min_idle_conns", 5)
        v.SetDefault("cache.dial_timeout", "5s")
        v.SetDefault("cache.read_timeout", "3s")
        v.SetDefault("cache.write_timeout", "3s")
        v.SetDefault("cache.ttl", "1h")
        v.SetDefault("cache.max_memory", 100*1024*1024) // 100MB
        
        // Metrics defaults
        v.SetDefault("metrics.enabled", true)
        v.SetDefault("metrics.type", "prometheus")
        v.SetDefault("metrics.host", "localhost")
        v.SetDefault("metrics.port", 9090)
        v.SetDefault("metrics.path", "/metrics")
        v.SetDefault("metrics.namespace", "hotel_reviews")
        v.SetDefault("metrics.service_name", "hotel-reviews-api")
        v.SetDefault("metrics.environment", "development")
        v.SetDefault("metrics.version", "1.0.0")
        
        // Notification defaults
        v.SetDefault("notification.email.enabled", false)
        v.SetDefault("notification.email.port", 587)
        v.SetDefault("notification.email.use_tls", true)
        v.SetDefault("notification.slack.enabled", false)
        v.SetDefault("notification.slack.username", "Hotel Reviews Bot")
        v.SetDefault("notification.slack.icon_emoji", ":hotel:")
        
        // Processing defaults
        v.SetDefault("processing.batch_size", 1000)
        v.SetDefault("processing.worker_count", 4)
        v.SetDefault("processing.max_file_size", 100*1024*1024) // 100MB
        v.SetDefault("processing.processing_timeout", "30m")
        v.SetDefault("processing.max_retries", 3)
        v.SetDefault("processing.retry_delay", "5s")
        v.SetDefault("processing.enable_validation", true)
        v.SetDefault("processing.enable_duplicate_check", true)
        v.SetDefault("processing.temp_directory", "/tmp/hotel-reviews")
        
        // Security defaults
        v.SetDefault("security.jwt_expiration", "24h")
        v.SetDefault("security.rate_limit", 1000)
        v.SetDefault("security.rate_limit_window", "1h")
        v.SetDefault("security.enable_api_key", false)
        v.SetDefault("security.api_key_header", "X-API-Key")
        v.SetDefault("security.enable_encryption", false)
}</span>

// validate validates the configuration
func validate(config *Config) error <span class="cov0" title="0">{
        // Validate database configuration
        if config.Database.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database host is required")
        }</span>
        <span class="cov0" title="0">if config.Database.Port &lt;= 0 || config.Database.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("database port must be between 1 and 65535")
        }</span>
        <span class="cov0" title="0">if config.Database.User == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database user is required")
        }</span>
        <span class="cov0" title="0">if config.Database.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database password is required")
        }</span>
        <span class="cov0" title="0">if config.Database.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>
        
        // Validate S3 configuration
        <span class="cov0" title="0">if config.S3.Region == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 region is required")
        }</span>
        <span class="cov0" title="0">if config.S3.AccessKeyID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 access key ID is required")
        }</span>
        <span class="cov0" title="0">if config.S3.SecretAccessKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 secret access key is required")
        }</span>
        <span class="cov0" title="0">if config.S3.Bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 bucket is required")
        }</span>
        
        // Validate server configuration
        <span class="cov0" title="0">if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("server port must be between 1 and 65535")
        }</span>
        
        // Validate log configuration
        <span class="cov0" title="0">validLogLevels := []string{"debug", "info", "warn", "error"}
        if !contains(validLogLevels, config.Log.Level) </span><span class="cov0" title="0">{
                return fmt.Errorf("log level must be one of: %s", strings.Join(validLogLevels, ", "))
        }</span>
        
        <span class="cov0" title="0">validLogFormats := []string{"json", "text"}
        if !contains(validLogFormats, config.Log.Format) </span><span class="cov0" title="0">{
                return fmt.Errorf("log format must be one of: %s", strings.Join(validLogFormats, ", "))
        }</span>
        
        <span class="cov0" title="0">validLogOutputs := []string{"stdout", "stderr", "file"}
        if !contains(validLogOutputs, config.Log.Output) </span><span class="cov0" title="0">{
                return fmt.Errorf("log output must be one of: %s", strings.Join(validLogOutputs, ", "))
        }</span>
        
        <span class="cov0" title="0">if config.Log.Output == "file" &amp;&amp; config.Log.FilePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("log file path is required when output is file")
        }</span>
        
        // Validate cache configuration
        <span class="cov0" title="0">validCacheTypes := []string{"redis", "memory"}
        if !contains(validCacheTypes, config.Cache.Type) </span><span class="cov0" title="0">{
                return fmt.Errorf("cache type must be one of: %s", strings.Join(validCacheTypes, ", "))
        }</span>
        
        // Validate security configuration
        <span class="cov0" title="0">if config.Security.JWTSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret is required")
        }</span>
        
        // Validate TLS configuration
        <span class="cov0" title="0">if config.Server.TLSCertFile != "" &amp;&amp; config.Server.TLSKeyFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("TLS key file is required when TLS cert file is provided")
        }</span>
        <span class="cov0" title="0">if config.Server.TLSKeyFile != "" &amp;&amp; config.Server.TLSCertFile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("TLS cert file is required when TLS key file is provided")
        }</span>
        
        // Validate file paths exist
        <span class="cov0" title="0">if config.Server.TLSCertFile != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(config.Server.TLSCertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS cert file does not exist: %s", config.Server.TLSCertFile)
                }</span>
        }
        <span class="cov0" title="0">if config.Server.TLSKeyFile != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(config.Server.TLSKeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS key file does not exist: %s", config.Server.TLSKeyFile)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetDatabaseURL returns the database connection URL
func (c *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s&amp;timezone=%s",
                c.Database.User,
                c.Database.Password,
                c.Database.Host,
                c.Database.Port,
                c.Database.Name,
                c.Database.SSLMode,
                c.Database.TimeZone,
        )
}</span>

// GetServerAddress returns the server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetCacheAddress returns the cache address
func (c *Config) GetCacheAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Cache.Host, c.Cache.Port)
}</span>

// IsProduction returns true if the environment is production
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        return c.Metrics.Environment == "production"
}</span>

// IsDevelopment returns true if the environment is development
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        return c.Metrics.Environment == "development"
}</span>

// IsTestEnvironment returns true if the environment is test
func (c *Config) IsTestEnvironment() bool <span class="cov0" title="0">{
        return c.Metrics.Environment == "test"
}</pre>
		
		<pre class="file" id="file9" style="display: none">package logger

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/google/uuid"
        "gopkg.in/natefinch/lumberjack.v2"
)

// ContextKey represents a key for context values
type ContextKey string

const (
        // ContextKeyRequestID is the key for request ID in context
        ContextKeyRequestID ContextKey = "request_id"
        // ContextKeyUserID is the key for user ID in context
        ContextKeyUserID ContextKey = "user_id"
        // ContextKeyCorrelationID is the key for correlation ID in context
        ContextKeyCorrelationID ContextKey = "correlation_id"
        // ContextKeyTraceID is the key for trace ID in context
        ContextKeyTraceID ContextKey = "trace_id"
        // ContextKeySpanID is the key for span ID in context
        ContextKeySpanID ContextKey = "span_id"
)

// Config represents logger configuration
type Config struct {
        Level           string `json:"level"`
        Format          string `json:"format"`
        Output          string `json:"output"`
        FilePath        string `json:"file_path"`
        MaxSize         int    `json:"max_size"`
        MaxBackups      int    `json:"max_backups"`
        MaxAge          int    `json:"max_age"`
        Compress        bool   `json:"compress"`
        EnableCaller    bool   `json:"enable_caller"`
        EnableStacktrace bool  `json:"enable_stacktrace"`
}

// Logger wraps slog.Logger with additional functionality
type Logger struct {
        *slog.Logger
        config *Config
}

// New creates a new logger instance
func New(config *Config) (*Logger, error) <span class="cov0" title="0">{
        // Parse log level
        level, err := parseLogLevel(config.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create writer based on output configuration
        <span class="cov0" title="0">writer, err := createWriter(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create handler options
        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: config.EnableCaller,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        // Customize source attribute
                        if a.Key == slog.SourceKey </span><span class="cov0" title="0">{
                                if src, ok := a.Value.Any().(*slog.Source); ok </span><span class="cov0" title="0">{
                                        // Shorten file path
                                        src.File = shortenFilePath(src.File)
                                        return slog.Attr{Key: a.Key, Value: slog.AnyValue(src)}
                                }</span>
                        }
                        
                        // Customize time format
                        <span class="cov0" title="0">if a.Key == slog.TimeKey </span><span class="cov0" title="0">{
                                return slog.Attr{Key: a.Key, Value: slog.StringValue(a.Value.Time().Format(time.RFC3339Nano))}
                        }</span>
                        
                        <span class="cov0" title="0">return a</span>
                },
        }

        // Create handler based on format
        <span class="cov0" title="0">var handler slog.Handler
        switch config.Format </span>{
        case "json":<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        case "text":<span class="cov0" title="0">
                handler = slog.NewTextHandler(writer, opts)</span>
        default:<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        }

        // Create logger
        <span class="cov0" title="0">logger := &amp;Logger{
                Logger: slog.New(handler),
                config: config,
        }

        return logger, nil</span>
}

// NewDefault creates a logger with default configuration
func NewDefault() *Logger <span class="cov0" title="0">{
        config := &amp;Config{
                Level:           "info",
                Format:          "json",
                Output:          "stdout",
                EnableCaller:    true,
                EnableStacktrace: false,
        }

        logger, err := New(config)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to basic logger
                return &amp;Logger{
                        Logger: slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                                Level:     slog.LevelInfo,
                                AddSource: true,
                        })),
                        config: config,
                }
        }</span>

        <span class="cov0" title="0">return logger</span>
}

// Context-aware logging methods
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov0" title="0">{
        attrs := l.extractContextAttributes(ctx)
        if len(attrs) == 0 </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

func (l *Logger) extractContextAttributes(ctx context.Context) []any <span class="cov0" title="0">{
        var attrs []any

        if requestID := ctx.Value(ContextKeyRequestID); requestID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, "request_id", requestID)
        }</span>

        <span class="cov0" title="0">if userID := ctx.Value(ContextKeyUserID); userID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, "user_id", userID)
        }</span>

        <span class="cov0" title="0">if correlationID := ctx.Value(ContextKeyCorrelationID); correlationID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, "correlation_id", correlationID)
        }</span>

        <span class="cov0" title="0">if traceID := ctx.Value(ContextKeyTraceID); traceID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, "trace_id", traceID)
        }</span>

        <span class="cov0" title="0">if spanID := ctx.Value(ContextKeySpanID); spanID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, "span_id", spanID)
        }</span>

        <span class="cov0" title="0">return attrs</span>
}

// Enhanced logging methods with context support
func (l *Logger) DebugContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        l.WithContext(ctx).Debug(msg, args...)
}</span>

func (l *Logger) InfoContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        l.WithContext(ctx).Info(msg, args...)
}</span>

func (l *Logger) WarnContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        l.WithContext(ctx).Warn(msg, args...)
}</span>

func (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        if l.config.EnableStacktrace </span><span class="cov0" title="0">{
                args = append(args, "stacktrace", getStackTrace())
        }</span>
        <span class="cov0" title="0">l.WithContext(ctx).Error(msg, args...)</span>
}

// Structured logging methods
func (l *Logger) WithFields(fields map[string]any) *Logger <span class="cov0" title="0">{
        attrs := make([]any, 0, len(fields)*2)
        for k, v := range fields </span><span class="cov0" title="0">{
                attrs = append(attrs, k, v)
        }</span>
        <span class="cov0" title="0">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

func (l *Logger) WithField(key string, value any) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                Logger: l.Logger.With(key, value),
                config: l.config,
        }
}</span>

func (l *Logger) WithError(err error) *Logger <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return l
        }</span>
        
        <span class="cov0" title="0">attrs := []any{"error", err.Error()}
        if l.config.EnableStacktrace </span><span class="cov0" title="0">{
                attrs = append(attrs, "stacktrace", getStackTrace())
        }</span>
        
        <span class="cov0" title="0">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

// Business domain specific logging methods
func (l *Logger) LogRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration, size int64) <span class="cov0" title="0">{
        l.WithContext(ctx).Info("HTTP request completed",
                "method", method,
                "path", path,
                "status_code", statusCode,
                "duration_ms", duration.Milliseconds(),
                "response_size", size,
        )
}</span>

func (l *Logger) LogDatabaseQuery(ctx context.Context, query string, duration time.Duration, rowsAffected int64) <span class="cov0" title="0">{
        l.WithContext(ctx).Debug("Database query executed",
                "query", query,
                "duration_ms", duration.Milliseconds(),
                "rows_affected", rowsAffected,
        )
}</span>

func (l *Logger) LogFileProcessing(ctx context.Context, filename string, recordsProcessed int, duration time.Duration) <span class="cov0" title="0">{
        l.WithContext(ctx).Info("File processing completed",
                "filename", filename,
                "records_processed", recordsProcessed,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogCacheOperation(ctx context.Context, operation, key string, hit bool, duration time.Duration) <span class="cov0" title="0">{
        l.WithContext(ctx).Debug("Cache operation",
                "operation", operation,
                "key", key,
                "hit", hit,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogS3Operation(ctx context.Context, operation, bucket, key string, size int64, duration time.Duration) <span class="cov0" title="0">{
        l.WithContext(ctx).Debug("S3 operation",
                "operation", operation,
                "bucket", bucket,
                "key", key,
                "size", size,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogMetric(ctx context.Context, name string, value float64, labels map[string]string) <span class="cov0" title="0">{
        attrs := []any{
                "metric_name", name,
                "metric_value", value,
        }
        
        for k, v := range labels </span><span class="cov0" title="0">{
                attrs = append(attrs, "label_"+k, v)
        }</span>
        
        <span class="cov0" title="0">l.WithContext(ctx).Debug("Metric recorded", attrs...)</span>
}

func (l *Logger) LogBusinessEvent(ctx context.Context, event string, entityType string, entityID string, details map[string]any) <span class="cov0" title="0">{
        attrs := []any{
                "event", event,
                "entity_type", entityType,
                "entity_id", entityID,
        }
        
        for k, v := range details </span><span class="cov0" title="0">{
                attrs = append(attrs, k, v)
        }</span>
        
        <span class="cov0" title="0">l.WithContext(ctx).Info("Business event", attrs...)</span>
}

// Error handling methods
func (l *Logger) LogError(ctx context.Context, err error, msg string, args ...any) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">attrs := append(args, "error", err.Error())
        if l.config.EnableStacktrace </span><span class="cov0" title="0">{
                attrs = append(attrs, "stacktrace", getStackTrace())
        }</span>
        
        <span class="cov0" title="0">l.WithContext(ctx).Error(msg, attrs...)</span>
}

func (l *Logger) LogPanic(ctx context.Context, recovered any, msg string, args ...any) <span class="cov0" title="0">{
        attrs := append(args, "panic", recovered, "stacktrace", getStackTrace())
        l.WithContext(ctx).Error(msg, attrs...)
}</span>

// Utility methods
func (l *Logger) IsDebugEnabled() bool <span class="cov0" title="0">{
        return l.Logger.Enabled(context.Background(), slog.LevelDebug)
}</span>

func (l *Logger) IsInfoEnabled() bool <span class="cov0" title="0">{
        return l.Logger.Enabled(context.Background(), slog.LevelInfo)
}</span>

func (l *Logger) IsWarnEnabled() bool <span class="cov0" title="0">{
        return l.Logger.Enabled(context.Background(), slog.LevelWarn)
}</span>

func (l *Logger) IsErrorEnabled() bool <span class="cov0" title="0">{
        return l.Logger.Enabled(context.Background(), slog.LevelError)
}</span>

// Helper functions
func parseLogLevel(level string) (slog.Level, error) <span class="cov0" title="0">{
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                return slog.LevelDebug, nil</span>
        case "info":<span class="cov0" title="0">
                return slog.LevelInfo, nil</span>
        case "warn":<span class="cov0" title="0">
                return slog.LevelWarn, nil</span>
        case "error":<span class="cov0" title="0">
                return slog.LevelError, nil</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo, nil</span>
        }
}

func createWriter(config *Config) (io.Writer, error) <span class="cov0" title="0">{
        switch config.Output </span>{
        case "stdout":<span class="cov0" title="0">
                return os.Stdout, nil</span>
        case "stderr":<span class="cov0" title="0">
                return os.Stderr, nil</span>
        case "file":<span class="cov0" title="0">
                if config.FilePath == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file path is required for file output")
                }</span>
                
                <span class="cov0" title="0">return &amp;lumberjack.Logger{
                        Filename:   config.FilePath,
                        MaxSize:    config.MaxSize,
                        MaxBackups: config.MaxBackups,
                        MaxAge:     config.MaxAge,
                        Compress:   config.Compress,
                }, nil</span>
        default:<span class="cov0" title="0">
                return os.Stdout, nil</span>
        }
}

func shortenFilePath(path string) string <span class="cov0" title="0">{
        // Extract just the filename and parent directory
        parts := strings.Split(path, "/")
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                return strings.Join(parts[len(parts)-2:], "/")
        }</span>
        <span class="cov0" title="0">return path</span>
}

func getStackTrace() string <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        return string(buf[:n])
}</span>

// Context helpers
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyRequestID, requestID)
}</span>

func WithUserID(ctx context.Context, userID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyUserID, userID)
}</span>

func WithCorrelationID(ctx context.Context, correlationID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyCorrelationID, correlationID)
}</span>

func WithTraceID(ctx context.Context, traceID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyTraceID, traceID)
}</span>

func WithSpanID(ctx context.Context, spanID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeySpanID, spanID)
}</span>

func GetRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if id := ctx.Value(ContextKeyRequestID); id != nil </span><span class="cov0" title="0">{
                return id.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func GetUserID(ctx context.Context) string <span class="cov0" title="0">{
        if id := ctx.Value(ContextKeyUserID); id != nil </span><span class="cov0" title="0">{
                return id.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func GetCorrelationID(ctx context.Context) string <span class="cov0" title="0">{
        if id := ctx.Value(ContextKeyCorrelationID); id != nil </span><span class="cov0" title="0">{
                return id.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func GetTraceID(ctx context.Context) string <span class="cov0" title="0">{
        if id := ctx.Value(ContextKeyTraceID); id != nil </span><span class="cov0" title="0">{
                return id.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func GetSpanID(ctx context.Context) string <span class="cov0" title="0">{
        if id := ctx.Value(ContextKeySpanID); id != nil </span><span class="cov0" title="0">{
                return id.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GenerateRequestID generates a new request ID
func GenerateRequestID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

// GenerateCorrelationID generates a new correlation ID
func GenerateCorrelationID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

// Middleware for HTTP requests
func RequestLoggerMiddleware(logger *Logger) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        
                        // Generate request ID if not present
                        requestID := r.Header.Get("X-Request-ID")
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>
                        
                        // Generate correlation ID if not present
                        <span class="cov0" title="0">correlationID := r.Header.Get("X-Correlation-ID")
                        if correlationID == "" </span><span class="cov0" title="0">{
                                correlationID = GenerateCorrelationID()
                        }</span>
                        
                        // Add IDs to context
                        <span class="cov0" title="0">ctx := WithRequestID(r.Context(), requestID)
                        ctx = WithCorrelationID(ctx, correlationID)
                        
                        // Add trace information if available
                        if traceID := r.Header.Get("X-Trace-ID"); traceID != "" </span><span class="cov0" title="0">{
                                ctx = WithTraceID(ctx, traceID)
                        }</span>
                        <span class="cov0" title="0">if spanID := r.Header.Get("X-Span-ID"); spanID != "" </span><span class="cov0" title="0">{
                                ctx = WithSpanID(ctx, spanID)
                        }</span>
                        
                        // Update request with new context
                        <span class="cov0" title="0">r = r.WithContext(ctx)
                        
                        // Set response headers
                        w.Header().Set("X-Request-ID", requestID)
                        w.Header().Set("X-Correlation-ID", correlationID)
                        
                        // Wrap response writer to capture status code and size
                        ww := &amp;responseWriter{ResponseWriter: w, statusCode: 200}
                        
                        // Log request start
                        logger.InfoContext(ctx, "HTTP request started",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.UserAgent(),
                        )
                        
                        // Process request
                        next.ServeHTTP(ww, r)
                        
                        // Log request completion
                        duration := time.Since(start)
                        logger.LogRequest(ctx, r.Method, r.URL.Path, ww.statusCode, duration, ww.size)</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture status code and response size
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int64
}

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        n, err := w.ResponseWriter.Write(data)
        w.size += int64(n)
        return n, err
}</span>

// Recovery middleware for panic handling
func RecoveryMiddleware(logger *Logger) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if recovered := recover(); recovered != nil </span><span class="cov0" title="0">{
                                        logger.LogPanic(r.Context(), recovered, "HTTP request panic")
                                        
                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusInternalServerError)
                                        w.Write([]byte(`{"error": "Internal server error"}`))
                                }</span>
                        }()
                        
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// Global logger instance
var defaultLogger *Logger

func init() <span class="cov0" title="0">{
        defaultLogger = NewDefault()
}</span>

// Global logging functions
func Debug(msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.Debug(msg, args...)
}</span>

func Info(msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.Info(msg, args...)
}</span>

func Warn(msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.Warn(msg, args...)
}</span>

func Error(msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.Error(msg, args...)
}</span>

func DebugContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.DebugContext(ctx, msg, args...)
}</span>

func InfoContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.InfoContext(ctx, msg, args...)
}</span>

func WarnContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.WarnContext(ctx, msg, args...)
}</span>

func ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        defaultLogger.ErrorContext(ctx, msg, args...)
}</span>

// SetDefault sets the default logger
func SetDefault(logger *Logger) <span class="cov0" title="0">{
        defaultLogger = logger
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
