
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gkbiswas/hotel-reviews-microservice/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/gkbiswas/hotel-reviews-microservice/cmd/demo-config-watcher/main.go (0.0%)</option>
				
				<option value="file2">github.com/gkbiswas/hotel-reviews-microservice/cmd/server-with-config-watcher/main.go (0.0%)</option>
				
				<option value="file3">github.com/gkbiswas/hotel-reviews-microservice/internal/application/auth_handlers.go (31.9%)</option>
				
				<option value="file4">github.com/gkbiswas/hotel-reviews-microservice/internal/application/auth_middleware.go (67.7%)</option>
				
				<option value="file5">github.com/gkbiswas/hotel-reviews-microservice/internal/application/cache_service.go (0.0%)</option>
				
				<option value="file6">github.com/gkbiswas/hotel-reviews-microservice/internal/application/event_handlers.go (0.5%)</option>
				
				<option value="file7">github.com/gkbiswas/hotel-reviews-microservice/internal/application/hotel_handlers.go (29.6%)</option>
				
				<option value="file8">github.com/gkbiswas/hotel-reviews-microservice/internal/application/processor.go (0.0%)</option>
				
				<option value="file9">github.com/gkbiswas/hotel-reviews-microservice/internal/application/provider_handlers.go (44.0%)</option>
				
				<option value="file10">github.com/gkbiswas/hotel-reviews-microservice/internal/application/simplified_integrated_handlers.go (0.0%)</option>
				
				<option value="file11">github.com/gkbiswas/hotel-reviews-microservice/internal/config/app_config.go (35.0%)</option>
				
				<option value="file12">github.com/gkbiswas/hotel-reviews-microservice/internal/config/watcher_integration.go (45.0%)</option>
				
				<option value="file13">github.com/gkbiswas/hotel-reviews-microservice/internal/domain/entities.go (0.0%)</option>
				
				<option value="file14">github.com/gkbiswas/hotel-reviews-microservice/internal/domain/events.go (97.8%)</option>
				
				<option value="file15">github.com/gkbiswas/hotel-reviews-microservice/internal/domain/review_service_wrapper.go (0.0%)</option>
				
				<option value="file16">github.com/gkbiswas/hotel-reviews-microservice/internal/domain/services.go (81.8%)</option>
				
				<option value="file17">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/alert_channels.go (0.0%)</option>
				
				<option value="file18">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/async_processor.go (24.5%)</option>
				
				<option value="file19">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/auth.go (2.2%)</option>
				
				<option value="file20">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/cache_service.go (0.0%)</option>
				
				<option value="file21">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/circuit_breaker.go (92.1%)</option>
				
				<option value="file22">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/circuit_breaker_integration.go (89.6%)</option>
				
				<option value="file23">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/config_watcher.go (83.8%)</option>
				
				<option value="file24">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/database.go (57.8%)</option>
				
				<option value="file25">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/database_pool.go (0.0%)</option>
				
				<option value="file26">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/db_optimizer.go (55.2%)</option>
				
				<option value="file27">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_aggregator.go (51.5%)</option>
				
				<option value="file28">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_alerter.go (50.0%)</option>
				
				<option value="file29">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_handler.go (79.2%)</option>
				
				<option value="file30">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_health_checker.go (40.3%)</option>
				
				<option value="file31">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_metrics.go (54.8%)</option>
				
				<option value="file32">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/error_rate_limiter.go (44.7%)</option>
				
				<option value="file33">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/health_checks.go (0.0%)</option>
				
				<option value="file34">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/jsonlines.go (17.7%)</option>
				
				<option value="file35">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/kafka.go (19.6%)</option>
				
				<option value="file36">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/middleware/auth_middleware.go (0.0%)</option>
				
				<option value="file37">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/middleware/base_middleware.go (100.0%)</option>
				
				<option value="file38">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/middleware/circuit_breaker_middleware.go (0.0%)</option>
				
				<option value="file39">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/middleware/error_handler_middleware.go (0.0%)</option>
				
				<option value="file40">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/migrator.go (0.0%)</option>
				
				<option value="file41">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/protected_repository.go (0.0%)</option>
				
				<option value="file42">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/rate_limiter.go (89.8%)</option>
				
				<option value="file43">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/redis.go (11.0%)</option>
				
				<option value="file44">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/redis_cache_service.go (2.4%)</option>
				
				<option value="file45">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/repository.go (23.9%)</option>
				
				<option value="file46">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/retry.go (80.1%)</option>
				
				<option value="file47">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/s3_client_wrapper.go (0.0%)</option>
				
				<option value="file48">github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure/s3client.go (10.8%)</option>
				
				<option value="file49">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/business_metrics.go (19.1%)</option>
				
				<option value="file50">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/health.go (82.8%)</option>
				
				<option value="file51">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/logger.go (0.0%)</option>
				
				<option value="file52">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/metrics.go (97.7%)</option>
				
				<option value="file53">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/middleware.go (0.0%)</option>
				
				<option value="file54">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/monitoring.go (85.7%)</option>
				
				<option value="file55">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/sli_slo.go (52.9%)</option>
				
				<option value="file56">github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring/tracing.go (82.0%)</option>
				
				<option value="file57">github.com/gkbiswas/hotel-reviews-microservice/internal/server/shutdown.go (73.2%)</option>
				
				<option value="file58">github.com/gkbiswas/hotel-reviews-microservice/internal/server/wrappers.go (0.0%)</option>
				
				<option value="file59">github.com/gkbiswas/hotel-reviews-microservice/pkg/config/config.go (92.7%)</option>
				
				<option value="file60">github.com/gkbiswas/hotel-reviews-microservice/pkg/logger/logger.go (98.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/redis/go-redis/v9"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/application"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/server"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        var (
                mode        = flag.String("mode", "production", "Application mode (development/production)")
                logLevel    = flag.String("log-level", "info", "Log level (debug/info/warn/error)")
                host        = flag.String("host", "", "Server host (overrides config)")
                port        = flag.Int("port", 0, "Server port (overrides config)")
                createAdmin = flag.Bool("create-admin", false, "Create admin user on startup")
        )
        flag.Parse()

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Apply command line overrides
        <span class="cov0" title="0">if *host != "" </span><span class="cov0" title="0">{
                cfg.Server.Host = *host
        }</span>
        <span class="cov0" title="0">if *port &gt; 0 </span><span class="cov0" title="0">{
                cfg.Server.Port = *port
        }</span>
        <span class="cov0" title="0">if *logLevel != "" </span><span class="cov0" title="0">{
                cfg.Log.Level = *logLevel
        }</span>

        // Initialize structured logger
        <span class="cov0" title="0">loggerConfig := &amp;logger.Config{
                Level:  cfg.Log.Level,
                Format: cfg.Log.Format,
                Output: cfg.Log.Output,
        }
        appLogger, err := logger.New(loggerConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize logger: %v", err)
        }</span>

        // Create slog logger for components that need it
        <span class="cov0" title="0">slogLogger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))

        // Initialize graceful shutdown manager
        shutdownConfig := server.DefaultShutdownConfig()
        shutdownConfig.GracefulTimeout = time.Duration(cfg.Server.ShutdownTimeout)

        loggerAdapter := &amp;LoggerAdapter{Logger: appLogger}
        shutdownManager := server.NewShutdownManager(loggerAdapter, shutdownConfig)

        // Initialize database
        database, err := infrastructure.NewDatabase(&amp;cfg.Database, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize database: %v", err)
        }</span>

        // Initialize S3 client
        <span class="cov0" title="0">s3Client, err := infrastructure.NewS3Client(&amp;cfg.S3, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize S3 client: %v", err)
        }</span>

        // Initialize Redis client for caching
        <span class="cov0" title="0">redisClient := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.GetCacheAddress(),
                Password: cfg.Cache.Password,
                DB:       cfg.Cache.Database,
        })

        // Test Redis connection
        ctx := context.Background()
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                appLogger.Warn("Redis connection failed, continuing without cache", "error", err)
                redisClient = nil
        }</span>

        // Initialize cache service
        <span class="cov0" title="0">var cacheService domain.CacheService
        if redisClient != nil </span><span class="cov0" title="0">{
                cacheService = infrastructure.NewRedisCacheService(redisClient, appLogger)
        }</span>

        // Initialize circuit breaker and retry manager
        <span class="cov0" title="0">cbConfig := infrastructure.DefaultCircuitBreakerConfig()
        cbConfig.Name = "api-circuit-breaker"
        circuitBreaker := infrastructure.NewCircuitBreaker(cbConfig, appLogger)

        retryConfig := infrastructure.DefaultRetryConfig()
        retryManager := infrastructure.NewRetryManager(retryConfig, circuitBreaker, appLogger)

        // Initialize repositories
        reviewRepo := infrastructure.NewReviewRepository(database, appLogger)

        // Initialize JSON processor
        jsonProcessor := infrastructure.NewJSONLinesProcessor(reviewRepo, appLogger)

        // Initialize auth repository
        authRepo := infrastructure.NewAuthRepository(database.DB, slogLogger, circuitBreaker, retryManager)

        // Initialize auth services
        jwtService := infrastructure.NewJWTService(cfg, slogLogger, circuitBreaker, retryManager)
        passwordService := infrastructure.NewPasswordService(slogLogger)
        rbacService := infrastructure.NewRBACService(authRepo, slogLogger, circuitBreaker, retryManager)
        apiKeyService := infrastructure.NewApiKeyService(authRepo, slogLogger, circuitBreaker, retryManager)
        rateLimitService := infrastructure.NewRateLimitService(authRepo, slogLogger, circuitBreaker, retryManager)
        auditService := infrastructure.NewAuditService(authRepo, slogLogger, circuitBreaker, retryManager)

        // Initialize authentication service
        authService := infrastructure.NewAuthenticationService(
                authRepo, jwtService, passwordService, rbacService,
                apiKeyService, rateLimitService, auditService,
                slogLogger, circuitBreaker, retryManager,
        )

        // Initialize error handler
        errorHandlerConfig := &amp;infrastructure.ErrorHandlerConfig{}
        errorHandler := infrastructure.NewErrorHandler(errorHandlerConfig, appLogger, circuitBreaker, retryConfig)

        // Initialize review service
        reviewService := domain.NewReviewService(
                reviewRepo,
                s3Client,
                jsonProcessor,
                nil, // notification service - not implemented
                cacheService,
                nil, // metrics service - not implemented
                nil, // event publisher - not implemented
                slogLogger,
        )

        // Initialize application handlers

        handlers := application.NewSimplifiedIntegratedHandlers(
                reviewService,
                authService,
                rbacService,
                nil, // circuit breaker integration - not configured
                retryManager,
                nil, // redis client - not configured
                nil, // kafka producer - not configured
                s3Client,
                errorHandler,
                nil, // processing engine - not configured
                appLogger,
        )

        // Initialize auth handlers
        authHandlers := application.NewAuthHandlers(authService, passwordService, slogLogger)

        // Initialize health checker
        healthChecker := &amp;HealthChecker{logger: loggerAdapter, checks: make(map[string]func(context.Context) error)}
        healthChecker.AddCheck("database", func(ctx context.Context) error </span><span class="cov0" title="0">{
                return nil // simplified for now
        }</span>)
        <span class="cov0" title="0">if redisClient != nil </span><span class="cov0" title="0">{
                healthChecker.AddCheck("redis", func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return redisClient.Ping(ctx).Err()
                }</span>)
        }
        <span class="cov0" title="0">healthChecker.AddCheck("s3", func(ctx context.Context) error </span><span class="cov0" title="0">{
                // Test S3 connection by checking if bucket exists
                _, err := s3Client.BucketExists(ctx, cfg.S3.Bucket)
                return err
        }</span>)

        // Initialize Gin router
        <span class="cov0" title="0">gin.SetMode(gin.ReleaseMode)
        if *mode == "development" </span><span class="cov0" title="0">{
                gin.SetMode(gin.DebugMode)
        }</span>

        <span class="cov0" title="0">router := gin.New()

        // Add essential middleware
        router.Use(gin.Recovery())
        router.Use(requestIDMiddleware())
        router.Use(loggingMiddleware(appLogger))
        router.Use(corsMiddleware())

        // Public routes
        router.GET("/health", gin.HandlerFunc(healthChecker.Handler))
        router.GET("/metrics", gin.WrapH(promhttp.Handler()))

        // API routes
        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Authentication routes
                auth := api.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/register", gin.WrapF(authHandlers.Register))
                        auth.POST("/login", gin.WrapF(authHandlers.Login))
                        auth.POST("/refresh", gin.WrapF(authHandlers.RefreshToken))
                        auth.POST("/logout", gin.WrapF(authHandlers.Logout))
                }</span>

                // Review routes
                <span class="cov0" title="0">reviews := api.Group("/reviews")
                </span><span class="cov0" title="0">{
                        reviews.GET("", handlers.ListReviews)
                        reviews.GET("/:id", handlers.GetReview)
                        reviews.POST("", handlers.CreateReview)
                        reviews.PUT("/:id", handlers.UpdateReview)
                        reviews.DELETE("/:id", handlers.DeleteReview)
                        // Bulk operations not implemented in simplified handlers
                }</span>

                // Hotel routes (placeholder - not implemented in simplified handlers)
                <span class="cov0" title="0">hotels := api.Group("/hotels")
                </span><span class="cov0" title="0">{
                        hotels.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Hotel endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">hotels.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Hotel endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">hotels.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Hotel endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">hotels.PUT("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Hotel endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">hotels.DELETE("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Hotel endpoints not implemented"})
                        }</span>)
                }

                // Provider routes (placeholder - not implemented in simplified handlers)
                <span class="cov0" title="0">providers := api.Group("/providers")
                </span><span class="cov0" title="0">{
                        providers.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Provider endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">providers.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Provider endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">providers.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Provider endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">providers.PUT("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Provider endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">providers.DELETE("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "Provider endpoints not implemented"})
                        }</span>)
                }

                // File processing routes (placeholder - not implemented in simplified handlers)
                <span class="cov0" title="0">processing := api.Group("/processing")
                </span><span class="cov0" title="0">{
                        processing.POST("/upload", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "File processing endpoints not implemented"})
                        }</span>)
                        <span class="cov0" title="0">processing.GET("/status/:id", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotImplemented, gin.H{"error": "File processing endpoints not implemented"})
                        }</span>)
                }

                // User management routes
                <span class="cov0" title="0">users := api.Group("/users")
                </span><span class="cov0" title="0">{
                        users.GET("/me", gin.WrapF(authHandlers.GetProfile))
                        users.PUT("/me", gin.WrapF(authHandlers.UpdateProfile))
                        // Delete account not implemented in auth handlers
                }</span>

                // Admin routes
                <span class="cov0" title="0">admin := api.Group("/admin")
                </span><span class="cov0" title="0">{
                        admin.GET("/users", gin.WrapF(authHandlers.ListUsers))
                        admin.PUT("/users/:id/role", gin.WrapF(authHandlers.AssignRole))
                        admin.GET("/users/:id", gin.WrapF(authHandlers.GetUser))
                        admin.DELETE("/users/:id", gin.WrapF(authHandlers.DeleteUser))
                        admin.GET("/api-keys", gin.WrapF(authHandlers.ListApiKeys))
                        admin.POST("/api-keys", gin.WrapF(authHandlers.CreateApiKey))
                        admin.DELETE("/api-keys/:id", gin.WrapF(authHandlers.DeleteApiKey))
                }</span>
        }

        // Create HTTP server
        <span class="cov0" title="0">httpServer := &amp;http.Server{
                Addr:           fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:        router,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                IdleTimeout:    cfg.Server.IdleTimeout,
                MaxHeaderBytes: cfg.Server.MaxHeaderBytes,
        }

        // Register HTTP server for graceful shutdown
        shutdownManager.RegisterResource(httpServer)

        // Create admin user if requested
        if *createAdmin </span><span class="cov0" title="0">{
                if err := createAdminUser(authService, slogLogger); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to create admin user", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        appLogger.Info("Admin user created successfully")
                }</span>
        }

        // Start server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                appLogger.Info("Starting HTTP server",
                        "addr", httpServer.Addr,
                        "mode", *mode,
                        "features", map[string]bool{
                                "authentication":  true,
                                "rbac":            true,
                                "circuit_breaker": true,
                                "retry_logic":     true,
                                "caching":         redisClient != nil,
                                "s3_storage":      true,
                                "health_checks":   true,
                                "metrics":         true,
                                "json_processing": true,
                        },
                )

                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("HTTP server failed: %v", err)
                }</span>
        }()

        // Log startup information
        <span class="cov0" title="0">appLogger.Info("Hotel Reviews Microservice started successfully",
                "version", cfg.Metrics.Version,
                "environment", cfg.Metrics.Environment,
                "service_name", cfg.Metrics.ServiceName,
        )

        // Wait for shutdown signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigChan

        appLogger.Info("Shutdown signal received, initiating graceful shutdown...")

        // Trigger graceful shutdown
        if err := shutdownManager.WaitForShutdown(); err != nil </span><span class="cov0" title="0">{
                appLogger.Error("Shutdown completed with errors", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">appLogger.Info("Graceful shutdown completed successfully")</span>
}

// createAdminUser creates an initial admin user
func createAdminUser(authService *infrastructure.AuthenticationService, logger *slog.Logger) error <span class="cov0" title="0">{
        adminUser := &amp;domain.User{
                Email:    "admin@example.com",
                Username: "admin",
                // Role will be set through RBAC service
                IsActive: true,
        }

        ctx := context.Background()
        if err := authService.CreateUser(ctx, adminUser, "admin123!"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create admin user: %w", err)
        }</span>

        // Generate API key for admin
        <span class="cov0" title="0">apiKey, err := authService.CreateApiKey(ctx, adminUser.ID, "admin-key", []string{"*"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to create admin API key", "error", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Admin API key created", "key", apiKey.Key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoggerAdapter adapts the logger to monitoring.Logger interface
type LoggerAdapter struct {
        Logger *logger.Logger
}

func (l *LoggerAdapter) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        l.Logger.Debug(msg, fields...)
}</span>

func (l *LoggerAdapter) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        l.Logger.Info(msg, fields...)
}</span>

func (l *LoggerAdapter) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        l.Logger.Warn(msg, fields...)
}</span>

func (l *LoggerAdapter) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        l.Logger.Error(msg, fields...)
}</span>

// Simple middleware implementations

func requestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = fmt.Sprintf("%d", time.Now().UnixNano())
                }</span>
                <span class="cov0" title="0">c.Set("request_id", requestID)
                c.Header("X-Request-ID", requestID)
                c.Next()</span>
        }
}

func loggingMiddleware(logger *logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                c.Next()
                duration := time.Since(start)

                logger.Info("HTTP request",
                        "method", c.Request.Method,
                        "path", c.Request.URL.Path,
                        "status", c.Writer.Status(),
                        "duration", duration,
                        "client_ip", c.ClientIP(),
                        "request_id", c.GetString("request_id"),
                )
        }</span>
}

func corsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET,POST,PUT,PATCH,DELETE,OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin,Content-Type,Authorization,X-Request-ID")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// Adapter types for compatibility

type HealthChecker struct {
        logger *LoggerAdapter
        checks map[string]func(context.Context) error
}

func (h *HealthChecker) AddCheck(name string, check func(context.Context) error) <span class="cov0" title="0">{
        h.checks[name] = check
}</span>

func (h *HealthChecker) Handler(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        status := "ok"
        details := make(map[string]string)

        for name, check := range h.checks </span><span class="cov0" title="0">{
                if err := check(ctx); err != nil </span><span class="cov0" title="0">{
                        status = "error"
                        details[name] = err.Error()
                }</span> else<span class="cov0" title="0"> {
                        details[name] = "ok"
                }</span>
        }

        <span class="cov0" title="0">if status == "error" </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "status":  status,
                        "details": details,
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "status":  status,
                "details": details,
        })</span>
}

type CircuitBreakerAdapter struct {
        cb *infrastructure.CircuitBreaker
}

type RedisAdapter struct {
        client *redis.Client
}

type ProcessingEngineAdapter struct{}

func (p *ProcessingEngineAdapter) ProcessFile(ctx context.Context, fileURL string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gorilla/mux"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// Demo application showing the config watcher in action
func main() <span class="cov0" title="0">{
        fmt.Println("üöÄ Hotel Reviews Config Watcher Demo")
        fmt.Println("=====================================")

        // Create logger
        logger := monitoring.NewLogger("config-demo", "info")

        // Create config watcher with fast polling for demo
        options := &amp;infrastructure.ConfigWatcherOptions{
                WatchIntervalSec:    1, // Check every second for demo
                FileChecksum:        true,
                EnvCheckIntervalSec: 5, // Check env vars every 5 seconds
                EnableDebugLogging:  true,
                LogConfigChanges:    true,
                MaxHistorySize:      10,
                EnableRollback:      true,
        }

        watcher, err := infrastructure.NewConfigWatcher(logger, options)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create config watcher", "error", err)
                os.Exit(1)
        }</span>

        // Demo configuration
        <span class="cov0" title="0">demoConfig := map[string]interface{}{
                "server": map[string]interface{}{
                        "port":    8080,
                        "host":    "localhost",
                        "timeout": "30s",
                },
                "app": map[string]interface{}{
                        "name":      "hotel-reviews-demo",
                        "log_level": "info",
                        "debug":     false,
                },
                "cache": map[string]interface{}{
                        "ttl":     "1h",
                        "enabled": true,
                },
        }

        // Register initial configuration
        err = watcher.RegisterConfig("demo_config", demoConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to register demo config", "error", err)
                os.Exit(1)
        }</span>

        // Setup change tracking
        <span class="cov0" title="0">configChangeCount := 0
        watcher.RegisterChangeCallback("demo_config", func(configName string, oldConfig, newConfig interface{}) error </span><span class="cov0" title="0">{
                configChangeCount++
                logger.Info("üîÑ Configuration changed!",
                        "change_number", configChangeCount,
                        "config_name", configName)

                // Show what changed
                if oldConfigMap, ok := oldConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if newConfigMap, ok := newConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                showConfigDiff(logger, oldConfigMap, newConfigMap)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        // Watch environment variables
        <span class="cov0" title="0">envVars := []string{"DEMO_LOG_LEVEL", "DEMO_PORT", "DEMO_DEBUG"}
        for _, envVar := range envVars </span><span class="cov0" title="0">{
                err := watcher.WatchEnvVar("demo_env", envVar)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to watch env var", "var", envVar, "error", err)
                }</span>
        }

        // Setup env var callbacks
        <span class="cov0" title="0">watcher.RegisterChangeCallback("env:DEMO_LOG_LEVEL", func(configName string, oldConfig, newConfig interface{}) error </span><span class="cov0" title="0">{
                logger.Info("üåç Environment variable changed",
                        "var", "DEMO_LOG_LEVEL",
                        "old", oldConfig,
                        "new", newConfig)
                return nil
        }</span>)

        <span class="cov0" title="0">watcher.RegisterChangeCallback("env:DEMO_PORT", func(configName string, oldConfig, newConfig interface{}) error </span><span class="cov0" title="0">{
                logger.Info("üåç Environment variable changed",
                        "var", "DEMO_PORT",
                        "old", oldConfig,
                        "new", newConfig)
                return nil
        }</span>)

        // Create HTTP server for demo API
        <span class="cov0" title="0">router := mux.NewRouter()
        setupDemoRoutes(router, watcher, logger)

        server := &amp;http.Server{
                Addr:    ":8080",
                Handler: router,
        }

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                logger.Info("üåê Starting demo HTTP server", "addr", server.Addr)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error("HTTP server failed", "error", err)
                }</span>
        }()

        // Print demo instructions
        <span class="cov0" title="0">printDemoInstructions()

        // Wait for shutdown signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        logger.Info("üõë Shutting down demo...")

        // Graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server shutdown failed", "error", err)
        }</span>

        <span class="cov0" title="0">if err := watcher.Stop(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Config watcher stop failed", "error", err)
        }</span>

        <span class="cov0" title="0">logger.Info("‚úÖ Demo shutdown complete")</span>
}

func setupDemoRoutes(router *mux.Router, watcher *infrastructure.ConfigWatcher, logger monitoring.Logger) <span class="cov0" title="0">{
        // API to get current configuration
        router.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                config, exists := watcher.GetConfig("demo_config")
                if !exists </span><span class="cov0" title="0">{
                        http.Error(w, "No configuration found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": true,
                        "config":  config,
                })</span>
        }).Methods("GET")

        // API to get configuration history
        <span class="cov0" title="0">router.HandleFunc("/config/history", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                history := watcher.GetConfigHistory("demo_config")

                historyResponse := make([]map[string]interface{}, len(history))
                for i, snapshot := range history </span><span class="cov0" title="0">{
                        historyResponse[i] = map[string]interface{}{
                                "hash":      snapshot.Hash,
                                "timestamp": snapshot.Timestamp,
                                "source":    snapshot.Source,
                        }
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": true,
                        "history": historyResponse,
                        "total":   len(history),
                })</span>
        }).Methods("GET")

        // API to rollback configuration
        <span class="cov0" title="0">router.HandleFunc("/config/rollback/{hash}", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                vars := mux.Vars(r)
                hash := vars["hash"]

                if hash == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Hash parameter required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">logger.Info("üîÑ Rollback requested", "hash", hash)

                err := watcher.RollbackConfig("demo_config", hash)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Rollback failed", "error", err, "hash", hash)
                        http.Error(w, fmt.Sprintf("Rollback failed: %v", err), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": true,
                        "message": "Configuration rolled back successfully",
                        "hash":    hash,
                })</span>
        }).Methods("POST")

        // API to get metrics
        <span class="cov0" title="0">router.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                metrics := watcher.GetMetrics()

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": true,
                        "metrics": metrics,
                })
        }</span>).Methods("GET")

        // Health check
        <span class="cov0" title="0">router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                health := map[string]interface{}{
                        "status":         "healthy",
                        "watcher_health": watcher.HealthCheck() == nil,
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(health)
        }</span>).Methods("GET")
}

func showConfigDiff(logger monitoring.Logger, oldConfig, newConfig map[string]interface{}) <span class="cov0" title="0">{
        logger.Info("üìã Configuration differences:")

        // Check for changes in nested maps
        for key, newValue := range newConfig </span><span class="cov0" title="0">{
                if oldValue, exists := oldConfig[key]; exists </span><span class="cov0" title="0">{
                        if !isEqual(oldValue, newValue) </span><span class="cov0" title="0">{
                                logger.Info("  üî∏ Changed", "key", key, "old", oldValue, "new", newValue)
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Info("  ‚ûï Added", "key", key, "value", newValue)
                }</span>
        }

        // Check for removed keys
        <span class="cov0" title="0">for key, oldValue := range oldConfig </span><span class="cov0" title="0">{
                if _, exists := newConfig[key]; !exists </span><span class="cov0" title="0">{
                        logger.Info("  ‚ûñ Removed", "key", key, "value", oldValue)
                }</span>
        }
}

func isEqual(a, b interface{}) bool <span class="cov0" title="0">{
        aBytes, _ := json.Marshal(a)
        bBytes, _ := json.Marshal(b)
        return string(aBytes) == string(bBytes)
}</span>

func printDemoInstructions() <span class="cov0" title="0">{
        fmt.Println("")
        fmt.Println("üéØ Demo Instructions:")
        fmt.Println("====================")
        fmt.Println("")
        fmt.Println("üì° API Endpoints:")
        fmt.Println("  GET  http://localhost:8080/config          - View current config")
        fmt.Println("  GET  http://localhost:8080/config/history   - View config history")
        fmt.Println("  POST http://localhost:8080/config/rollback/{hash} - Rollback config")
        fmt.Println("  GET  http://localhost:8080/metrics          - View watcher metrics")
        fmt.Println("  GET  http://localhost:8080/health           - Health check")
        fmt.Println("")
        fmt.Println("üåç Environment Variables to Test:")
        fmt.Println("  export DEMO_LOG_LEVEL=debug")
        fmt.Println("  export DEMO_PORT=9090")
        fmt.Println("  export DEMO_DEBUG=true")
        fmt.Println("")
        fmt.Println("üìù Configuration Updates:")
        fmt.Println("  The watcher is monitoring for changes every second")
        fmt.Println("  Watch the logs to see real-time configuration updates!")
        fmt.Println("")
        fmt.Println("üéÆ Try these commands in another terminal:")
        fmt.Println("  curl http://localhost:8080/config")
        fmt.Println("  curl http://localhost:8080/config/history")
        fmt.Println("  curl http://localhost:8080/metrics")
        fmt.Println("  export DEMO_LOG_LEVEL=debug  # Watch the logs!")
        fmt.Println("")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gorilla/mux"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/config"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// Application represents the main application with configuration hot-reloading
type Application struct {
        configManager *config.ConfigManager
        httpServer    *http.Server
        router        *mux.Router
        logger        monitoring.Logger
        ctx           context.Context
        cancel        context.CancelFunc
}

// NewApplication creates a new application instance
func NewApplication() (*Application, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // Create logger (in a real app, this would be more sophisticated)
        logger := &amp;SimpleLogger{}

        // Create configuration manager
        configManager, err := config.NewConfigManager(logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create config manager: %w", err)
        }</span>

        <span class="cov0" title="0">app := &amp;Application{
                configManager: configManager,
                logger:        logger,
                ctx:           ctx,
                cancel:        cancel,
        }

        // Initialize application components
        if err := app.initialize(); err != nil </span><span class="cov0" title="0">{
                cancel()
                configManager.Stop()
                return nil, fmt.Errorf("failed to initialize application: %w", err)
        }</span>

        <span class="cov0" title="0">return app, nil</span>
}

// initialize sets up the application components
func (app *Application) initialize() error <span class="cov0" title="0">{
        // Setup HTTP router
        app.router = mux.NewRouter()
        app.setupRoutes()

        // Create HTTP server with initial configuration
        config := app.configManager.GetConfig()
        if config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration available")
        }</span>

        <span class="cov0" title="0">app.httpServer = &amp;http.Server{
                Addr:         config.GetServerAddr(),
                Handler:      app.router,
                ReadTimeout:  config.Server.ReadTimeout,
                WriteTimeout: config.Server.WriteTimeout,
                IdleTimeout:  config.Server.IdleTimeout,
        }

        // Register for configuration changes
        app.configManager.RegisterComponent("http_server", app.handleServerConfigChange)
        app.configManager.RegisterComponent("application", app.handleAppConfigChange)

        // Set component references (for more sophisticated reconfiguration)
        components := map[string]interface{}{
                "server": app.httpServer,
        }
        app.configManager.SetComponentReferences(components)

        app.logger.Info("Application initialized",
                "server_addr", config.GetServerAddr(),
                "environment", config.App.Environment,
                "log_level", config.App.LogLevel)

        return nil</span>
}

// setupRoutes configures HTTP routes
func (app *Application) setupRoutes() <span class="cov0" title="0">{
        // Health check endpoint
        app.router.HandleFunc("/health", app.healthHandler).Methods("GET")

        // Configuration endpoints
        app.router.HandleFunc("/config", app.configHandler).Methods("GET")
        app.router.HandleFunc("/config/history", app.configHistoryHandler).Methods("GET")
        app.router.HandleFunc("/config/rollback/{hash}", app.configRollbackHandler).Methods("POST")
        app.router.HandleFunc("/config/metrics", app.configMetricsHandler).Methods("GET")

        // Example business endpoints
        app.router.HandleFunc("/api/v1/reviews", app.reviewsHandler).Methods("GET")
        app.router.HandleFunc("/api/v1/hotels", app.hotelsHandler).Methods("GET")

        // Admin endpoints
        app.router.HandleFunc("/admin/status", app.statusHandler).Methods("GET")

        app.logger.Info("HTTP routes configured")
}</span>

// HTTP Handlers
func (app *Application) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        health := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC(),
                "version":   "1.0.0",
        }

        // Check config manager health
        if err := app.configManager.HealthCheck(); err != nil </span><span class="cov0" title="0">{
                health["status"] = "unhealthy"
                health["config_manager_error"] = err.Error()
                w.WriteHeader(http.StatusServiceUnavailable)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(health)</span>
}

func (app *Application) configHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        config := app.configManager.GetConfig()
        if config == nil </span><span class="cov0" title="0">{
                http.Error(w, "No configuration available", http.StatusInternalServerError)
                return
        }</span>

        // Return a summary instead of the full config (security)
        <span class="cov0" title="0">summary := config.GetConfigSummary()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(summary)</span>
}

func (app *Application) configHistoryHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        history := app.configManager.GetConfigHistory()

        // Return simplified history for API response
        historyResponse := make([]map[string]interface{}, len(history))
        for i, snapshot := range history </span><span class="cov0" title="0">{
                historyResponse[i] = map[string]interface{}{
                        "hash":      snapshot.Hash,
                        "timestamp": snapshot.Timestamp,
                        "source":    snapshot.Source,
                }
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "history": historyResponse,
                "total":   len(history),
        })</span>
}

func (app *Application) configRollbackHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        targetHash := vars["hash"]

        if targetHash == "" </span><span class="cov0" title="0">{
                http.Error(w, "Hash parameter is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">app.logger.Info("Configuration rollback requested", "target_hash", targetHash)

        if err := app.configManager.RollbackConfig(targetHash); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("Configuration rollback failed", "error", err, "target_hash", targetHash)
                http.Error(w, fmt.Sprintf("Rollback failed: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success":     true,
                "message":     "Configuration rolled back successfully",
                "target_hash": targetHash,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *Application) configMetricsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        metrics := app.configManager.GetMetrics()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(metrics)
}</span>

func (app *Application) reviewsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        config := app.configManager.GetConfig()

        // Example response that shows current configuration affects business logic
        response := map[string]interface{}{
                "reviews": []map[string]interface{}{
                        {
                                "id":       1,
                                "hotel_id": 1,
                                "rating":   4.5,
                                "comment":  "Great hotel!",
                        },
                        {
                                "id":       2,
                                "hotel_id": 1,
                                "rating":   5.0,
                                "comment":  "Excellent service!",
                        },
                },
                "config_info": map[string]interface{}{
                        "cache_ttl":          config.Cache.ReviewTTL.String(),
                        "max_request_size":   config.App.MaxRequestSize,
                        "rate_limit_enabled": config.App.EnableRateLimit,
                },
                "timestamp": time.Now().UTC(),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (app *Application) hotelsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        config := app.configManager.GetConfig()

        response := map[string]interface{}{
                "hotels": []map[string]interface{}{
                        {
                                "id":     1,
                                "name":   "Grand Hotel",
                                "city":   "New York",
                                "rating": 4.5,
                        },
                        {
                                "id":     2,
                                "name":   "Ocean View Resort",
                                "city":   "Miami",
                                "rating": 4.8,
                        },
                },
                "config_info": map[string]interface{}{
                        "cache_ttl":          config.Cache.HotelTTL.String(),
                        "database_host":      config.Database.Host,
                        "database_max_conns": config.Database.MaxConns,
                },
                "timestamp": time.Now().UTC(),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (app *Application) statusHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        config := app.configManager.GetConfig()
        metrics := app.configManager.GetMetrics()

        status := map[string]interface{}{
                "application": map[string]interface{}{
                        "name":        config.App.Name,
                        "version":     config.App.Version,
                        "environment": config.App.Environment,
                        "uptime":      time.Since(time.Now()).String(), // This would be actual uptime
                },
                "configuration": map[string]interface{}{
                        "current_config": config.GetConfigSummary(),
                        "metrics":        metrics,
                        "health":         app.configManager.HealthCheck() == nil,
                },
                "server": map[string]interface{}{
                        "address":      app.httpServer.Addr,
                        "tls_enabled":  config.Server.EnableTLS,
                        "read_timeout": config.Server.ReadTimeout.String(),
                },
                "timestamp": time.Now().UTC(),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(status)
}</span>

// Configuration change handlers
func (app *Application) handleServerConfigChange(oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        app.logger.Info("Server configuration change detected")

        newAppConfig, ok := newConfig.(*config.AppConfig)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config type for server reconfiguration")
        }</span>

        // In a real application, we would gracefully restart the server
        // For this example, we'll just update timeouts
        <span class="cov0" title="0">app.httpServer.ReadTimeout = newAppConfig.Server.ReadTimeout
        app.httpServer.WriteTimeout = newAppConfig.Server.WriteTimeout
        app.httpServer.IdleTimeout = newAppConfig.Server.IdleTimeout

        app.logger.Info("Server configuration updated",
                "read_timeout", newAppConfig.Server.ReadTimeout,
                "write_timeout", newAppConfig.Server.WriteTimeout,
                "idle_timeout", newAppConfig.Server.IdleTimeout)

        return nil</span>
}

func (app *Application) handleAppConfigChange(oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        app.logger.Info("Application configuration change detected")

        newAppConfig, ok := newConfig.(*config.AppConfig)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config type for app reconfiguration")
        }</span>

        // Example: Update logging level
        <span class="cov0" title="0">if newAppConfig.App.LogLevel != "" </span><span class="cov0" title="0">{
                app.logger.Info("Log level updated", "new_level", newAppConfig.App.LogLevel)
                // In a real app, you would reconfigure the actual logger here
        }</span>

        // Example: Update max request size (this would affect middleware)
        <span class="cov0" title="0">app.logger.Info("Application settings updated",
                "max_request_size", newAppConfig.App.MaxRequestSize,
                "rate_limit_enabled", newAppConfig.App.EnableRateLimit,
                "auth_enabled", newAppConfig.App.EnableAuthentication)

        return nil</span>
}

// Run starts the application
func (app *Application) Run() error <span class="cov0" title="0">{
        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                app.logger.Info("Starting HTTP server", "addr", app.httpServer.Addr)
                if err := app.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        app.logger.Error("HTTP server failed", "error", err)
                }</span>
        }()

        // Setup signal handling
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Wait for shutdown signal
        select </span>{
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                app.logger.Info("Received shutdown signal", "signal", sig)</span>
        case &lt;-app.ctx.Done():<span class="cov0" title="0">
                app.logger.Info("Application context cancelled")</span>
        }

        <span class="cov0" title="0">return app.shutdown()</span>
}

// shutdown gracefully shuts down the application
func (app *Application) shutdown() error <span class="cov0" title="0">{
        app.logger.Info("Shutting down application")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Shutdown HTTP server
        if app.httpServer != nil </span><span class="cov0" title="0">{
                if err := app.httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("HTTP server shutdown failed", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        app.logger.Info("HTTP server shut down gracefully")
                }</span>
        }

        // Stop configuration manager
        <span class="cov0" title="0">if app.configManager != nil </span><span class="cov0" title="0">{
                if err := app.configManager.Stop(); err != nil </span><span class="cov0" title="0">{
                        app.logger.Error("Config manager stop failed", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        app.logger.Info("Configuration manager stopped")
                }</span>
        }

        <span class="cov0" title="0">app.cancel()
        app.logger.Info("Application shutdown complete")
        return nil</span>
}

// SimpleLogger is a basic logger implementation for the example
type SimpleLogger struct{}

func (l *SimpleLogger) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[DEBUG] %s %v\n", msg, fields)
}</span>

func (l *SimpleLogger) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[INFO] %s %v\n", msg, fields)
}</span>

func (l *SimpleLogger) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[WARN] %s %v\n", msg, fields)
}</span>

func (l *SimpleLogger) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[ERROR] %s %v\n", msg, fields)
}</span>

// main function
func main() <span class="cov0" title="0">{
        fmt.Println("Starting Hotel Reviews Service with Configuration Hot-Reloading...")

        app, err := NewApplication()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create application: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Application failed: %v\n", err)
                os.Exit(1)
        }</span>
}

// Example usage instructions:
//
// 1. Build and run the application:
//    go run cmd/server-with-config-watcher/main.go
//
// 2. The application will start on http://localhost:8080 (or as configured)
//
// 3. Test endpoints:
//    curl http://localhost:8080/health
//    curl http://localhost:8080/config
//    curl http://localhost:8080/config/history
//    curl http://localhost:8080/config/metrics
//    curl http://localhost:8080/api/v1/reviews
//    curl http://localhost:8080/admin/status
//
// 4. Test configuration hot-reloading:
//    - Edit config/app.json and change the server port to 9090
//    - The application will detect the change and update accordingly
//    - Check the logs to see the configuration change being processed
//
// 5. Test environment variable changes:
//    export APP_LOG_LEVEL=debug
//    export APP_SERVER_PORT=9090
//    - The application will detect these changes and update the configuration
//
// 6. Test configuration rollback:
//    - Get configuration history: curl http://localhost:8080/config/history
//    - Rollback to a previous version: curl -X POST http://localhost:8080/config/rollback/{hash}
//
// 7. Monitor configuration changes:
//    - Watch the application logs to see real-time configuration updates
//    - Check metrics endpoint for statistics about configuration reloads
</pre>
		
		<pre class="file" id="file3" style="display: none">package application

import (
        "encoding/json"
        "errors"
        "log/slog"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
)

// AuthHandlers handles authentication-related HTTP requests
type AuthHandlers struct {
        authService     *infrastructure.AuthenticationService
        passwordService domain.PasswordService
        logger          *slog.Logger
}

// NewAuthHandlers creates a new authentication handlers instance
func NewAuthHandlers(authService *infrastructure.AuthenticationService, passwordService domain.PasswordService, logger *slog.Logger) *AuthHandlers <span class="cov0" title="0">{
        return &amp;AuthHandlers{
                authService:     authService,
                passwordService: passwordService,
                logger:          logger,
        }
}</span>

// Request and Response structures

type RegisterRequest struct {
        Username  string `json:"username" validate:"required,min=3,max=50"`
        Email     string `json:"email" validate:"required,email"`
        Password  string `json:"password" validate:"required,min=8"`
        FirstName string `json:"first_name" validate:"max=100"`
        LastName  string `json:"last_name" validate:"max=100"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" validate:"required"`
}

type ChangePasswordRequest struct {
        OldPassword string `json:"old_password" validate:"required"`
        NewPassword string `json:"new_password" validate:"required,min=8"`
}

type ForgotPasswordRequest struct {
        Email string `json:"email" validate:"required,email"`
}

type ResetPasswordRequest struct {
        Token       string `json:"token" validate:"required"`
        NewPassword string `json:"new_password" validate:"required,min=8"`
}

type CreateApiKeyRequest struct {
        Name      string     `json:"name" validate:"required,min=1,max=100"`
        Scopes    []string   `json:"scopes"`
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

type UpdateUserRequest struct {
        FirstName string `json:"first_name" validate:"max=100"`
        LastName  string `json:"last_name" validate:"max=100"`
        Email     string `json:"email" validate:"email"`
}

type AssignRoleRequest struct {
        RoleID uuid.UUID `json:"role_id" validate:"required"`
}

type CreateRoleRequest struct {
        Name        string `json:"name" validate:"required,min=1,max=50"`
        Description string `json:"description"`
}

type CreatePermissionRequest struct {
        Name        string `json:"name" validate:"required,min=1,max=100"`
        Resource    string `json:"resource" validate:"required,max=50"`
        Action      string `json:"action" validate:"required,oneof=create read update delete execute"`
        Description string `json:"description"`
}

type ErrorResponse struct {
        Error   string `json:"error"`
        Code    int    `json:"code"`
        Time    string `json:"time"`
        Details string `json:"details,omitempty"`
}

type SuccessResponse struct {
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
        Time    string      `json:"time"`
}

// Authentication endpoints

// Register handles user registration
func (h *AuthHandlers) Register(w http.ResponseWriter, r *http.Request) <span class="cov6" title="5">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov4" title="3">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov3" title="2">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Hash password
        <span class="cov3" title="2">hashedPassword, err := h.passwordService.HashPassword(req.Password)
        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error("password hashing failed", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "registration failed", "")
                return
        }</span>

        // Create user
        <span class="cov1" title="1">user := &amp;domain.User{
                ID:           uuid.New(),
                Username:     req.Username,
                Email:        req.Email,
                PasswordHash: hashedPassword,
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                IsActive:     true,
                IsVerified:   false,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        // Register user through auth service
        if err := h.authService.Register(r.Context(), user, req.Password); err != nil </span><span class="cov1" title="1">{
                h.logger.Error("user registration failed", "error", err, "email", req.Email)
                h.writeErrorResponse(w, http.StatusConflict, "registration failed", err.Error())
                return
        }</span>

        // Audit the registration
        <span class="cov0" title="0">_ = h.authService.AuditAction(r.Context(), &amp;user.ID, "register", "user", &amp;user.ID, nil, nil, h.getClientIP(r), r.Header.Get("User-Agent"))

        h.writeSuccessResponse(w, http.StatusCreated, "user registered successfully", map[string]interface{}{
                "user_id": user.ID,
                "email":   user.Email,
        })</span>
}

// Login handles user login
func (h *AuthHandlers) Login(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov4" title="3">if err := h.validateRequest(req); err != nil </span><span class="cov3" title="2">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Authenticate user
        <span class="cov1" title="1">ipAddress := h.getClientIP(r)
        userAgent := r.Header.Get("User-Agent")

        loginResponse, err := h.authService.Login(r.Context(), req.Email, req.Password, ipAddress, userAgent)
        if err != nil </span><span class="cov1" title="1">{
                h.logger.Warn("login failed", "error", err, "email", req.Email, "ip", ipAddress)
                h.writeErrorResponse(w, http.StatusUnauthorized, "login failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "login successful", loginResponse)</span>
}

// RefreshToken handles token refresh
func (h *AuthHandlers) RefreshToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req RefreshTokenRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Refresh token
        <span class="cov0" title="0">loginResponse, err := h.authService.RefreshToken(r.Context(), req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("token refresh failed", "error", err, "ip", h.getClientIP(r))
                h.writeErrorResponse(w, http.StatusUnauthorized, "token refresh failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "token refreshed successfully", loginResponse)</span>
}

// Logout handles user logout
func (h *AuthHandlers) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract token from Authorization header
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "authorization header required", "")
                return
        }</span>

        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid authorization header format", "")
                return
        }</span>

        <span class="cov0" title="0">accessToken := parts[1]
        if err := h.authService.Logout(r.Context(), accessToken); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("logout failed", "error", err, "ip", h.getClientIP(r))
                h.writeErrorResponse(w, http.StatusInternalServerError, "logout failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "logged out successfully", nil)</span>
}

// LogoutAll handles logging out from all devices
func (h *AuthHandlers) LogoutAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        // TODO: Implement LogoutAll functionality in AuthenticationService
        <span class="cov0" title="0">h.logger.Info("logout all requested", "user_id", user.ID)

        h.writeSuccessResponse(w, http.StatusOK, "logged out from all devices", nil)</span>
}

// User management endpoints

// GetProfile returns the current user's profile
func (h *AuthHandlers) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "profile retrieved successfully", user)</span>
}

// UpdateProfile updates the current user's profile
func (h *AuthHandlers) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Update user
        <span class="cov0" title="0">if req.FirstName != "" </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != "" </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                user.Email = req.Email
        }</span>

        <span class="cov0" title="0">if err := h.authService.UpdateUser(r.Context(), user); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("profile update failed", "error", err, "user_id", user.ID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "profile update failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "profile updated successfully", user)</span>
}

// ChangePassword handles password change
func (h *AuthHandlers) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        <span class="cov0" title="0">var req ChangePasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Change password
        <span class="cov0" title="0">if err := h.authService.ChangePassword(r.Context(), user.ID, req.OldPassword, req.NewPassword); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("password change failed", "error", err, "user_id", user.ID)
                h.writeErrorResponse(w, http.StatusBadRequest, "password change failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "password changed successfully", nil)</span>
}

// API Key management endpoints

// CreateApiKey creates a new API key
func (h *AuthHandlers) CreateApiKey(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        <span class="cov0" title="0">var req CreateApiKeyRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Create API key
        <span class="cov0" title="0">apiKey, err := h.authService.CreateApiKey(r.Context(), user.ID, req.Name, req.Scopes, req.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("API key creation failed", "error", err, "user_id", user.ID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "API key creation failed", err.Error())
                return
        }</span>

        // Return the API key (this is the only time it will be shown)
        <span class="cov0" title="0">response := map[string]interface{}{
                "id":         apiKey.ID,
                "name":       apiKey.Name,
                "key":        apiKey.Key,
                "scopes":     apiKey.Scopes,
                "expires_at": apiKey.ExpiresAt,
                "created_at": apiKey.CreatedAt,
        }

        h.writeSuccessResponse(w, http.StatusCreated, "API key created successfully", response)</span>
}

// ListApiKeys lists user's API keys
func (h *AuthHandlers) ListApiKeys(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limit, offset := h.parsePaginationParams(r)

        // Get API keys
        apiKeys, err := h.authService.ListApiKeys(r.Context(), user.ID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("API key listing failed", "error", err, "user_id", user.ID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "API key listing failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "API keys retrieved successfully", apiKeys)</span>
}

// DeleteApiKey deletes an API key
func (h *AuthHandlers) DeleteApiKey(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := h.getUserFromContext(r)
        if user == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusUnauthorized, "authentication required", "")
                return
        }</span>

        // Parse API key ID from URL
        <span class="cov0" title="0">vars := mux.Vars(r)
        apiKeyID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid API key ID", err.Error())
                return
        }</span>

        // Delete API key
        <span class="cov0" title="0">if err := h.authService.DeleteApiKey(r.Context(), apiKeyID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("API key deletion failed", "error", err, "user_id", user.ID, "api_key_id", apiKeyID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "API key deletion failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "API key deleted successfully", nil)</span>
}

// Admin endpoints (require admin role)

// ListUsers lists all users (admin only)
func (h *AuthHandlers) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit, offset := h.parsePaginationParams(r)

        // Get users
        users, err := h.authService.ListUsers(r.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("user listing failed", "error", err)
                h.writeErrorResponse(w, http.StatusInternalServerError, "user listing failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "users retrieved successfully", users)</span>
}

// GetUser gets a specific user (admin only)
func (h *AuthHandlers) GetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse user ID from URL
        vars := mux.Vars(r)
        userID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid user ID", err.Error())
                return
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := h.authService.GetUser(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("user retrieval failed", "error", err, "user_id", userID)
                h.writeErrorResponse(w, http.StatusNotFound, "user not found", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "user retrieved successfully", user)</span>
}

// DeleteUser deletes a user (admin only)
func (h *AuthHandlers) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse user ID from URL
        vars := mux.Vars(r)
        userID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid user ID", err.Error())
                return
        }</span>

        // Delete user
        <span class="cov0" title="0">if err := h.authService.DeleteUser(r.Context(), userID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("user deletion failed", "error", err, "user_id", userID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "user deletion failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "user deleted successfully", nil)</span>
}

// AssignRole assigns a role to a user (admin only)
func (h *AuthHandlers) AssignRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse user ID from URL
        vars := mux.Vars(r)
        userID, err := uuid.Parse(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid user ID", err.Error())
                return
        }</span>

        <span class="cov0" title="0">var req AssignRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if err := h.validateRequest(req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "validation failed", err.Error())
                return
        }</span>

        // Assign role
        <span class="cov0" title="0">if err := h.authService.AssignRole(r.Context(), userID, req.RoleID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("role assignment failed", "error", err, "user_id", userID, "role_id", req.RoleID)
                h.writeErrorResponse(w, http.StatusInternalServerError, "role assignment failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, http.StatusOK, "role assigned successfully", nil)</span>
}

// Helper methods

func (h *AuthHandlers) writeErrorResponse(w http.ResponseWriter, statusCode int, message, details string) <span class="cov10" title="12">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        response := ErrorResponse{
                Error:   message,
                Code:    statusCode,
                Time:    time.Now().UTC().Format(time.RFC3339),
                Details: details,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode JSON response", "error", err)
        }</span>
}

func (h *AuthHandlers) writeSuccessResponse(w http.ResponseWriter, statusCode int, message string, data interface{}) <span class="cov6" title="4">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        response := SuccessResponse{
                Message: message,
                Data:    data,
                Time:    time.Now().UTC().Format(time.RFC3339),
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode JSON response", "error", err)
        }</span>
}

func (h *AuthHandlers) getClientIP(r *http.Request) string <span class="cov6" title="4">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov1" title="1">{
                parts := strings.Split(xff, ",")
                return strings.TrimSpace(parts[0])
        }</span>

        // Check X-Real-IP header
        <span class="cov4" title="3">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov3" title="2">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov1" title="1">return r.RemoteAddr</span>
}

func (h *AuthHandlers) getUserFromContext(r *http.Request) *domain.User <span class="cov3" title="2">{
        user, ok := r.Context().Value("user").(*domain.User)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return user</span>
}

func (h *AuthHandlers) parsePaginationParams(r *http.Request) (int, int) <span class="cov6" title="5">{
        limit := 20 // default limit
        offset := 0 // default offset

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov6" title="4">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov3" title="2">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov6" title="5">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov4" title="3">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov1" title="1">{
                        offset = parsedOffset
                }</span>
        }

        // Limit maximum page size
        <span class="cov6" title="5">if limit &gt; 100 </span><span class="cov1" title="1">{
                limit = 100
        }</span>

        <span class="cov6" title="5">return limit, offset</span>
}

func (h *AuthHandlers) validateRequest(req interface{}) error <span class="cov8" title="9">{
        switch r := req.(type) </span>{
        case RegisterRequest:<span class="cov7" title="6">
                return h.validateRegisterRequest(r)</span>
        case LoginRequest:<span class="cov4" title="3">
                return h.validateLoginRequest(r)</span>
        default:<span class="cov0" title="0">
                return errors.New("unknown request type")</span>
        }
}

func (h *AuthHandlers) validateRegisterRequest(req RegisterRequest) error <span class="cov7" title="6">{
        var validationErrors []string
        
        // Validate required fields
        if req.Username == "" </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, "username is required")
        }</span>
        <span class="cov7" title="6">if req.Email == "" </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, "email is required")
        }</span>
        <span class="cov7" title="6">if req.Password == "" </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, "password is required")
        }</span>
        
        // Validate email format
        <span class="cov7" title="6">if req.Email != "" </span><span class="cov6" title="5">{
                emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
                if !emailRegex.MatchString(req.Email) </span><span class="cov1" title="1">{
                        validationErrors = append(validationErrors, "email format is invalid")
                }</span>
        }
        
        // Validate password strength
        <span class="cov7" title="6">if req.Password != "" &amp;&amp; len(req.Password) &lt; 8 </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, "password must be at least 8 characters long")
        }</span>
        
        // Validate username
        <span class="cov7" title="6">if req.Username != "" &amp;&amp; len(req.Username) &lt; 3 </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, "username must be at least 3 characters long")
        }</span>
        
        <span class="cov7" title="6">if len(validationErrors) &gt; 0 </span><span class="cov4" title="3">{
                return errors.New(strings.Join(validationErrors, "; "))
        }</span>
        
        <span class="cov4" title="3">return nil</span>
}

func (h *AuthHandlers) validateLoginRequest(req LoginRequest) error <span class="cov4" title="3">{
        var validationErrors []string
        
        // Validate required fields
        if req.Email == "" </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, "email is required")
        }</span>
        <span class="cov4" title="3">if req.Password == "" </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, "password is required")
        }</span>
        
        // Validate email format
        <span class="cov4" title="3">if req.Email != "" </span><span class="cov4" title="3">{
                emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
                if !emailRegex.MatchString(req.Email) </span><span class="cov1" title="1">{
                        validationErrors = append(validationErrors, "email format is invalid")
                }</span>
        }
        
        <span class="cov4" title="3">if len(validationErrors) &gt; 0 </span><span class="cov3" title="2">{
                return errors.New(strings.Join(validationErrors, "; "))
        }</span>
        
        <span class="cov1" title="1">return nil</span>
}

// SetupAuthRoutes sets up all authentication routes
func (h *AuthHandlers) SetupAuthRoutes(router *mux.Router) <span class="cov0" title="0">{
        // Authentication routes
        authRouter := router.PathPrefix("/auth").Subrouter()
        authRouter.HandleFunc("/register", h.Register).Methods("POST")
        authRouter.HandleFunc("/login", h.Login).Methods("POST")
        authRouter.HandleFunc("/refresh", h.RefreshToken).Methods("POST")
        authRouter.HandleFunc("/logout", h.Logout).Methods("POST")
        authRouter.HandleFunc("/logout-all", h.LogoutAll).Methods("POST")

        // User profile routes
        userRouter := router.PathPrefix("/user").Subrouter()
        userRouter.HandleFunc("/profile", h.GetProfile).Methods("GET")
        userRouter.HandleFunc("/profile", h.UpdateProfile).Methods("PUT")
        userRouter.HandleFunc("/change-password", h.ChangePassword).Methods("POST")

        // API key routes
        apiKeyRouter := router.PathPrefix("/api-keys").Subrouter()
        apiKeyRouter.HandleFunc("", h.CreateApiKey).Methods("POST")
        apiKeyRouter.HandleFunc("", h.ListApiKeys).Methods("GET")
        apiKeyRouter.HandleFunc("/{id}", h.DeleteApiKey).Methods("DELETE")

        // Admin routes
        adminRouter := router.PathPrefix("/admin").Subrouter()
        adminRouter.HandleFunc("/users", h.ListUsers).Methods("GET")
        adminRouter.HandleFunc("/users/{id}", h.GetUser).Methods("GET")
        adminRouter.HandleFunc("/users/{id}", h.DeleteUser).Methods("DELETE")
        adminRouter.HandleFunc("/users/{id}/roles", h.AssignRole).Methods("POST")
}</span>

// HealthCheck provides a health check endpoint
func (h *AuthHandlers) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        health := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "service":   "authentication",
        }

        h.writeSuccessResponse(w, http.StatusOK, "service is healthy", health)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package application

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
)

// AuthMiddleware provides comprehensive authentication and authorization middleware
type AuthMiddleware struct {
        authService      *infrastructure.AuthenticationService
        rateLimiter      *RateLimiter
        circuitBreaker   *infrastructure.CircuitBreaker
        metricsCollector *AuthMetricsCollector
        blacklist        *BlacklistManager
        sessionManager   *SessionManager
        logger           *slog.Logger
        config           *AuthMiddlewareConfig
        mu               sync.RWMutex
}

// AuthMiddlewareConfig holds configuration for the authentication middleware
type AuthMiddlewareConfig struct {
        // JWT Configuration
        JWTSecret        string        `json:"jwt_secret"`
        JWTExpiry        time.Duration `json:"jwt_expiry"`
        JWTRefreshExpiry time.Duration `json:"jwt_refresh_expiry"`
        JWTIssuer        string        `json:"jwt_issuer"`

        // Rate Limiting Configuration
        RateLimitEnabled         bool          `json:"rate_limit_enabled"`
        RateLimitRequests        int           `json:"rate_limit_requests"`
        RateLimitWindow          time.Duration `json:"rate_limit_window"`
        RateLimitBurst           int           `json:"rate_limit_burst"`
        RateLimitCleanupInterval time.Duration `json:"rate_limit_cleanup_interval"`

        // Session Configuration
        SessionTimeout         time.Duration `json:"session_timeout"`
        SessionCleanupInterval time.Duration `json:"session_cleanup_interval"`
        MaxActiveSessions      int           `json:"max_active_sessions"`
        SessionCookieName      string        `json:"session_cookie_name"`
        SessionSecure          bool          `json:"session_secure"`
        SessionHttpOnly        bool          `json:"session_http_only"`
        SessionSameSite        http.SameSite `json:"session_same_site"`

        // Security Configuration
        BlacklistEnabled       bool          `json:"blacklist_enabled"`
        BlacklistCheckInterval time.Duration `json:"blacklist_check_interval"`
        WhitelistEnabled       bool          `json:"whitelist_enabled"`
        WhitelistIPs           []string      `json:"whitelist_ips"`
        TrustedProxies         []string      `json:"trusted_proxies"`

        // API Key Configuration
        APIKeyEnabled       bool     `json:"api_key_enabled"`
        APIKeyHeaders       []string `json:"api_key_headers"`
        APIKeyQueryParam    string   `json:"api_key_query_param"`
        APIKeyHashAlgorithm string   `json:"api_key_hash_algorithm"`

        // Audit Configuration
        AuditEnabled          bool          `json:"audit_enabled"`
        AuditLogSensitiveData bool          `json:"audit_log_sensitive_data"`
        AuditBufferSize       int           `json:"audit_buffer_size"`
        AuditFlushInterval    time.Duration `json:"audit_flush_interval"`

        // Circuit Breaker Configuration
        CircuitBreakerEnabled   bool          `json:"circuit_breaker_enabled"`
        CircuitBreakerThreshold int           `json:"circuit_breaker_threshold"`
        CircuitBreakerTimeout   time.Duration `json:"circuit_breaker_timeout"`
        CircuitBreakerReset     time.Duration `json:"circuit_breaker_reset"`

        // Metrics Configuration
        MetricsEnabled            bool          `json:"metrics_enabled"`
        MetricsCollectionInterval time.Duration `json:"metrics_collection_interval"`
        MetricsRetentionPeriod    time.Duration `json:"metrics_retention_period"`

        // CORS Configuration
        CORSEnabled          bool          `json:"cors_enabled"`
        CORSAllowedOrigins   []string      `json:"cors_allowed_origins"`
        CORSAllowedMethods   []string      `json:"cors_allowed_methods"`
        CORSAllowedHeaders   []string      `json:"cors_allowed_headers"`
        CORSExposedHeaders   []string      `json:"cors_exposed_headers"`
        CORSAllowCredentials bool          `json:"cors_allow_credentials"`
        CORSMaxAge           time.Duration `json:"cors_max_age"`

        // Security Headers
        SecurityHeaders       map[string]string `json:"security_headers"`
        EnableCSP             bool              `json:"enable_csp"`
        CSPDirectives         map[string]string `json:"csp_directives"`
        EnableHSTS            bool              `json:"enable_hsts"`
        HSTSMaxAge            time.Duration     `json:"hsts_max_age"`
        HSTSIncludeSubdomains bool              `json:"hsts_include_subdomains"`
        HSTSPreload           bool              `json:"hsts_preload"`
}

// DefaultAuthMiddlewareConfig returns default configuration
func DefaultAuthMiddlewareConfig() *AuthMiddlewareConfig <span class="cov8" title="18">{
        return &amp;AuthMiddlewareConfig{
                JWTExpiry:                 15 * time.Minute,
                JWTRefreshExpiry:          7 * 24 * time.Hour,
                JWTIssuer:                 "hotel-reviews-service",
                RateLimitEnabled:          true,
                RateLimitRequests:         100,
                RateLimitWindow:           time.Minute,
                RateLimitBurst:            10,
                RateLimitCleanupInterval:  10 * time.Minute,
                SessionTimeout:            30 * time.Minute,
                SessionCleanupInterval:    5 * time.Minute,
                MaxActiveSessions:         10,
                SessionCookieName:         "session_id",
                SessionSecure:             true,
                SessionHttpOnly:           true,
                SessionSameSite:           http.SameSiteStrictMode,
                BlacklistEnabled:          true,
                BlacklistCheckInterval:    5 * time.Minute,
                WhitelistEnabled:          false,
                APIKeyEnabled:             true,
                APIKeyHeaders:             []string{"X-API-Key", "Authorization"},
                APIKeyQueryParam:          "api_key",
                APIKeyHashAlgorithm:       "sha256",
                AuditEnabled:              true,
                AuditLogSensitiveData:     false,
                AuditBufferSize:           1000,
                AuditFlushInterval:        30 * time.Second,
                CircuitBreakerEnabled:     true,
                CircuitBreakerThreshold:   5,
                CircuitBreakerTimeout:     30 * time.Second,
                CircuitBreakerReset:       60 * time.Second,
                MetricsEnabled:            true,
                MetricsCollectionInterval: 30 * time.Second,
                MetricsRetentionPeriod:    24 * time.Hour,
                CORSEnabled:               true,
                CORSAllowedOrigins:        []string{"*"},
                CORSAllowedMethods:        []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                CORSAllowedHeaders:        []string{"Content-Type", "Authorization", "X-API-Key"},
                CORSExposedHeaders:        []string{"X-Total-Count", "X-Request-ID"},
                CORSAllowCredentials:      true,
                CORSMaxAge:                24 * time.Hour,
                SecurityHeaders: map[string]string{
                        "X-Frame-Options":        "DENY",
                        "X-Content-Type-Options": "nosniff",
                        "X-XSS-Protection":       "1; mode=block",
                        "Referrer-Policy":        "strict-origin-when-cross-origin",
                        "Permissions-Policy":     "geolocation=(), microphone=(), camera=()",
                },
                EnableCSP: true,
                CSPDirectives: map[string]string{
                        "default-src": "'self'",
                        "script-src":  "'self' 'unsafe-inline'",
                        "style-src":   "'self' 'unsafe-inline'",
                        "img-src":     "'self' data: https:",
                        "font-src":    "'self'",
                        "connect-src": "'self'",
                        "frame-src":   "'none'",
                        "object-src":  "'none'",
                        "base-uri":    "'self'",
                        "form-action": "'self'",
                },
                EnableHSTS:            true,
                HSTSMaxAge:            365 * 24 * time.Hour,
                HSTSIncludeSubdomains: true,
                HSTSPreload:           true,
        }
}</span>

// RateLimiter implements per-user and per-IP rate limiting
type RateLimiter struct {
        userLimits map[string]*UserRateLimit
        ipLimits   map[string]*IPRateLimit
        mu         sync.RWMutex
        config     *AuthMiddlewareConfig
        logger     *slog.Logger
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
}

// UserRateLimit tracks rate limiting for a specific user
type UserRateLimit struct {
        UserID       uuid.UUID
        RequestCount int
        LastReset    time.Time
        BurstUsed    int
        LastRequest  time.Time
        Blocked      bool
        BlockedUntil time.Time
}

// IPRateLimit tracks rate limiting for a specific IP
type IPRateLimit struct {
        IP           string
        RequestCount int
        LastReset    time.Time
        BurstUsed    int
        LastRequest  time.Time
        Blocked      bool
        BlockedUntil time.Time
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(config *AuthMiddlewareConfig, logger *slog.Logger) *RateLimiter <span class="cov7" title="15">{
        ctx, cancel := context.WithCancel(context.Background())

        rl := &amp;RateLimiter{
                userLimits: make(map[string]*UserRateLimit),
                ipLimits:   make(map[string]*IPRateLimit),
                config:     config,
                logger:     logger,
                ctx:        ctx,
                cancel:     cancel,
        }

        // Start cleanup goroutine
        if config.RateLimitEnabled </span><span class="cov7" title="15">{
                rl.wg.Add(1)
                go rl.cleanupExpiredLimits()
        }</span>

        <span class="cov7" title="15">return rl</span>
}

// Close shuts down the rate limiter
func (rl *RateLimiter) Close() <span class="cov7" title="15">{
        rl.cancel()
        rl.wg.Wait()
}</span>

// CheckUserRateLimit checks if a user is rate limited
func (rl *RateLimiter) CheckUserRateLimit(userID uuid.UUID) bool <span class="cov6" title="8">{
        if !rl.config.RateLimitEnabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="8">rl.mu.Lock()
        defer rl.mu.Unlock()

        key := userID.String()
        now := time.Now()

        limit, exists := rl.userLimits[key]
        if !exists </span><span class="cov1" title="1">{
                limit = &amp;UserRateLimit{
                        UserID:       userID,
                        RequestCount: 0,
                        LastReset:    now,
                        BurstUsed:    0,
                        LastRequest:  now,
                }
                rl.userLimits[key] = limit
        }</span>

        // Check if user is currently blocked
        <span class="cov6" title="8">if limit.Blocked &amp;&amp; now.Before(limit.BlockedUntil) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Reset window if needed
        <span class="cov6" title="8">if now.Sub(limit.LastReset) &gt;= rl.config.RateLimitWindow </span><span class="cov0" title="0">{
                limit.RequestCount = 0
                limit.LastReset = now
                limit.BurstUsed = 0
                limit.Blocked = false
        }</span>

        // Check rate limit
        <span class="cov6" title="8">if limit.RequestCount &gt;= rl.config.RateLimitRequests </span><span class="cov3" title="3">{
                // Check burst allowance
                if limit.BurstUsed &gt;= rl.config.RateLimitBurst </span><span class="cov1" title="1">{
                        limit.Blocked = true
                        limit.BlockedUntil = now.Add(rl.config.RateLimitWindow)
                        return true
                }</span>
                <span class="cov2" title="2">limit.BurstUsed++</span>
        }

        <span class="cov5" title="7">limit.RequestCount++
        limit.LastRequest = now

        return false</span>
}

// CheckIPRateLimit checks if an IP is rate limited
func (rl *RateLimiter) CheckIPRateLimit(ip string) bool <span class="cov7" title="12">{
        if !rl.config.RateLimitEnabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="12">rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()

        limit, exists := rl.ipLimits[ip]
        if !exists </span><span class="cov3" title="3">{
                limit = &amp;IPRateLimit{
                        IP:           ip,
                        RequestCount: 0,
                        LastReset:    now,
                        BurstUsed:    0,
                        LastRequest:  now,
                }
                rl.ipLimits[ip] = limit
        }</span>

        // Check if IP is currently blocked
        <span class="cov7" title="12">if limit.Blocked &amp;&amp; now.Before(limit.BlockedUntil) </span><span class="cov1" title="1">{
                return true
        }</span>

        // Reset window if needed
        <span class="cov6" title="11">if now.Sub(limit.LastReset) &gt;= rl.config.RateLimitWindow </span><span class="cov0" title="0">{
                limit.RequestCount = 0
                limit.LastReset = now
                limit.BurstUsed = 0
                limit.Blocked = false
        }</span>

        // Check rate limit
        <span class="cov6" title="11">if limit.RequestCount &gt;= rl.config.RateLimitRequests </span><span class="cov3" title="3">{
                // Check burst allowance
                if limit.BurstUsed &gt;= rl.config.RateLimitBurst </span><span class="cov1" title="1">{
                        limit.Blocked = true
                        limit.BlockedUntil = now.Add(rl.config.RateLimitWindow)
                        return true
                }</span>
                <span class="cov2" title="2">limit.BurstUsed++</span>
        }

        <span class="cov6" title="10">limit.RequestCount++
        limit.LastRequest = now

        return false</span>
}

// cleanupExpiredLimits removes expired rate limit entries
func (rl *RateLimiter) cleanupExpiredLimits() <span class="cov7" title="15">{
        defer rl.wg.Done()

        ticker := time.NewTicker(rl.config.RateLimitCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov7" title="15">{
                select </span>{
                case &lt;-rl.ctx.Done():<span class="cov7" title="15">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rl.performCleanup()</span>
                }
        }
}

// performCleanup removes expired rate limit entries
func (rl *RateLimiter) performCleanup() <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        cutoff := now.Add(-2 * rl.config.RateLimitWindow)

        // Clean up user limits
        for key, limit := range rl.userLimits </span><span class="cov0" title="0">{
                if limit.LastRequest.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(rl.userLimits, key)
                }</span>
        }

        // Clean up IP limits
        <span class="cov0" title="0">for key, limit := range rl.ipLimits </span><span class="cov0" title="0">{
                if limit.LastRequest.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(rl.ipLimits, key)
                }</span>
        }
}

// GetRateLimitStats returns current rate limit statistics
func (rl *RateLimiter) GetRateLimitStats() map[string]interface{} <span class="cov1" title="1">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        stats := map[string]interface{}{
                "user_limits_count": len(rl.userLimits),
                "ip_limits_count":   len(rl.ipLimits),
                "blocked_users":     0,
                "blocked_ips":       0,
        }

        now := time.Now()
        blockedUsers := 0
        blockedIPs := 0

        for _, limit := range rl.userLimits </span><span class="cov0" title="0">{
                if limit.Blocked &amp;&amp; now.Before(limit.BlockedUntil) </span><span class="cov0" title="0">{
                        blockedUsers++
                }</span>
        }

        <span class="cov1" title="1">for _, limit := range rl.ipLimits </span><span class="cov0" title="0">{
                if limit.Blocked &amp;&amp; now.Before(limit.BlockedUntil) </span><span class="cov0" title="0">{
                        blockedIPs++
                }</span>
        }

        <span class="cov1" title="1">stats["blocked_users"] = blockedUsers
        stats["blocked_ips"] = blockedIPs

        return stats</span>
}

// BlacklistManager manages IP and user blacklists
type BlacklistManager struct {
        blacklistedIPs   map[string]time.Time
        blacklistedUsers map[uuid.UUID]time.Time
        whitelistedIPs   map[string]bool
        mu               sync.RWMutex
        config           *AuthMiddlewareConfig
        logger           *slog.Logger
        ctx              context.Context
        cancel           context.CancelFunc
        wg               sync.WaitGroup
}

// NewBlacklistManager creates a new blacklist manager
func NewBlacklistManager(config *AuthMiddlewareConfig, logger *slog.Logger) *BlacklistManager <span class="cov7" title="15">{
        ctx, cancel := context.WithCancel(context.Background())

        bm := &amp;BlacklistManager{
                blacklistedIPs:   make(map[string]time.Time),
                blacklistedUsers: make(map[uuid.UUID]time.Time),
                whitelistedIPs:   make(map[string]bool),
                config:           config,
                logger:           logger,
                ctx:              ctx,
                cancel:           cancel,
        }

        // Initialize whitelist
        for _, ip := range config.WhitelistIPs </span><span class="cov1" title="1">{
                bm.whitelistedIPs[ip] = true
        }</span>

        // Start cleanup goroutine
        <span class="cov7" title="15">if config.BlacklistEnabled </span><span class="cov7" title="15">{
                bm.wg.Add(1)
                go bm.cleanupExpiredBlacklist()
        }</span>

        <span class="cov7" title="15">return bm</span>
}

// Close shuts down the blacklist manager
func (bm *BlacklistManager) Close() <span class="cov7" title="15">{
        bm.cancel()
        bm.wg.Wait()
}</span>

// IsIPBlacklisted checks if an IP is blacklisted
func (bm *BlacklistManager) IsIPBlacklisted(ip string) bool <span class="cov5" title="7">{
        if !bm.config.BlacklistEnabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="7">bm.mu.RLock()
        defer bm.mu.RUnlock()

        // Check whitelist first
        if bm.config.WhitelistEnabled &amp;&amp; bm.whitelistedIPs[ip] </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="6">expiresAt, exists := bm.blacklistedIPs[ip]
        if !exists </span><span class="cov4" title="5">{
                return false
        }</span>

        <span class="cov1" title="1">return time.Now().Before(expiresAt)</span>
}

// IsUserBlacklisted checks if a user is blacklisted
func (bm *BlacklistManager) IsUserBlacklisted(userID uuid.UUID) bool <span class="cov3" title="3">{
        if !bm.config.BlacklistEnabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="3">bm.mu.RLock()
        defer bm.mu.RUnlock()

        expiresAt, exists := bm.blacklistedUsers[userID]
        if !exists </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov1" title="1">return time.Now().Before(expiresAt)</span>
}

// BlacklistIP adds an IP to the blacklist
func (bm *BlacklistManager) BlacklistIP(ip string, duration time.Duration) <span class="cov2" title="2">{
        bm.mu.Lock()
        defer bm.mu.Unlock()

        bm.blacklistedIPs[ip] = time.Now().Add(duration)
        bm.logger.Warn("IP blacklisted", "ip", ip, "duration", duration)
}</span>

// BlacklistUser adds a user to the blacklist
func (bm *BlacklistManager) BlacklistUser(userID uuid.UUID, duration time.Duration) <span class="cov1" title="1">{
        bm.mu.Lock()
        defer bm.mu.Unlock()

        bm.blacklistedUsers[userID] = time.Now().Add(duration)
        bm.logger.Warn("User blacklisted", "user_id", userID, "duration", duration)
}</span>

// RemoveIPFromBlacklist removes an IP from the blacklist
func (bm *BlacklistManager) RemoveIPFromBlacklist(ip string) <span class="cov1" title="1">{
        bm.mu.Lock()
        defer bm.mu.Unlock()

        delete(bm.blacklistedIPs, ip)
        bm.logger.Info("IP removed from blacklist", "ip", ip)
}</span>

// RemoveUserFromBlacklist removes a user from the blacklist
func (bm *BlacklistManager) RemoveUserFromBlacklist(userID uuid.UUID) <span class="cov1" title="1">{
        bm.mu.Lock()
        defer bm.mu.Unlock()

        delete(bm.blacklistedUsers, userID)
        bm.logger.Info("User removed from blacklist", "user_id", userID)
}</span>

// cleanupExpiredBlacklist removes expired blacklist entries
func (bm *BlacklistManager) cleanupExpiredBlacklist() <span class="cov7" title="15">{
        defer bm.wg.Done()

        ticker := time.NewTicker(bm.config.BlacklistCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov7" title="15">{
                select </span>{
                case &lt;-bm.ctx.Done():<span class="cov7" title="15">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        bm.performBlacklistCleanup()</span>
                }
        }
}

// performBlacklistCleanup removes expired blacklist entries
func (bm *BlacklistManager) performBlacklistCleanup() <span class="cov0" title="0">{
        bm.mu.Lock()
        defer bm.mu.Unlock()

        now := time.Now()

        // Clean up expired IP blacklists
        for ip, expiresAt := range bm.blacklistedIPs </span><span class="cov0" title="0">{
                if now.After(expiresAt) </span><span class="cov0" title="0">{
                        delete(bm.blacklistedIPs, ip)
                        bm.logger.Info("IP blacklist expired", "ip", ip)
                }</span>
        }

        // Clean up expired user blacklists
        <span class="cov0" title="0">for userID, expiresAt := range bm.blacklistedUsers </span><span class="cov0" title="0">{
                if now.After(expiresAt) </span><span class="cov0" title="0">{
                        delete(bm.blacklistedUsers, userID)
                        bm.logger.Info("User blacklist expired", "user_id", userID)
                }</span>
        }
}

// GetBlacklistStats returns current blacklist statistics
func (bm *BlacklistManager) GetBlacklistStats() map[string]interface{} <span class="cov1" title="1">{
        bm.mu.RLock()
        defer bm.mu.RUnlock()

        return map[string]interface{}{
                "blacklisted_ips":   len(bm.blacklistedIPs),
                "blacklisted_users": len(bm.blacklistedUsers),
                "whitelisted_ips":   len(bm.whitelistedIPs),
        }
}</span>

// SessionManager manages user sessions
type SessionManager struct {
        sessions map[string]*AuthSession
        mu       sync.RWMutex
        config   *AuthMiddlewareConfig
        logger   *slog.Logger
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
}

// AuthSession represents an authentication session
type AuthSession struct {
        ID           string
        UserID       uuid.UUID
        CreatedAt    time.Time
        LastActivity time.Time
        IPAddress    string
        UserAgent    string
        IsActive     bool
        ExpiresAt    time.Time
        Data         map[string]interface{}
}

// NewSessionManager creates a new session manager
func NewSessionManager(config *AuthMiddlewareConfig, logger *slog.Logger) *SessionManager <span class="cov7" title="15">{
        ctx, cancel := context.WithCancel(context.Background())

        sm := &amp;SessionManager{
                sessions: make(map[string]*AuthSession),
                config:   config,
                logger:   logger,
                ctx:      ctx,
                cancel:   cancel,
        }

        // Start cleanup goroutine
        sm.wg.Add(1)
        go sm.cleanupExpiredSessions()

        return sm
}</span>

// Close shuts down the session manager
func (sm *SessionManager) Close() <span class="cov7" title="15">{
        sm.cancel()
        sm.wg.Wait()
}</span>

// CreateSession creates a new session
func (sm *SessionManager) CreateSession(userID uuid.UUID, ipAddress, userAgent string) (*AuthSession, error) <span class="cov3" title="3">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Check if user has exceeded max active sessions
        activeSessions := 0
        for _, session := range sm.sessions </span><span class="cov3" title="3">{
                if session.UserID == userID &amp;&amp; session.IsActive &amp;&amp; time.Now().Before(session.ExpiresAt) </span><span class="cov3" title="3">{
                        activeSessions++
                }</span>
        }

        <span class="cov3" title="3">if activeSessions &gt;= sm.config.MaxActiveSessions </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("maximum active sessions exceeded")
        }</span>

        <span class="cov2" title="2">sessionID := uuid.New().String()
        now := time.Now()

        session := &amp;AuthSession{
                ID:           sessionID,
                UserID:       userID,
                CreatedAt:    now,
                LastActivity: now,
                IPAddress:    ipAddress,
                UserAgent:    userAgent,
                IsActive:     true,
                ExpiresAt:    now.Add(sm.config.SessionTimeout),
                Data:         make(map[string]interface{}),
        }

        sm.sessions[sessionID] = session

        return session, nil</span>
}

// GetSession retrieves a session by ID
func (sm *SessionManager) GetSession(sessionID string) (*AuthSession, bool) <span class="cov4" title="4">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        session, exists := sm.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if session is expired
        <span class="cov4" title="4">if time.Now().After(session.ExpiresAt) </span><span class="cov2" title="2">{
                return nil, false
        }</span>

        <span class="cov2" title="2">return session, true</span>
}

// UpdateSessionActivity updates the last activity time for a session
func (sm *SessionManager) UpdateSessionActivity(sessionID string) <span class="cov1" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        session, exists := sm.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">session.LastActivity = time.Now()
        session.ExpiresAt = time.Now().Add(sm.config.SessionTimeout)</span>
}

// InvalidateSession invalidates a session
func (sm *SessionManager) InvalidateSession(sessionID string) <span class="cov1" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        session, exists := sm.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">session.IsActive = false
        session.ExpiresAt = time.Now()</span>
}

// InvalidateUserSessions invalidates all sessions for a user
func (sm *SessionManager) InvalidateUserSessions(userID uuid.UUID) <span class="cov1" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        for _, session := range sm.sessions </span><span class="cov2" title="2">{
                if session.UserID == userID </span><span class="cov2" title="2">{
                        session.IsActive = false
                        session.ExpiresAt = time.Now()
                }</span>
        }
}

// cleanupExpiredSessions removes expired sessions
func (sm *SessionManager) cleanupExpiredSessions() <span class="cov7" title="15">{
        defer sm.wg.Done()

        ticker := time.NewTicker(sm.config.SessionCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov7" title="15">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov7" title="15">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.performSessionCleanup()</span>
                }
        }
}

// performSessionCleanup removes expired sessions
func (sm *SessionManager) performSessionCleanup() <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        now := time.Now()

        for sessionID, session := range sm.sessions </span><span class="cov0" title="0">{
                if now.After(session.ExpiresAt) </span><span class="cov0" title="0">{
                        delete(sm.sessions, sessionID)
                }</span>
        }
}

// GetSessionStats returns current session statistics
func (sm *SessionManager) GetSessionStats() map[string]interface{} <span class="cov1" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        activeSessions := 0
        expiredSessions := 0
        now := time.Now()

        for _, session := range sm.sessions </span><span class="cov0" title="0">{
                if session.IsActive &amp;&amp; now.Before(session.ExpiresAt) </span><span class="cov0" title="0">{
                        activeSessions++
                }</span> else<span class="cov0" title="0"> {
                        expiredSessions++
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "total_sessions":   len(sm.sessions),
                "active_sessions":  activeSessions,
                "expired_sessions": expiredSessions,
        }</span>
}

// AuthMetricsCollector collects authentication metrics
type AuthMetricsCollector struct {
        metrics map[string]int64
        mu      sync.RWMutex
        config  *AuthMiddlewareConfig
        logger  *slog.Logger
        ctx     context.Context
        cancel  context.CancelFunc
        wg      sync.WaitGroup
}

// NewAuthMetricsCollector creates a new metrics collector
func NewAuthMetricsCollector(config *AuthMiddlewareConfig, logger *slog.Logger) *AuthMetricsCollector <span class="cov7" title="15">{
        ctx, cancel := context.WithCancel(context.Background())

        mc := &amp;AuthMetricsCollector{
                metrics: make(map[string]int64),
                config:  config,
                logger:  logger,
                ctx:     ctx,
                cancel:  cancel,
        }

        // Start metrics collection goroutine
        if config.MetricsEnabled </span><span class="cov7" title="15">{
                mc.wg.Add(1)
                go mc.collectMetrics()
        }</span>

        <span class="cov7" title="15">return mc</span>
}

// Close shuts down the metrics collector
func (mc *AuthMetricsCollector) Close() <span class="cov7" title="15">{
        mc.cancel()
        mc.wg.Wait()
}</span>

// IncrementCounter increments a counter metric
func (mc *AuthMetricsCollector) IncrementCounter(name string) <span class="cov5" title="7">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        mc.metrics[name]++
}</span>

// RecordAuth records an authentication event
func (mc *AuthMetricsCollector) RecordAuth(authType, result string) <span class="cov3" title="3">{
        mc.IncrementCounter(fmt.Sprintf("auth_%s_%s", authType, result))
}</span>

// RecordRateLimit records a rate limit event
func (mc *AuthMetricsCollector) RecordRateLimit(limitType string) <span class="cov2" title="2">{
        mc.IncrementCounter(fmt.Sprintf("rate_limit_%s", limitType))
}</span>

// RecordBlacklist records a blacklist event
func (mc *AuthMetricsCollector) RecordBlacklist(listType, action string) <span class="cov0" title="0">{
        mc.IncrementCounter(fmt.Sprintf("blacklist_%s_%s", listType, action))
}</span>

// GetMetrics returns current metrics
func (mc *AuthMetricsCollector) GetMetrics() map[string]int64 <span class="cov4" title="4">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := make(map[string]int64)
        for k, v := range mc.metrics </span><span class="cov6" title="11">{
                metrics[k] = v
        }</span>

        <span class="cov4" title="4">return metrics</span>
}

// collectMetrics collects and logs metrics periodically
func (mc *AuthMetricsCollector) collectMetrics() <span class="cov7" title="15">{
        defer mc.wg.Done()

        ticker := time.NewTicker(mc.config.MetricsCollectionInterval)
        defer ticker.Stop()

        for </span><span class="cov7" title="15">{
                select </span>{
                case &lt;-mc.ctx.Done():<span class="cov7" title="15">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mc.logMetrics()</span>
                }
        }
}

// logMetrics logs current metrics
func (mc *AuthMetricsCollector) logMetrics() <span class="cov0" title="0">{
        metrics := mc.GetMetrics()

        mc.logger.Info("Authentication metrics",
                "metrics_count", len(metrics),
                "metrics", metrics,
        )
}</span>

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(
        authService *infrastructure.AuthenticationService,
        circuitBreaker *infrastructure.CircuitBreaker,
        logger *slog.Logger,
        config *AuthMiddlewareConfig,
) *AuthMiddleware <span class="cov7" title="14">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultAuthMiddlewareConfig()
        }</span>

        <span class="cov7" title="14">return &amp;AuthMiddleware{
                authService:      authService,
                rateLimiter:      NewRateLimiter(config, logger),
                circuitBreaker:   circuitBreaker,
                metricsCollector: NewAuthMetricsCollector(config, logger),
                blacklist:        NewBlacklistManager(config, logger),
                sessionManager:   NewSessionManager(config, logger),
                logger:           logger,
                config:           config,
        }</span>
}

// Close shuts down the authentication middleware
func (am *AuthMiddleware) Close() <span class="cov7" title="14">{
        am.rateLimiter.Close()
        am.blacklist.Close()
        am.sessionManager.Close()
        am.metricsCollector.Close()
}</span>

// AuthenticationMiddleware is the main authentication middleware
func (am *AuthMiddleware) AuthenticationMiddleware(next http.Handler) http.Handler <span class="cov4" title="5">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="4">{
                ctx := r.Context()

                // Add security headers
                am.addSecurityHeaders(w)

                // Handle CORS if enabled
                if am.config.CORSEnabled </span><span class="cov4" title="4">{
                        am.handleCORS(w, r)
                        if r.Method == http.MethodOptions </span><span class="cov1" title="1">{
                                return
                        }</span>
                }

                // Get client IP
                <span class="cov3" title="3">clientIP := am.getClientIP(r)

                // Check IP blacklist
                if am.blacklist.IsIPBlacklisted(clientIP) </span><span class="cov0" title="0">{
                        am.metricsCollector.RecordBlacklist("ip", "blocked")
                        am.writeErrorResponse(w, http.StatusForbidden, "IP address is blacklisted", "")
                        return
                }</span>

                // Check IP rate limit
                <span class="cov3" title="3">if am.rateLimiter.CheckIPRateLimit(clientIP) </span><span class="cov0" title="0">{
                        am.metricsCollector.RecordRateLimit("ip")
                        am.writeErrorResponse(w, http.StatusTooManyRequests, "Rate limit exceeded", "")
                        return
                }</span>

                // Try to authenticate the request
                <span class="cov3" title="3">user, authType, err := am.authenticateRequest(r)
                if err != nil </span><span class="cov0" title="0">{
                        am.metricsCollector.RecordAuth(authType, "failed")
                        am.logger.Warn("Authentication failed", "error", err, "ip", clientIP, "user_agent", r.Header.Get("User-Agent"))
                        am.writeErrorResponse(w, http.StatusUnauthorized, "Authentication failed", err.Error())
                        return
                }</span>

                // If user is authenticated, check user-specific limits
                <span class="cov3" title="3">if user != nil </span><span class="cov0" title="0">{
                        // Check user blacklist
                        if am.blacklist.IsUserBlacklisted(user.ID) </span><span class="cov0" title="0">{
                                am.metricsCollector.RecordBlacklist("user", "blocked")
                                am.writeErrorResponse(w, http.StatusForbidden, "User is blacklisted", "")
                                return
                        }</span>

                        // Check user rate limit
                        <span class="cov0" title="0">if am.rateLimiter.CheckUserRateLimit(user.ID) </span><span class="cov0" title="0">{
                                am.metricsCollector.RecordRateLimit("user")
                                am.writeErrorResponse(w, http.StatusTooManyRequests, "User rate limit exceeded", "")
                                return
                        }</span>

                        // Add user to context
                        <span class="cov0" title="0">ctx = context.WithValue(ctx, "user", user)
                        ctx = context.WithValue(ctx, "user_id", user.ID)
                        ctx = context.WithValue(ctx, "user_email", user.Email)

                        am.metricsCollector.RecordAuth(authType, "success")</span>
                }

                // Add authentication metadata to context
                <span class="cov3" title="3">ctx = context.WithValue(ctx, "auth_type", authType)
                ctx = context.WithValue(ctx, "client_ip", clientIP)
                ctx = context.WithValue(ctx, "request_id", uuid.New().String())

                // Continue to next handler
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// authenticateRequest attempts to authenticate the request using various methods
func (am *AuthMiddleware) authenticateRequest(r *http.Request) (*domain.User, string, error) <span class="cov3" title="3">{
        // Try JWT authentication first
        if user, err := am.authenticateJWT(r); err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                return user, "jwt", nil
        }</span>

        // Try API key authentication
        <span class="cov3" title="3">if user, err := am.authenticateAPIKey(r); err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                return user, "apikey", nil
        }</span>

        // Try session authentication
        <span class="cov3" title="3">if user, err := am.authenticateSession(r); err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                return user, "session", nil
        }</span>

        // No authentication found - this might be okay for optional auth endpoints
        <span class="cov3" title="3">return nil, "none", nil</span>
}

// authenticateJWT authenticates using JWT token
func (am *AuthMiddleware) authenticateJWT(r *http.Request) (*domain.User, error) <span class="cov3" title="3">{
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("no authorization header")
        }</span>

        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid authorization header format")
        }</span>

        <span class="cov0" title="0">token := parts[1]
        if token == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty token")
        }</span>

        // Use circuit breaker for JWT validation
        <span class="cov0" title="0">if am.config.CircuitBreakerEnabled </span><span class="cov0" title="0">{
                result, err := am.circuitBreaker.Execute(r.Context(), func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        return am.authService.ValidateToken(ctx, token)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result.(*domain.User), nil</span>
        }

        <span class="cov0" title="0">return am.authService.ValidateToken(r.Context(), token)</span>
}

// authenticateAPIKey authenticates using API key
func (am *AuthMiddleware) authenticateAPIKey(r *http.Request) (*domain.User, error) <span class="cov3" title="3">{
        if !am.config.APIKeyEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key authentication disabled")
        }</span>

        <span class="cov3" title="3">var apiKey string

        // Try headers first
        for _, header := range am.config.APIKeyHeaders </span><span class="cov5" title="6">{
                if key := r.Header.Get(header); key != "" </span><span class="cov0" title="0">{
                        apiKey = key
                        break</span>
                }
        }

        // Try query parameter if no header found
        <span class="cov3" title="3">if apiKey == "" &amp;&amp; am.config.APIKeyQueryParam != "" </span><span class="cov3" title="3">{
                apiKey = r.URL.Query().Get(am.config.APIKeyQueryParam)
        }</span>

        <span class="cov3" title="3">if apiKey == "" </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("no API key found")
        }</span>

        // Use circuit breaker for API key validation
        <span class="cov0" title="0">if am.config.CircuitBreakerEnabled </span><span class="cov0" title="0">{
                result, err := am.circuitBreaker.Execute(r.Context(), func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        return am.authService.ValidateApiKey(ctx, apiKey)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">apiKeyData := result.(*domain.ApiKey)
                // Get the user associated with the API key
                return am.authService.GetUser(r.Context(), apiKeyData.UserID)</span>
        }

        <span class="cov0" title="0">apiKeyData, err := am.authService.ValidateApiKey(r.Context(), apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return am.authService.GetUser(r.Context(), apiKeyData.UserID)</span>
}

// authenticateSession authenticates using session
func (am *AuthMiddleware) authenticateSession(r *http.Request) (*domain.User, error) <span class="cov3" title="3">{
        // Try session cookie
        cookie, err := r.Cookie(am.config.SessionCookieName)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("no session cookie")
        }</span>

        <span class="cov0" title="0">session, exists := am.sessionManager.GetSession(cookie.Value)
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid session")
        }</span>

        // Update session activity
        <span class="cov0" title="0">am.sessionManager.UpdateSessionActivity(cookie.Value)

        // Get user
        return am.authService.GetUser(r.Context(), session.UserID)</span>
}

// RequireAuthentication middleware that requires authentication
func (am *AuthMiddleware) RequireAuthentication(next http.Handler) http.Handler <span class="cov2" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                user, ok := r.Context().Value("user").(*domain.User)
                if !ok || user == nil </span><span class="cov0" title="0">{
                        am.writeErrorResponse(w, http.StatusUnauthorized, "Authentication required", "")
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// RequirePermission middleware that requires specific permissions
func (am *AuthMiddleware) RequirePermission(resource, action string) func(http.Handler) http.Handler <span class="cov5" title="6">{
        return func(next http.Handler) http.Handler </span><span class="cov5" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        user, ok := r.Context().Value("user").(*domain.User)
                        if !ok || user == nil </span><span class="cov0" title="0">{
                                am.writeErrorResponse(w, http.StatusUnauthorized, "Authentication required", "")
                                return
                        }</span>

                        <span class="cov0" title="0">hasPermission, err := am.authService.CheckPermission(r.Context(), user.ID, resource, action)
                        if err != nil </span><span class="cov0" title="0">{
                                am.logger.Error("Permission check failed", "error", err, "user_id", user.ID, "resource", resource, "action", action)
                                am.writeErrorResponse(w, http.StatusInternalServerError, "Permission check failed", "")
                                return
                        }</span>

                        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                                am.logger.Warn("Permission denied", "user_id", user.ID, "resource", resource, "action", action)
                                am.writeErrorResponse(w, http.StatusForbidden, "Insufficient permissions", "")
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireRole middleware that requires specific roles
func (am *AuthMiddleware) RequireRole(roles ...string) func(http.Handler) http.Handler <span class="cov4" title="5">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="5">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="3">{
                        user, ok := r.Context().Value("user").(*domain.User)
                        if !ok || user == nil </span><span class="cov0" title="0">{
                                am.writeErrorResponse(w, http.StatusUnauthorized, "Authentication required", "")
                                return
                        }</span>

                        // Check if user has any of the required roles
                        <span class="cov3" title="3">hasRole := false
                        userRoles := make(map[string]bool)
                        for _, role := range user.Roles </span><span class="cov5" title="6">{
                                userRoles[role.Name] = true
                        }</span>

                        <span class="cov3" title="3">for _, requiredRole := range roles </span><span class="cov4" title="4">{
                                if userRoles[requiredRole] </span><span class="cov2" title="2">{
                                        hasRole = true
                                        break</span>
                                }
                        }

                        <span class="cov3" title="3">if !hasRole </span><span class="cov1" title="1">{
                                am.logger.Warn("Role check failed", "user_id", user.ID, "required_roles", roles, "user_roles", userRoles)
                                am.writeErrorResponse(w, http.StatusForbidden, "Insufficient role permissions", "")
                                return
                        }</span>

                        <span class="cov2" title="2">next.ServeHTTP(w, r)</span>
                })
        }
}

// OptionalAuthentication middleware that provides optional authentication
func (am *AuthMiddleware) OptionalAuthentication(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                // Try to authenticate, but don't fail if it doesn't work
                user, authType, _ := am.authenticateRequest(r)
                if user != nil </span><span class="cov0" title="0">{
                        ctx = context.WithValue(ctx, "user", user)
                        ctx = context.WithValue(ctx, "user_id", user.ID)
                        ctx = context.WithValue(ctx, "user_email", user.Email)
                        ctx = context.WithValue(ctx, "auth_type", authType)
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// AuditMiddleware logs authentication events
func (am *AuthMiddleware) AuditMiddleware(next http.Handler) http.Handler <span class="cov3" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !am.config.AuditEnabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()

                // Create a response writer that captures the status code
                wrappedWriter := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                // Process request
                next.ServeHTTP(wrappedWriter, r)

                // Log audit information asynchronously
                go am.logAuditEvent(r, wrappedWriter.statusCode, time.Since(start))</span>
        })
}

// logAuditEvent logs an audit event
func (am *AuthMiddleware) logAuditEvent(r *http.Request, statusCode int, duration time.Duration) <span class="cov0" title="0">{
        ctx := context.Background()

        var userID *uuid.UUID
        if user, ok := r.Context().Value("user").(*domain.User); ok </span><span class="cov0" title="0">{
                userID = &amp;user.ID
        }</span>

        <span class="cov0" title="0">authType, _ := r.Context().Value("auth_type").(string)
        clientIP := am.getClientIP(r)
        requestID, _ := r.Context().Value("request_id").(string)

        // Build audit data
        auditData := map[string]interface{}{
                "method":      r.Method,
                "path":        r.URL.Path,
                "status_code": statusCode,
                "duration_ms": duration.Milliseconds(),
                "auth_type":   authType,
                "client_ip":   clientIP,
                "user_agent":  r.Header.Get("User-Agent"),
                "request_id":  requestID,
                "timestamp":   time.Now().UTC().Format(time.RFC3339),
        }

        // Add query parameters if not sensitive
        if !am.config.AuditLogSensitiveData </span><span class="cov0" title="0">{
                auditData["query_params"] = r.URL.Query()
        }</span>

        // Determine resource and action
        <span class="cov0" title="0">resource, action := am.extractResourceAndAction(r.URL.Path, r.Method)

        // Log audit event
        err := am.authService.AuditAction(
                ctx,
                userID,
                action,
                resource,
                nil,       // resourceID
                nil,       // oldValues
                auditData, // newValues
                clientIP,
                r.Header.Get("User-Agent"),
        )

        if err != nil </span><span class="cov0" title="0">{
                am.logger.Error("Audit logging failed", "error", err)
        }</span>
}

// Helper methods

// getClientIP extracts the client IP address from the request
func (am *AuthMiddleware) getClientIP(r *http.Request) string <span class="cov6" title="8">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov2" title="2">{
                // Take the first IP in the chain
                ips := strings.Split(xff, ",")
                clientIP := strings.TrimSpace(ips[0])

                // Validate that it's from a trusted proxy
                if am.isTrustedProxy(r.RemoteAddr) </span><span class="cov1" title="1">{
                        return clientIP
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov5" title="7">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov1" title="1">{
                if am.isTrustedProxy(r.RemoteAddr) </span><span class="cov1" title="1">{
                        return xri
                }</span>
        }

        // Check CF-Connecting-IP header (Cloudflare)
        <span class="cov5" title="6">if cfIP := r.Header.Get("CF-Connecting-IP"); cfIP != "" </span><span class="cov1" title="1">{
                if am.isTrustedProxy(r.RemoteAddr) </span><span class="cov1" title="1">{
                        return cfIP
                }</span>
        }

        // Fall back to RemoteAddr
        <span class="cov4" title="5">host, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                return r.RemoteAddr
        }</span>
        <span class="cov4" title="5">return host</span>
}

// isTrustedProxy checks if the IP is a trusted proxy
func (am *AuthMiddleware) isTrustedProxy(remoteAddr string) bool <span class="cov4" title="4">{
        host, _, err := net.SplitHostPort(remoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                host = remoteAddr
        }</span>

        <span class="cov4" title="4">for _, trustedProxy := range am.config.TrustedProxies </span><span class="cov5" title="6">{
                if host == trustedProxy </span><span class="cov3" title="3">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// addSecurityHeaders adds security headers to the response
func (am *AuthMiddleware) addSecurityHeaders(w http.ResponseWriter) <span class="cov4" title="4">{
        // Add configured security headers
        for header, value := range am.config.SecurityHeaders </span><span class="cov7" title="17">{
                w.Header().Set(header, value)
        }</span>

        // Add Content Security Policy
        <span class="cov4" title="4">if am.config.EnableCSP </span><span class="cov4" title="4">{
                cspValue := am.buildCSPHeader()
                w.Header().Set("Content-Security-Policy", cspValue)
        }</span>

        // Add HSTS header
        <span class="cov4" title="4">if am.config.EnableHSTS </span><span class="cov4" title="4">{
                hstsValue := am.buildHSTSHeader()
                w.Header().Set("Strict-Transport-Security", hstsValue)
        }</span>
}

// buildCSPHeader builds the Content Security Policy header value
func (am *AuthMiddleware) buildCSPHeader() string <span class="cov4" title="4">{
        var directives []string

        // Sort directives for consistent output
        var keys []string
        for key := range am.config.CSPDirectives </span><span class="cov10" title="40">{
                keys = append(keys, key)
        }</span>
        <span class="cov4" title="4">sort.Strings(keys)

        for _, key := range keys </span><span class="cov10" title="40">{
                directives = append(directives, fmt.Sprintf("%s %s", key, am.config.CSPDirectives[key]))
        }</span>

        <span class="cov4" title="4">return strings.Join(directives, "; ")</span>
}

// buildHSTSHeader builds the HSTS header value
func (am *AuthMiddleware) buildHSTSHeader() string <span class="cov4" title="4">{
        maxAge := int(am.config.HSTSMaxAge.Seconds())
        hstsValue := fmt.Sprintf("max-age=%d", maxAge)

        if am.config.HSTSIncludeSubdomains </span><span class="cov4" title="4">{
                hstsValue += "; includeSubDomains"
        }</span>

        <span class="cov4" title="4">if am.config.HSTSPreload </span><span class="cov4" title="4">{
                hstsValue += "; preload"
        }</span>

        <span class="cov4" title="4">return hstsValue</span>
}

// handleCORS handles CORS preflight and actual requests
func (am *AuthMiddleware) handleCORS(w http.ResponseWriter, r *http.Request) <span class="cov4" title="4">{
        origin := r.Header.Get("Origin")

        // Check if origin is allowed
        if !am.isOriginAllowed(origin) </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov2" title="2">w.Header().Set("Access-Control-Allow-Origin", origin)

        if am.config.CORSAllowCredentials </span><span class="cov2" title="2">{
                w.Header().Set("Access-Control-Allow-Credentials", "true")
        }</span>

        // Handle preflight request
        <span class="cov2" title="2">if r.Method == http.MethodOptions </span><span class="cov1" title="1">{
                w.Header().Set("Access-Control-Allow-Methods", strings.Join(am.config.CORSAllowedMethods, ", "))
                w.Header().Set("Access-Control-Allow-Headers", strings.Join(am.config.CORSAllowedHeaders, ", "))
                w.Header().Set("Access-Control-Max-Age", strconv.Itoa(int(am.config.CORSMaxAge.Seconds())))
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        // Handle actual request
        <span class="cov1" title="1">if len(am.config.CORSExposedHeaders) &gt; 0 </span><span class="cov1" title="1">{
                w.Header().Set("Access-Control-Expose-Headers", strings.Join(am.config.CORSExposedHeaders, ", "))
        }</span>
}

// isOriginAllowed checks if the origin is allowed
func (am *AuthMiddleware) isOriginAllowed(origin string) bool <span class="cov4" title="4">{
        if origin == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="3">for _, allowedOrigin := range am.config.CORSAllowedOrigins </span><span class="cov3" title="3">{
                if allowedOrigin == "*" || allowedOrigin == origin </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// extractResourceAndAction extracts resource and action from URL path and method
func (am *AuthMiddleware) extractResourceAndAction(path, method string) (string, string) <span class="cov4" title="4">{
        // Remove leading/trailing slashes and split
        path = strings.Trim(path, "/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return "unknown", strings.ToLower(method)
        }</span>

        // Skip "api" and "v1" parts and get the resource name
        <span class="cov4" title="4">resource := parts[2]
        // parts[3] would be the resource ID (e.g., "123"), not the resource name
        // so we keep parts[2] as the resource name

        // Map HTTP methods to actions
        actionMap := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "PUT":    "update",
                "PATCH":  "update",
                "DELETE": "delete",
        }

        action := actionMap[strings.ToUpper(method)]
        if action == "" </span><span class="cov0" title="0">{
                action = strings.ToLower(method)
        }</span>

        <span class="cov4" title="4">return resource, action</span>
}

// writeErrorResponse writes an error response
func (am *AuthMiddleware) writeErrorResponse(w http.ResponseWriter, statusCode int, message, details string) <span class="cov2" title="2">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        response := map[string]interface{}{
                "error": message,
                "code":  statusCode,
                "time":  time.Now().UTC().Format(time.RFC3339),
        }

        if details != "" </span><span class="cov1" title="1">{
                response["details"] = details
        }</span>

        <span class="cov2" title="2">requestID, _ := w.Header()["request_id"]
        if len(requestID) &gt; 0 </span><span class="cov0" title="0">{
                response["request_id"] = requestID[0]
        }</span>

        <span class="cov2" title="2">if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                // Log encoding error but don't return since we've already set status
                logger := am.logger
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to encode JSON response", "error", err)
                }</span>
        }
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// AuthMiddlewareChain provides convenient middleware chaining
type AuthMiddlewareChain struct {
        middleware *AuthMiddleware
}

// NewAuthMiddlewareChain creates a new middleware chain
func NewAuthMiddlewareChain(middleware *AuthMiddleware) *AuthMiddlewareChain <span class="cov2" title="2">{
        return &amp;AuthMiddlewareChain{middleware: middleware}
}</span>

// ForPublicEndpoints applies middleware for public endpoints
func (c *AuthMiddlewareChain) ForPublicEndpoints() func(http.Handler) http.Handler <span class="cov2" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov1" title="1">{
                return c.middleware.AuditMiddleware(
                        c.middleware.OptionalAuthentication(
                                c.middleware.AuthenticationMiddleware(next),
                        ),
                )
        }</span>
}

// ForProtectedEndpoints applies middleware for protected endpoints
func (c *AuthMiddlewareChain) ForProtectedEndpoints() func(http.Handler) http.Handler <span class="cov3" title="3">{
        return func(next http.Handler) http.Handler </span><span class="cov1" title="1">{
                return c.middleware.AuditMiddleware(
                        c.middleware.RequireAuthentication(
                                c.middleware.AuthenticationMiddleware(next),
                        ),
                )
        }</span>
}

// ForAdminEndpoints applies middleware for admin endpoints
func (c *AuthMiddlewareChain) ForAdminEndpoints() func(http.Handler) http.Handler <span class="cov2" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov1" title="1">{
                return c.middleware.AuditMiddleware(
                        c.middleware.RequireRole("admin")(
                                c.middleware.RequireAuthentication(
                                        c.middleware.AuthenticationMiddleware(next),
                                ),
                        ),
                )
        }</span>
}

// WithPermission adds permission requirement to middleware chain
func (c *AuthMiddlewareChain) WithPermission(resource, action string) func(http.Handler) http.Handler <span class="cov4" title="5">{
        return c.middleware.RequirePermission(resource, action)
}</span>

// WithRole adds role requirement to middleware chain
func (c *AuthMiddlewareChain) WithRole(roles ...string) func(http.Handler) http.Handler <span class="cov1" title="1">{
        return c.middleware.RequireRole(roles...)
}</span>

// SetupRoutes demonstrates how to setup routes with different authentication requirements
func (c *AuthMiddlewareChain) SetupRoutes(router *mux.Router) <span class="cov1" title="1">{
        // Public routes (no authentication required)
        publicRouter := router.PathPrefix("/api/v1/public").Subrouter()
        publicRouter.Use(c.ForPublicEndpoints())

        // Protected routes (requires authentication)
        protectedRouter := router.PathPrefix("/api/v1/protected").Subrouter()
        protectedRouter.Use(c.ForProtectedEndpoints())

        // Admin routes (requires admin role)
        adminRouter := router.PathPrefix("/api/v1/admin").Subrouter()
        adminRouter.Use(c.ForAdminEndpoints())

        // Routes with specific permissions
        reviewRouter := router.PathPrefix("/api/v1/reviews").Subrouter()
        reviewRouter.Use(c.ForProtectedEndpoints())

        // Example: Read reviews - requires read permission
        reviewRouter.Handle("", c.WithPermission("reviews", "read")(
                http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">
                        // Handler implementation
                }</span>),
        )).Methods("GET")

        // Example: Create review - requires create permission
        <span class="cov1" title="1">reviewRouter.Handle("", c.WithPermission("reviews", "create")(
                http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">
                        // Handler implementation
                }</span>),
        )).Methods("POST")

        // Example: Update review - requires update permission
        <span class="cov1" title="1">reviewRouter.Handle("/{id}", c.WithPermission("reviews", "update")(
                http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">
                        // Handler implementation
                }</span>),
        )).Methods("PUT")

        // Example: Delete review - requires delete permission
        <span class="cov1" title="1">reviewRouter.Handle("/{id}", c.WithPermission("reviews", "delete")(
                http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">
                        // Handler implementation
                }</span>),
        )).Methods("DELETE")
}

// GetAuthMiddlewareStatus returns status information about the middleware
func (am *AuthMiddleware) GetAuthMiddlewareStatus() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "rate_limiter":    am.rateLimiter.GetRateLimitStats(),
                "blacklist":       am.blacklist.GetBlacklistStats(),
                "session_manager": am.sessionManager.GetSessionStats(),
                "metrics":         am.metricsCollector.GetMetrics(),
                "circuit_breaker": am.circuitBreaker.GetMetrics(),
                "config":          am.config,
                "timestamp":       time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// CreateSecureHash creates a secure hash for API keys or other sensitive data
func (am *AuthMiddleware) CreateSecureHash(data string) string <span class="cov3" title="3">{
        hasher := sha256.New()
        hasher.Write([]byte(data))
        return hex.EncodeToString(hasher.Sum(nil))
}</span>

// VerifySecureHash verifies a secure hash
func (am *AuthMiddleware) VerifySecureHash(data, hash string) bool <span class="cov2" title="2">{
        computedHash := am.CreateSecureHash(data)
        return computedHash == hash
}</span>

// RefreshUserSession refreshes a user session
func (am *AuthMiddleware) RefreshUserSession(sessionID string) error <span class="cov0" title="0">{
        session, exists := am.sessionManager.GetSession(sessionID)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found")
        }</span>

        <span class="cov0" title="0">session.ExpiresAt = time.Now().Add(am.config.SessionTimeout)
        return nil</span>
}

// GetUserFromContext extracts user from request context
func (am *AuthMiddleware) GetUserFromContext(r *http.Request) (*domain.User, bool) <span class="cov1" title="1">{
        user, ok := r.Context().Value("user").(*domain.User)
        return user, ok
}</span>

// GetAuthTypeFromContext extracts auth type from request context
func (am *AuthMiddleware) GetAuthTypeFromContext(r *http.Request) (string, bool) <span class="cov1" title="1">{
        authType, ok := r.Context().Value("auth_type").(string)
        return authType, ok
}</span>

// GetClientIPFromContext extracts client IP from request context
func (am *AuthMiddleware) GetClientIPFromContext(r *http.Request) (string, bool) <span class="cov1" title="1">{
        clientIP, ok := r.Context().Value("client_ip").(string)
        return clientIP, ok
}</span>

// GetRequestIDFromContext extracts request ID from request context
func (am *AuthMiddleware) GetRequestIDFromContext(r *http.Request) (string, bool) <span class="cov1" title="1">{
        requestID, ok := r.Context().Value("request_id").(string)
        return requestID, ok
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package application

import (
        "context"
        "encoding/json"
        "fmt"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// CacheService defines the interface for cache operations
type CacheService interface {
        // Review caching
        GetReview(ctx context.Context, reviewID uuid.UUID) (*domain.Review, error)
        SetReview(ctx context.Context, review *domain.Review) error
        GetReviewsByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]*domain.Review, error)
        SetReviewsByProvider(ctx context.Context, providerID uuid.UUID, reviews []*domain.Review, limit, offset int) error
        GetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int, filters *ReviewFilters) ([]*domain.Review, error)
        SetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, reviews []*domain.Review, limit, offset int, filters *ReviewFilters) error
        InvalidateReview(ctx context.Context, reviewID uuid.UUID) error
        InvalidateReviewsByProvider(ctx context.Context, providerID uuid.UUID) error
        InvalidateReviewsByHotel(ctx context.Context, hotelID uuid.UUID) error

        // Hotel caching
        GetHotel(ctx context.Context, hotelID uuid.UUID) (*domain.Hotel, error)
        SetHotel(ctx context.Context, hotel *domain.Hotel) error
        GetHotelSummary(ctx context.Context, hotelID uuid.UUID) (*domain.ReviewSummary, error)
        SetHotelSummary(ctx context.Context, summary *domain.ReviewSummary) error
        GetHotelsByCity(ctx context.Context, city string, limit, offset int) ([]*domain.Hotel, error)
        SetHotelsByCity(ctx context.Context, city string, hotels []*domain.Hotel, limit, offset int) error
        InvalidateHotel(ctx context.Context, hotelID uuid.UUID) error
        InvalidateHotelsByCity(ctx context.Context, city string) error

        // Processing status caching
        GetProcessingStatus(ctx context.Context, jobID uuid.UUID) (*domain.ReviewProcessingStatus, error)
        SetProcessingStatus(ctx context.Context, status *domain.ReviewProcessingStatus) error
        UpdateProcessingProgress(ctx context.Context, jobID uuid.UUID, progress ProcessingProgress) error
        GetActiveProcessingJobs(ctx context.Context) ([]*domain.ReviewProcessingStatus, error)
        SetActiveProcessingJobs(ctx context.Context, jobs []*domain.ReviewProcessingStatus) error
        InvalidateProcessingStatus(ctx context.Context, jobID uuid.UUID) error

        // Analytics caching
        GetAnalytics(ctx context.Context, key string) (*AnalyticsData, error)
        SetAnalytics(ctx context.Context, key string, analytics *AnalyticsData) error
        InvalidateAnalytics(ctx context.Context, pattern string) error

        // Cache warming
        WarmupReviews(ctx context.Context, options *WarmupOptions) error
        WarmupHotels(ctx context.Context, options *WarmupOptions) error
        WarmupProcessingStatus(ctx context.Context, options *WarmupOptions) error
        WarmupAnalytics(ctx context.Context, options *WarmupOptions) error

        // Cache management
        GetCacheStats(ctx context.Context) (*CacheStats, error)
        ClearCache(ctx context.Context, pattern string) error
        HealthCheck(ctx context.Context) error
}

// ReviewFilters represents filters for review queries
type ReviewFilters struct {
        MinRating     *float64   `json:"min_rating,omitempty"`
        MaxRating     *float64   `json:"max_rating,omitempty"`
        Language      *string    `json:"language,omitempty"`
        Sentiment     *string    `json:"sentiment,omitempty"`
        DateFrom      *time.Time `json:"date_from,omitempty"`
        DateTo        *time.Time `json:"date_to,omitempty"`
        IsVerified    *bool      `json:"is_verified,omitempty"`
        TripType      *string    `json:"trip_type,omitempty"`
        SortBy        string     `json:"sort_by"`
        SortDirection string     `json:"sort_direction"`
}

// ProcessingProgress represents processing progress information
type ProcessingProgress struct {
        RecordsProcessed int64     `json:"records_processed"`
        RecordsTotal     int64     `json:"records_total"`
        RecordsFailed    int64     `json:"records_failed"`
        ProcessingRate   float64   `json:"processing_rate"`
        EstimatedETA     time.Time `json:"estimated_eta"`
        LastUpdate       time.Time `json:"last_update"`
}

// AnalyticsData represents cached analytics data
type AnalyticsData struct {
        Type        string                 `json:"type"`
        Data        map[string]interface{} `json:"data"`
        Timestamp   time.Time              `json:"timestamp"`
        ExpiresAt   time.Time              `json:"expires_at"`
        Source      string                 `json:"source"`
        RefreshRate time.Duration          `json:"refresh_rate"`
}

// WarmupOptions represents options for cache warming
type WarmupOptions struct {
        ConcurrentWorkers int                    `json:"concurrent_workers"`
        BatchSize         int                    `json:"batch_size"`
        Priority          string                 `json:"priority"`
        Filters           map[string]interface{} `json:"filters"`
        MaxItems          int                    `json:"max_items"`
        ProgressCallback  func(int, int)         `json:"-"`
}

// CacheStats represents cache statistics
type CacheStats struct {
        HitRate             float64          `json:"hit_rate"`
        MissRate            float64          `json:"miss_rate"`
        TotalOperations     int64            `json:"total_operations"`
        KeyspaceStats       map[string]int64 `json:"keyspace_stats"`
        MemoryUsage         int64            `json:"memory_usage"`
        ConnectionPoolStats map[string]int64 `json:"connection_pool_stats"`
        LastUpdated         time.Time        `json:"last_updated"`
}

// CacheServiceImpl implements the CacheService interface
type CacheServiceImpl struct {
        redisClient     *infrastructure.RedisClient
        reviewService   domain.ReviewService
        logger          *logger.Logger
        config          *CacheServiceConfig
        warmupQueue     chan WarmupTask
        invalidationLog []InvalidationEvent
        mu              sync.RWMutex
        ctx             context.Context
        cancel          context.CancelFunc
        wg              sync.WaitGroup
}

// CacheServiceConfig holds configuration for the cache service
type CacheServiceConfig struct {
        // TTL settings
        ReviewTTL     time.Duration `json:"review_ttl"`
        HotelTTL      time.Duration `json:"hotel_ttl"`
        ProcessingTTL time.Duration `json:"processing_ttl"`
        AnalyticsTTL  time.Duration `json:"analytics_ttl"`
        DefaultTTL    time.Duration `json:"default_ttl"`

        // Cache keys
        ReviewKeyPrefix     string `json:"review_key_prefix"`
        HotelKeyPrefix      string `json:"hotel_key_prefix"`
        ProcessingKeyPrefix string `json:"processing_key_prefix"`
        AnalyticsKeyPrefix  string `json:"analytics_key_prefix"`

        // Warming settings
        WarmupConcurrency      int           `json:"warmup_concurrency"`
        WarmupBatchSize        int           `json:"warmup_batch_size"`
        EnableBackgroundWarmup bool          `json:"enable_background_warmup"`
        WarmupInterval         time.Duration `json:"warmup_interval"`

        // Invalidation settings
        InvalidationBatchSize   int           `json:"invalidation_batch_size"`
        InvalidationDelay       time.Duration `json:"invalidation_delay"`
        EnableSmartInvalidation bool          `json:"enable_smart_invalidation"`

        // Performance settings
        MaxConcurrentOperations int           `json:"max_concurrent_operations"`
        OperationTimeout        time.Duration `json:"operation_timeout"`
        RetryAttempts           int           `json:"retry_attempts"`
        RetryDelay              time.Duration `json:"retry_delay"`
}

// WarmupTask represents a cache warming task
type WarmupTask struct {
        Type     string                 `json:"type"`
        Priority int                    `json:"priority"`
        Data     map[string]interface{} `json:"data"`
        Options  *WarmupOptions         `json:"options"`
}

// InvalidationEvent represents a cache invalidation event
type InvalidationEvent struct {
        Type      string    `json:"type"`
        Key       string    `json:"key"`
        Pattern   string    `json:"pattern"`
        Timestamp time.Time `json:"timestamp"`
        Reason    string    `json:"reason"`
}

// NewCacheService creates a new cache service
func NewCacheService(
        redisClient *infrastructure.RedisClient,
        reviewService domain.ReviewService,
        logger *logger.Logger,
        config *CacheServiceConfig,
) *CacheServiceImpl <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        service := &amp;CacheServiceImpl{
                redisClient:     redisClient,
                reviewService:   reviewService,
                logger:          logger,
                config:          config,
                warmupQueue:     make(chan WarmupTask, 1000),
                invalidationLog: make([]InvalidationEvent, 0),
                ctx:             ctx,
                cancel:          cancel,
        }

        // Start background processes
        if config.EnableBackgroundWarmup </span><span class="cov0" title="0">{
                service.wg.Add(1)
                go service.warmupWorker()
        }</span>

        <span class="cov0" title="0">return service</span>
}

// Close closes the cache service
func (c *CacheServiceImpl) Close() error <span class="cov0" title="0">{
        c.cancel()
        c.wg.Wait()
        return nil
}</span>

// Review Caching Methods

// GetReview retrieves a review from cache
func (c *CacheServiceImpl) GetReview(ctx context.Context, reviewID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:review:%s", c.config.ReviewKeyPrefix, reviewID.String())

        cached, err := c.redisClient.Get(ctx, "reviews", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get review from cache", "review_id", reviewID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var review domain.Review
        if err := json.Unmarshal([]byte(cached), &amp;review); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached review", "review_id", reviewID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;review, nil</span>
}

// SetReview stores a review in cache
func (c *CacheServiceImpl) SetReview(ctx context.Context, review *domain.Review) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:review:%s", c.config.ReviewKeyPrefix, review.ID.String())

        data, err := json.Marshal(review)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal review: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "reviews", key, string(data), c.config.ReviewTTL)</span>
}

// GetReviewsByProvider retrieves reviews by provider from cache
func (c *CacheServiceImpl) GetReviewsByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:provider:%s:reviews:%d:%d", c.config.ReviewKeyPrefix, providerID.String(), limit, offset)

        cached, err := c.redisClient.Get(ctx, "provider_reviews", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get provider reviews from cache", "provider_id", providerID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var reviews []*domain.Review
        if err := json.Unmarshal([]byte(cached), &amp;reviews); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached provider reviews", "provider_id", providerID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// SetReviewsByProvider stores reviews by provider in cache
func (c *CacheServiceImpl) SetReviewsByProvider(ctx context.Context, providerID uuid.UUID, reviews []*domain.Review, limit, offset int) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:provider:%s:reviews:%d:%d", c.config.ReviewKeyPrefix, providerID.String(), limit, offset)

        data, err := json.Marshal(reviews)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal provider reviews: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "provider_reviews", key, string(data), c.config.ReviewTTL)</span>
}

// GetReviewsByHotel retrieves reviews by hotel from cache with filters
func (c *CacheServiceImpl) GetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int, filters *ReviewFilters) ([]*domain.Review, error) <span class="cov0" title="0">{
        key := c.buildHotelReviewsKey(hotelID, limit, offset, filters)

        cached, err := c.redisClient.Get(ctx, "hotel_reviews", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get hotel reviews from cache", "hotel_id", hotelID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var reviews []*domain.Review
        if err := json.Unmarshal([]byte(cached), &amp;reviews); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached hotel reviews", "hotel_id", hotelID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// SetReviewsByHotel stores reviews by hotel in cache
func (c *CacheServiceImpl) SetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, reviews []*domain.Review, limit, offset int, filters *ReviewFilters) error <span class="cov0" title="0">{
        key := c.buildHotelReviewsKey(hotelID, limit, offset, filters)

        data, err := json.Marshal(reviews)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal hotel reviews: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "hotel_reviews", key, string(data), c.config.ReviewTTL)</span>
}

// buildHotelReviewsKey builds a cache key for hotel reviews with filters
func (c *CacheServiceImpl) buildHotelReviewsKey(hotelID uuid.UUID, limit, offset int, filters *ReviewFilters) string <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:hotel:%s:reviews:%d:%d", c.config.ReviewKeyPrefix, hotelID.String(), limit, offset)

        if filters != nil </span><span class="cov0" title="0">{
                filterStr := c.serializeFilters(filters)
                if filterStr != "" </span><span class="cov0" title="0">{
                        key += ":" + filterStr
                }</span>
        }

        <span class="cov0" title="0">return key</span>
}

// serializeFilters serializes review filters for cache key
func (c *CacheServiceImpl) serializeFilters(filters *ReviewFilters) string <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">parts := make([]string, 0)

        if filters.MinRating != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("min_rating:%.2f", *filters.MinRating))
        }</span>
        <span class="cov0" title="0">if filters.MaxRating != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("max_rating:%.2f", *filters.MaxRating))
        }</span>
        <span class="cov0" title="0">if filters.Language != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("language:%s", *filters.Language))
        }</span>
        <span class="cov0" title="0">if filters.Sentiment != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("sentiment:%s", *filters.Sentiment))
        }</span>
        <span class="cov0" title="0">if filters.IsVerified != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("verified:%t", *filters.IsVerified))
        }</span>
        <span class="cov0" title="0">if filters.TripType != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("trip_type:%s", *filters.TripType))
        }</span>
        <span class="cov0" title="0">if filters.SortBy != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("sort:%s:%s", filters.SortBy, filters.SortDirection))
        }</span>

        <span class="cov0" title="0">sort.Strings(parts)
        return strings.Join(parts, "_")</span>
}

// InvalidateReview invalidates a single review
func (c *CacheServiceImpl) InvalidateReview(ctx context.Context, reviewID uuid.UUID) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:review:%s", c.config.ReviewKeyPrefix, reviewID.String())

        err := c.redisClient.Delete(ctx, "reviews", key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.logInvalidation("review", key, "", "single_review_update")
        return nil</span>
}

// InvalidateReviewsByProvider invalidates all reviews for a provider
func (c *CacheServiceImpl) InvalidateReviewsByProvider(ctx context.Context, providerID uuid.UUID) error <span class="cov0" title="0">{
        pattern := fmt.Sprintf("%s:provider:%s:reviews:*", c.config.ReviewKeyPrefix, providerID.String())

        err := c.invalidatePattern(ctx, "provider_reviews", pattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.logInvalidation("provider_reviews", "", pattern, "provider_update")
        return nil</span>
}

// InvalidateReviewsByHotel invalidates all reviews for a hotel
func (c *CacheServiceImpl) InvalidateReviewsByHotel(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        pattern := fmt.Sprintf("%s:hotel:%s:reviews:*", c.config.ReviewKeyPrefix, hotelID.String())

        err := c.invalidatePattern(ctx, "hotel_reviews", pattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.logInvalidation("hotel_reviews", "", pattern, "hotel_update")
        return nil</span>
}

// Hotel Caching Methods

// GetHotel retrieves a hotel from cache
func (c *CacheServiceImpl) GetHotel(ctx context.Context, hotelID uuid.UUID) (*domain.Hotel, error) <span class="cov0" title="0">{
        key := hotelID.String()

        hotelData, err := c.redisClient.HGetAll(ctx, "hotels", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get hotel from cache", "hotel_id", hotelID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(hotelData) == 0 </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">return c.deserializeHotel(hotelData)</span>
}

// SetHotel stores a hotel in cache
func (c *CacheServiceImpl) SetHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        key := hotel.ID.String()
        hotelData := c.serializeHotel(hotel)

        return c.redisClient.HSetMap(ctx, "hotels", key, hotelData, c.config.HotelTTL)
}</span>

// GetHotelSummary retrieves hotel summary from cache
func (c *CacheServiceImpl) GetHotelSummary(ctx context.Context, hotelID uuid.UUID) (*domain.ReviewSummary, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:summary:%s", c.config.HotelKeyPrefix, hotelID.String())

        cached, err := c.redisClient.Get(ctx, "hotel_summaries", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get hotel summary from cache", "hotel_id", hotelID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var summary domain.ReviewSummary
        if err := json.Unmarshal([]byte(cached), &amp;summary); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached hotel summary", "hotel_id", hotelID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;summary, nil</span>
}

// SetHotelSummary stores hotel summary in cache
func (c *CacheServiceImpl) SetHotelSummary(ctx context.Context, summary *domain.ReviewSummary) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:summary:%s", c.config.HotelKeyPrefix, summary.HotelID.String())

        data, err := json.Marshal(summary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal hotel summary: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "hotel_summaries", key, string(data), c.config.HotelTTL)</span>
}

// GetHotelsByCity retrieves hotels by city from cache
func (c *CacheServiceImpl) GetHotelsByCity(ctx context.Context, city string, limit, offset int) ([]*domain.Hotel, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:city:%s:hotels:%d:%d", c.config.HotelKeyPrefix, city, limit, offset)

        cached, err := c.redisClient.Get(ctx, "city_hotels", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get city hotels from cache", "city", city, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var hotels []*domain.Hotel
        if err := json.Unmarshal([]byte(cached), &amp;hotels); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached city hotels", "city", city, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return hotels, nil</span>
}

// SetHotelsByCity stores hotels by city in cache
func (c *CacheServiceImpl) SetHotelsByCity(ctx context.Context, city string, hotels []*domain.Hotel, limit, offset int) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:city:%s:hotels:%d:%d", c.config.HotelKeyPrefix, city, limit, offset)

        data, err := json.Marshal(hotels)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal city hotels: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "city_hotels", key, string(data), c.config.HotelTTL)</span>
}

// serializeHotel converts hotel to map for hash storage
func (c *CacheServiceImpl) serializeHotel(hotel *domain.Hotel) map[string]string <span class="cov0" title="0">{
        data := make(map[string]string)

        data["id"] = hotel.ID.String()
        data["name"] = hotel.Name
        data["address"] = hotel.Address
        data["city"] = hotel.City
        data["country"] = hotel.Country
        data["postal_code"] = hotel.PostalCode
        data["phone"] = hotel.Phone
        data["email"] = hotel.Email
        data["star_rating"] = strconv.Itoa(hotel.StarRating)
        data["description"] = hotel.Description
        data["latitude"] = strconv.FormatFloat(hotel.Latitude, 'f', 8, 64)
        data["longitude"] = strconv.FormatFloat(hotel.Longitude, 'f', 8, 64)
        data["created_at"] = hotel.CreatedAt.Format(time.RFC3339)
        data["updated_at"] = hotel.UpdatedAt.Format(time.RFC3339)

        // Serialize amenities
        if amenities, err := json.Marshal(hotel.Amenities); err == nil </span><span class="cov0" title="0">{
                data["amenities"] = string(amenities)
        }</span>

        <span class="cov0" title="0">return data</span>
}

// deserializeHotel converts map to hotel struct
func (c *CacheServiceImpl) deserializeHotel(data map[string]string) (*domain.Hotel, error) <span class="cov0" title="0">{
        hotel := &amp;domain.Hotel{}

        if id, err := uuid.Parse(data["id"]); err == nil </span><span class="cov0" title="0">{
                hotel.ID = id
        }</span>

        <span class="cov0" title="0">hotel.Name = data["name"]
        hotel.Address = data["address"]
        hotel.City = data["city"]
        hotel.Country = data["country"]
        hotel.PostalCode = data["postal_code"]
        hotel.Phone = data["phone"]
        hotel.Email = data["email"]
        hotel.Description = data["description"]

        if starRating, err := strconv.Atoi(data["star_rating"]); err == nil </span><span class="cov0" title="0">{
                hotel.StarRating = starRating
        }</span>

        <span class="cov0" title="0">if lat, err := strconv.ParseFloat(data["latitude"], 64); err == nil </span><span class="cov0" title="0">{
                hotel.Latitude = lat
        }</span>

        <span class="cov0" title="0">if lng, err := strconv.ParseFloat(data["longitude"], 64); err == nil </span><span class="cov0" title="0">{
                hotel.Longitude = lng
        }</span>

        <span class="cov0" title="0">if createdAt, err := time.Parse(time.RFC3339, data["created_at"]); err == nil </span><span class="cov0" title="0">{
                hotel.CreatedAt = createdAt
        }</span>

        <span class="cov0" title="0">if updatedAt, err := time.Parse(time.RFC3339, data["updated_at"]); err == nil </span><span class="cov0" title="0">{
                hotel.UpdatedAt = updatedAt
        }</span>

        // Deserialize amenities
        <span class="cov0" title="0">if data["amenities"] != "" </span><span class="cov0" title="0">{
                var amenities []string
                if err := json.Unmarshal([]byte(data["amenities"]), &amp;amenities); err == nil </span><span class="cov0" title="0">{
                        hotel.Amenities = amenities
                }</span>
        }

        <span class="cov0" title="0">return hotel, nil</span>
}

// InvalidateHotel invalidates a single hotel
func (c *CacheServiceImpl) InvalidateHotel(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        key := hotelID.String()

        err := c.redisClient.Delete(ctx, "hotels", key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Also invalidate hotel summary
        <span class="cov0" title="0">summaryKey := fmt.Sprintf("%s:summary:%s", c.config.HotelKeyPrefix, hotelID.String())
        if err := c.redisClient.Delete(ctx, "hotel_summaries", summaryKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete hotel summary cache: %w", err)
        }</span>

        <span class="cov0" title="0">c.logInvalidation("hotel", key, "", "hotel_update")
        return nil</span>
}

// InvalidateHotelsByCity invalidates all hotels for a city
func (c *CacheServiceImpl) InvalidateHotelsByCity(ctx context.Context, city string) error <span class="cov0" title="0">{
        pattern := fmt.Sprintf("%s:city:%s:hotels:*", c.config.HotelKeyPrefix, city)

        err := c.invalidatePattern(ctx, "city_hotels", pattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.logInvalidation("city_hotels", "", pattern, "city_update")
        return nil</span>
}

// Processing Status Caching Methods

// GetProcessingStatus retrieves processing status from cache
func (c *CacheServiceImpl) GetProcessingStatus(ctx context.Context, jobID uuid.UUID) (*domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        key := jobID.String()

        statusData, err := c.redisClient.HGetAll(ctx, "processing_status", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get processing status from cache", "job_id", jobID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(statusData) == 0 </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">return c.deserializeProcessingStatus(statusData)</span>
}

// SetProcessingStatus stores processing status in cache
func (c *CacheServiceImpl) SetProcessingStatus(ctx context.Context, status *domain.ReviewProcessingStatus) error <span class="cov0" title="0">{
        key := status.ID.String()
        statusData := c.serializeProcessingStatus(status)

        return c.redisClient.HSetMap(ctx, "processing_status", key, statusData, c.config.ProcessingTTL)
}</span>

// UpdateProcessingProgress updates processing progress
func (c *CacheServiceImpl) UpdateProcessingProgress(ctx context.Context, jobID uuid.UUID, progress ProcessingProgress) error <span class="cov0" title="0">{
        key := jobID.String()

        updates := map[string]string{
                "records_processed": strconv.FormatInt(progress.RecordsProcessed, 10),
                "records_total":     strconv.FormatInt(progress.RecordsTotal, 10),
                "records_failed":    strconv.FormatInt(progress.RecordsFailed, 10),
                "processing_rate":   strconv.FormatFloat(progress.ProcessingRate, 'f', 2, 64),
                "estimated_eta":     progress.EstimatedETA.Format(time.RFC3339),
                "last_update":       progress.LastUpdate.Format(time.RFC3339),
        }

        for field, value := range updates </span><span class="cov0" title="0">{
                if err := c.redisClient.HSet(ctx, "processing_status", key, field, value, c.config.ProcessingTTL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetActiveProcessingJobs retrieves active processing jobs
func (c *CacheServiceImpl) GetActiveProcessingJobs(ctx context.Context) ([]*domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        key := "active_jobs"

        cached, err := c.redisClient.Get(ctx, "active_processing", key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get active processing jobs from cache", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var jobs []*domain.ReviewProcessingStatus
        if err := json.Unmarshal([]byte(cached), &amp;jobs); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached active jobs", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return jobs, nil</span>
}

// SetActiveProcessingJobs stores active processing jobs
func (c *CacheServiceImpl) SetActiveProcessingJobs(ctx context.Context, jobs []*domain.ReviewProcessingStatus) error <span class="cov0" title="0">{
        key := "active_jobs"

        data, err := json.Marshal(jobs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal active jobs: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "active_processing", key, string(data), c.config.ProcessingTTL)</span>
}

// serializeProcessingStatus converts processing status to map
func (c *CacheServiceImpl) serializeProcessingStatus(status *domain.ReviewProcessingStatus) map[string]string <span class="cov0" title="0">{
        data := make(map[string]string)

        data["id"] = status.ID.String()
        data["provider_id"] = status.ProviderID.String()
        data["status"] = status.Status
        data["file_url"] = status.FileURL
        data["records_processed"] = strconv.Itoa(status.RecordsProcessed)
        data["records_total"] = strconv.Itoa(status.RecordsTotal)
        data["error_msg"] = status.ErrorMsg
        data["created_at"] = status.CreatedAt.Format(time.RFC3339)
        data["updated_at"] = status.UpdatedAt.Format(time.RFC3339)

        if status.StartedAt != nil </span><span class="cov0" title="0">{
                data["started_at"] = status.StartedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">if status.CompletedAt != nil </span><span class="cov0" title="0">{
                data["completed_at"] = status.CompletedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return data</span>
}

// deserializeProcessingStatus converts map to processing status struct
func (c *CacheServiceImpl) deserializeProcessingStatus(data map[string]string) (*domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        status := &amp;domain.ReviewProcessingStatus{}

        if id, err := uuid.Parse(data["id"]); err == nil </span><span class="cov0" title="0">{
                status.ID = id
        }</span>

        <span class="cov0" title="0">if providerID, err := uuid.Parse(data["provider_id"]); err == nil </span><span class="cov0" title="0">{
                status.ProviderID = providerID
        }</span>

        <span class="cov0" title="0">status.Status = data["status"]
        status.FileURL = data["file_url"]
        status.ErrorMsg = data["error_msg"]

        if recordsProcessed, err := strconv.Atoi(data["records_processed"]); err == nil </span><span class="cov0" title="0">{
                status.RecordsProcessed = recordsProcessed
        }</span>

        <span class="cov0" title="0">if recordsTotal, err := strconv.Atoi(data["records_total"]); err == nil </span><span class="cov0" title="0">{
                status.RecordsTotal = recordsTotal
        }</span>

        <span class="cov0" title="0">if createdAt, err := time.Parse(time.RFC3339, data["created_at"]); err == nil </span><span class="cov0" title="0">{
                status.CreatedAt = createdAt
        }</span>

        <span class="cov0" title="0">if updatedAt, err := time.Parse(time.RFC3339, data["updated_at"]); err == nil </span><span class="cov0" title="0">{
                status.UpdatedAt = updatedAt
        }</span>

        <span class="cov0" title="0">if data["started_at"] != "" </span><span class="cov0" title="0">{
                if startedAt, err := time.Parse(time.RFC3339, data["started_at"]); err == nil </span><span class="cov0" title="0">{
                        status.StartedAt = &amp;startedAt
                }</span>
        }

        <span class="cov0" title="0">if data["completed_at"] != "" </span><span class="cov0" title="0">{
                if completedAt, err := time.Parse(time.RFC3339, data["completed_at"]); err == nil </span><span class="cov0" title="0">{
                        status.CompletedAt = &amp;completedAt
                }</span>
        }

        <span class="cov0" title="0">return status, nil</span>
}

// InvalidateProcessingStatus invalidates processing status
func (c *CacheServiceImpl) InvalidateProcessingStatus(ctx context.Context, jobID uuid.UUID) error <span class="cov0" title="0">{
        key := jobID.String()

        err := c.redisClient.Delete(ctx, "processing_status", key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Also invalidate active jobs list
        <span class="cov0" title="0">if err := c.redisClient.Delete(ctx, "active_processing", "active_jobs"); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to cleanup processing cache", "error", err)
        }</span>

        <span class="cov0" title="0">c.logInvalidation("processing_status", key, "", "processing_update")
        return nil</span>
}

// Analytics Caching Methods

// GetAnalytics retrieves analytics data from cache
func (c *CacheServiceImpl) GetAnalytics(ctx context.Context, key string) (*AnalyticsData, error) <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s:analytics:%s", c.config.AnalyticsKeyPrefix, key)

        cached, err := c.redisClient.Get(ctx, "analytics", cacheKey)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get analytics from cache", "key", key, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cached == "" </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var analytics AnalyticsData
        if err := json.Unmarshal([]byte(cached), &amp;analytics); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to unmarshal cached analytics", "key", key, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;analytics, nil</span>
}

// SetAnalytics stores analytics data in cache
func (c *CacheServiceImpl) SetAnalytics(ctx context.Context, key string, analytics *AnalyticsData) error <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s:analytics:%s", c.config.AnalyticsKeyPrefix, key)

        data, err := json.Marshal(analytics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal analytics: %w", err)
        }</span>

        <span class="cov0" title="0">return c.redisClient.Set(ctx, "analytics", cacheKey, string(data), c.config.AnalyticsTTL)</span>
}

// InvalidateAnalytics invalidates analytics data by pattern
func (c *CacheServiceImpl) InvalidateAnalytics(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        fullPattern := fmt.Sprintf("%s:analytics:%s", c.config.AnalyticsKeyPrefix, pattern)

        err := c.invalidatePattern(ctx, "analytics", fullPattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.logInvalidation("analytics", "", fullPattern, "analytics_update")
        return nil</span>
}

// Cache Warming Methods

// WarmupReviews warms up review cache
func (c *CacheServiceImpl) WarmupReviews(ctx context.Context, options *WarmupOptions) error <span class="cov0" title="0">{
        c.logger.Info("Starting review cache warmup", "options", options)

        // Implementation would fetch popular reviews and cache them
        // This is a placeholder for the actual implementation
        task := WarmupTask{
                Type:     "reviews",
                Priority: 1,
                Options:  options,
        }

        select </span>{
        case c.warmupQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("warmup queue is full")</span>
        }
}

// WarmupHotels warms up hotel cache
func (c *CacheServiceImpl) WarmupHotels(ctx context.Context, options *WarmupOptions) error <span class="cov0" title="0">{
        c.logger.Info("Starting hotel cache warmup", "options", options)

        task := WarmupTask{
                Type:     "hotels",
                Priority: 1,
                Options:  options,
        }

        select </span>{
        case c.warmupQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("warmup queue is full")</span>
        }
}

// WarmupProcessingStatus warms up processing status cache
func (c *CacheServiceImpl) WarmupProcessingStatus(ctx context.Context, options *WarmupOptions) error <span class="cov0" title="0">{
        c.logger.Info("Starting processing status cache warmup", "options", options)

        task := WarmupTask{
                Type:     "processing_status",
                Priority: 1,
                Options:  options,
        }

        select </span>{
        case c.warmupQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("warmup queue is full")</span>
        }
}

// WarmupAnalytics warms up analytics cache
func (c *CacheServiceImpl) WarmupAnalytics(ctx context.Context, options *WarmupOptions) error <span class="cov0" title="0">{
        c.logger.Info("Starting analytics cache warmup", "options", options)

        task := WarmupTask{
                Type:     "analytics",
                Priority: 1,
                Options:  options,
        }

        select </span>{
        case c.warmupQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("warmup queue is full")</span>
        }
}

// warmupWorker processes warmup tasks
func (c *CacheServiceImpl) warmupWorker() <span class="cov0" title="0">{
        defer c.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case task := &lt;-c.warmupQueue:<span class="cov0" title="0">
                        c.processWarmupTask(task)</span>
                }
        }
}

// processWarmupTask processes a single warmup task
func (c *CacheServiceImpl) processWarmupTask(task WarmupTask) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        c.logger.Info("Processing warmup task", "type", task.Type, "priority", task.Priority)

        switch task.Type </span>{
        case "reviews":<span class="cov0" title="0">
                c.warmupReviewsData(ctx, task.Options)</span>
        case "hotels":<span class="cov0" title="0">
                c.warmupHotelsData(ctx, task.Options)</span>
        case "processing_status":<span class="cov0" title="0">
                c.warmupProcessingStatusData(ctx, task.Options)</span>
        case "analytics":<span class="cov0" title="0">
                c.warmupAnalyticsData(ctx, task.Options)</span>
        default:<span class="cov0" title="0">
                c.logger.Warn("Unknown warmup task type", "type", task.Type)</span>
        }
}

// warmupReviewsData warms up reviews data
func (c *CacheServiceImpl) warmupReviewsData(ctx context.Context, options *WarmupOptions) <span class="cov0" title="0">{
        // Implementation would fetch and cache popular reviews
        // This is a placeholder for the actual implementation
        c.logger.Info("Warming up reviews data", "options", options)
}</span>

// warmupHotelsData warms up hotels data
func (c *CacheServiceImpl) warmupHotelsData(ctx context.Context, options *WarmupOptions) <span class="cov0" title="0">{
        // Implementation would fetch and cache popular hotels
        // This is a placeholder for the actual implementation
        c.logger.Info("Warming up hotels data", "options", options)
}</span>

// warmupProcessingStatusData warms up processing status data
func (c *CacheServiceImpl) warmupProcessingStatusData(ctx context.Context, options *WarmupOptions) <span class="cov0" title="0">{
        // Implementation would fetch and cache active processing jobs
        // This is a placeholder for the actual implementation
        c.logger.Info("Warming up processing status data", "options", options)
}</span>

// warmupAnalyticsData warms up analytics data
func (c *CacheServiceImpl) warmupAnalyticsData(ctx context.Context, options *WarmupOptions) <span class="cov0" title="0">{
        // Implementation would fetch and cache frequently accessed analytics
        // This is a placeholder for the actual implementation
        c.logger.Info("Warming up analytics data", "options", options)
}</span>

// Cache Management Methods

// GetCacheStats returns cache statistics
func (c *CacheServiceImpl) GetCacheStats(ctx context.Context) (*CacheStats, error) <span class="cov0" title="0">{
        metrics := c.redisClient.GetMetrics()

        stats := &amp;CacheStats{
                HitRate:         metrics.HitRate,
                MissRate:        100 - metrics.HitRate,
                TotalOperations: metrics.TotalHits + metrics.TotalMisses + metrics.TotalSets + metrics.TotalDeletes,
                KeyspaceStats:   metrics.KeyspaceCounts,
                LastUpdated:     metrics.LastUpdated,
        }

        return stats, nil
}</span>

// ClearCache clears cache by pattern
func (c *CacheServiceImpl) ClearCache(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        return c.invalidatePattern(ctx, "all", pattern)
}</span>

// HealthCheck performs cache health check
func (c *CacheServiceImpl) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return c.redisClient.HealthCheck(ctx)
}</span>

// Helper Methods

// invalidatePattern invalidates keys matching a pattern
func (c *CacheServiceImpl) invalidatePattern(ctx context.Context, keyspace, pattern string) error <span class="cov0" title="0">{
        // This would use Redis SCAN to find matching keys and delete them
        // Implementation would be similar to the one in redis.go
        return nil
}</span>

// logInvalidation logs cache invalidation events
func (c *CacheServiceImpl) logInvalidation(eventType, key, pattern, reason string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        event := InvalidationEvent{
                Type:      eventType,
                Key:       key,
                Pattern:   pattern,
                Timestamp: time.Now(),
                Reason:    reason,
        }

        c.invalidationLog = append(c.invalidationLog, event)

        // Keep only last 1000 events
        if len(c.invalidationLog) &gt; 1000 </span><span class="cov0" title="0">{
                c.invalidationLog = c.invalidationLog[1:]
        }</span>

        <span class="cov0" title="0">c.logger.Info("Cache invalidation",
                "type", eventType,
                "key", key,
                "pattern", pattern,
                "reason", reason,
        )</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package application

import (
        "context"
        "fmt"
        "runtime/debug"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// EventHandlerConfig represents configuration for event handlers
type EventHandlerConfig struct {
        MaxWorkers          int           `json:"max_workers"`
        MaxRetries          int           `json:"max_retries"`
        RetryDelay          time.Duration `json:"retry_delay"`
        RetryBackoffFactor  float64       `json:"retry_backoff_factor"`
        MaxRetryDelay       time.Duration `json:"max_retry_delay"`
        ProcessingTimeout   time.Duration `json:"processing_timeout"`
        BufferSize          int           `json:"buffer_size"`
        EnableMetrics       bool          `json:"enable_metrics"`
        EnableNotifications bool          `json:"enable_notifications"`
        EnableReplay        bool          `json:"enable_replay"`
        DeadLetterThreshold int           `json:"dead_letter_threshold"`
}

// EventHandlerResult represents the result of event handling
type EventHandlerResult struct {
        EventID     uuid.UUID              `json:"event_id"`
        HandlerName string                 `json:"handler_name"`
        ProcessedAt time.Time              `json:"processed_at"`
        Duration    time.Duration          `json:"duration"`
        Success     bool                   `json:"success"`
        Error       string                 `json:"error,omitempty"`
        RetryCount  int                    `json:"retry_count"`
        IsReplay    bool                   `json:"is_replay"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// EventHandlerMetrics represents metrics for event handlers
type EventHandlerMetrics struct {
        TotalProcessed   int64                      `json:"total_processed"`
        TotalErrors      int64                      `json:"total_errors"`
        TotalRetries     int64                      `json:"total_retries"`
        AverageLatency   time.Duration              `json:"average_latency"`
        ProcessingRate   float64                    `json:"processing_rate"`
        ErrorRate        float64                    `json:"error_rate"`
        LastProcessedAt  time.Time                  `json:"last_processed_at"`
        EventTypeMetrics map[domain.EventType]int64 `json:"event_type_metrics"`
        HandlerMetrics   map[string]int64           `json:"handler_metrics"`
        ReplayMetrics    map[string]int64           `json:"replay_metrics"`
}

// BaseEventHandler provides common functionality for all event handlers
type BaseEventHandler struct {
        name           string
        config         *EventHandlerConfig
        logger         *logger.Logger
        metrics        *EventHandlerMetrics
        mu             sync.RWMutex
        processingChan chan *EventHandlingTask
        ctx            context.Context
        cancel         context.CancelFunc
        wg             sync.WaitGroup
        started        bool
}

// EventHandlingTask represents a task for handling an event
type EventHandlingTask struct {
        ID            uuid.UUID
        Event         domain.DomainEvent
        HandlerName   string
        RetryCount    int
        MaxRetries    int
        CreatedAt     time.Time
        LastAttemptAt time.Time
        NextAttemptAt time.Time
        Context       context.Context
        ResultChan    chan *EventHandlerResult
        IsReplay      bool
        ReplayContext map[string]interface{}
}

// NewBaseEventHandler creates a new base event handler
func NewBaseEventHandler(name string, config *EventHandlerConfig, logger *logger.Logger) *BaseEventHandler <span class="cov10" title="6">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;BaseEventHandler{
                name:   name,
                config: config,
                logger: logger,
                metrics: &amp;EventHandlerMetrics{
                        EventTypeMetrics: make(map[domain.EventType]int64),
                        HandlerMetrics:   make(map[string]int64),
                        ReplayMetrics:    make(map[string]int64),
                },
                processingChan: make(chan *EventHandlingTask, config.BufferSize),
                ctx:            ctx,
                cancel:         cancel,
        }
}</span>

// Start starts the event handler
func (h *BaseEventHandler) Start() error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.started </span><span class="cov0" title="0">{
                return fmt.Errorf("event handler %s already started", h.name)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Starting event handler", "handler", h.name, "workers", h.config.MaxWorkers)

        // Start worker goroutines
        for i := 0; i &lt; h.config.MaxWorkers; i++ </span><span class="cov0" title="0">{
                h.wg.Add(1)
                go h.workerLoop(i)
        }</span>

        // Start metrics collector
        <span class="cov0" title="0">if h.config.EnableMetrics </span><span class="cov0" title="0">{
                h.wg.Add(1)
                go h.metricsLoop()
        }</span>

        <span class="cov0" title="0">h.started = true
        return nil</span>
}

// Stop stops the event handler
func (h *BaseEventHandler) Stop() error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if !h.started </span><span class="cov0" title="0">{
                return fmt.Errorf("event handler %s not started", h.name)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Stopping event handler", "handler", h.name)

        h.cancel()
        h.wg.Wait()

        h.started = false
        return nil</span>
}

// HandleEventAsync handles an event asynchronously
func (h *BaseEventHandler) HandleEventAsync(ctx context.Context, event domain.DomainEvent) error <span class="cov0" title="0">{
        task := &amp;EventHandlingTask{
                ID:            uuid.New(),
                Event:         event,
                HandlerName:   h.name,
                RetryCount:    0,
                MaxRetries:    h.config.MaxRetries,
                CreatedAt:     time.Now(),
                LastAttemptAt: time.Now(),
                NextAttemptAt: time.Now(),
                Context:       ctx,
                ResultChan:    make(chan *EventHandlerResult, 1),
                IsReplay:      event.IsReplayable(),
        }

        select </span>{
        case h.processingChan &lt;- task:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("event handler %s processing queue is full", h.name)</span>
        }
}

// HandleEventSync handles an event synchronously
func (h *BaseEventHandler) HandleEventSync(ctx context.Context, event domain.DomainEvent) (*EventHandlerResult, error) <span class="cov0" title="0">{
        task := &amp;EventHandlingTask{
                ID:            uuid.New(),
                Event:         event,
                HandlerName:   h.name,
                RetryCount:    0,
                MaxRetries:    h.config.MaxRetries,
                CreatedAt:     time.Now(),
                LastAttemptAt: time.Now(),
                NextAttemptAt: time.Now(),
                Context:       ctx,
                ResultChan:    make(chan *EventHandlerResult, 1),
                IsReplay:      event.IsReplayable(),
        }

        select </span>{
        case h.processingChan &lt;- task:<span class="cov0" title="0">
                // Wait for result
                select </span>{
                case result := &lt;-task.ResultChan:<span class="cov0" title="0">
                        return result, nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event handler %s processing queue is full", h.name)</span>
        }
}

// workerLoop is the main loop for worker goroutines
func (h *BaseEventHandler) workerLoop(workerID int) <span class="cov0" title="0">{
        defer h.wg.Done()

        h.logger.Debug("Event handler worker started", "handler", h.name, "worker_id", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.ctx.Done():<span class="cov0" title="0">
                        h.logger.Debug("Event handler worker stopping", "handler", h.name, "worker_id", workerID)
                        return</span>
                case task := &lt;-h.processingChan:<span class="cov0" title="0">
                        h.processTask(task)</span>
                }
        }
}

// processTask processes a single event handling task
func (h *BaseEventHandler) processTask(task *EventHandlingTask) <span class="cov0" title="0">{
        startTime := time.Now()

        // Create timeout context
        ctx, cancel := context.WithTimeout(task.Context, h.config.ProcessingTimeout)
        defer cancel()

        // Process the task
        result := &amp;EventHandlerResult{
                EventID:     task.Event.GetID(),
                HandlerName: task.HandlerName,
                ProcessedAt: startTime,
                RetryCount:  task.RetryCount,
                IsReplay:    task.IsReplay,
                Metadata:    make(map[string]interface{}),
        }

        // Handle the event with recovery
        err := h.handleEventWithRecovery(ctx, task.Event, result)

        // Calculate duration
        result.Duration = time.Since(startTime)
        result.Success = err == nil

        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
                h.logger.Error("Event handling failed",
                        "handler", h.name,
                        "event_id", task.Event.GetID(),
                        "event_type", task.Event.GetType(),
                        "error", err,
                        "retry_count", task.RetryCount,
                )

                // Handle retry logic
                if task.RetryCount &lt; task.MaxRetries </span><span class="cov0" title="0">{
                        h.scheduleRetry(task)
                        return
                }</span>

                // Send to dead letter queue if max retries exceeded
                <span class="cov0" title="0">if task.RetryCount &gt;= h.config.DeadLetterThreshold </span><span class="cov0" title="0">{
                        h.sendToDeadLetterQueue(task, err)
                }</span>
        } else<span class="cov0" title="0"> {
                h.logger.Debug("Event handled successfully",
                        "handler", h.name,
                        "event_id", task.Event.GetID(),
                        "event_type", task.Event.GetType(),
                        "duration", result.Duration,
                )
        }</span>

        // Update metrics
        <span class="cov0" title="0">h.updateMetrics(result)

        // Send result if channel is available
        if task.ResultChan != nil </span><span class="cov0" title="0">{
                select </span>{
                case task.ResultChan &lt;- result:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel full or closed, ignore
                }
        }
}

// handleEventWithRecovery handles an event with panic recovery
func (h *BaseEventHandler) handleEventWithRecovery(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("panic in event handler: %v", r)
                        result.Metadata["panic"] = r
                        result.Metadata["stack_trace"] = string(debug.Stack())
                        h.logger.Error("Event handler panic recovered",
                                "handler", h.name,
                                "event_id", event.GetID(),
                                "panic", r,
                                "stack_trace", string(debug.Stack()),
                        )
                }</span>
        }()

        // This method should be overridden by specific handlers
        <span class="cov0" title="0">return h.handleEvent(ctx, event, result)</span>
}

// handleEvent is the default event handling method (should be overridden)
func (h *BaseEventHandler) handleEvent(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        return fmt.Errorf("handleEvent method not implemented for handler %s", h.name)
}</span>

// scheduleRetry schedules a retry for a failed task
func (h *BaseEventHandler) scheduleRetry(task *EventHandlingTask) <span class="cov0" title="0">{
        task.RetryCount++
        task.LastAttemptAt = time.Now()

        // Calculate next retry delay with exponential backoff
        delay := time.Duration(float64(h.config.RetryDelay) *
                float64(task.RetryCount) * h.config.RetryBackoffFactor)

        if delay &gt; h.config.MaxRetryDelay </span><span class="cov0" title="0">{
                delay = h.config.MaxRetryDelay
        }</span>

        <span class="cov0" title="0">task.NextAttemptAt = time.Now().Add(delay)

        h.logger.Info("Scheduling event retry",
                "handler", h.name,
                "event_id", task.Event.GetID(),
                "retry_count", task.RetryCount,
                "next_attempt_at", task.NextAttemptAt,
                "delay", delay,
        )

        // Schedule the retry
        go func() </span><span class="cov0" title="0">{
                time.Sleep(delay)
                select </span>{
                case h.processingChan &lt;- task:<span class="cov0" title="0"></span>
                case &lt;-h.ctx.Done():<span class="cov0" title="0"></span>
                        // Handler is stopping, abandon retry
                }
        }()
}

// sendToDeadLetterQueue sends a task to the dead letter queue
func (h *BaseEventHandler) sendToDeadLetterQueue(task *EventHandlingTask, err error) <span class="cov0" title="0">{
        h.logger.Error("Sending event to dead letter queue",
                "handler", h.name,
                "event_id", task.Event.GetID(),
                "event_type", task.Event.GetType(),
                "retry_count", task.RetryCount,
                "error", err,
        )

        // Implementation would depend on your dead letter queue mechanism
        // This could be a database table, message queue, file system, etc.
}</span>

// updateMetrics updates handler metrics
func (h *BaseEventHandler) updateMetrics(result *EventHandlerResult) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        h.metrics.TotalProcessed++
        h.metrics.LastProcessedAt = result.ProcessedAt

        if !result.Success </span><span class="cov0" title="0">{
                h.metrics.TotalErrors++
        }</span>

        <span class="cov0" title="0">if result.RetryCount &gt; 0 </span><span class="cov0" title="0">{
                h.metrics.TotalRetries++
        }</span>

        // Update latency (simple moving average)
        <span class="cov0" title="0">if h.metrics.AverageLatency == 0 </span><span class="cov0" title="0">{
                h.metrics.AverageLatency = result.Duration
        }</span> else<span class="cov0" title="0"> {
                h.metrics.AverageLatency = (h.metrics.AverageLatency + result.Duration) / 2
        }</span>

        // Update rates
        <span class="cov0" title="0">if h.metrics.TotalProcessed &gt; 0 </span><span class="cov0" title="0">{
                h.metrics.ErrorRate = float64(h.metrics.TotalErrors) / float64(h.metrics.TotalProcessed)
        }</span>

        // Update handler-specific metrics
        <span class="cov0" title="0">h.metrics.HandlerMetrics[result.HandlerName]++

        // Update replay metrics
        if result.IsReplay </span><span class="cov0" title="0">{
                h.metrics.ReplayMetrics[result.HandlerName]++
        }</span>
}

// metricsLoop runs the metrics collection loop
func (h *BaseEventHandler) metricsLoop() <span class="cov0" title="0">{
        defer h.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.collectMetrics()</span>
                }
        }
}

// collectMetrics collects and logs metrics
func (h *BaseEventHandler) collectMetrics() <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        // Calculate processing rate (events per second)
        if !h.metrics.LastProcessedAt.IsZero() </span><span class="cov0" title="0">{
                duration := time.Since(h.metrics.LastProcessedAt)
                if duration &gt; 0 </span><span class="cov0" title="0">{
                        h.metrics.ProcessingRate = float64(h.metrics.TotalProcessed) / duration.Seconds()
                }</span>
        }

        <span class="cov0" title="0">h.logger.Info("Event handler metrics",
                "handler", h.name,
                "total_processed", h.metrics.TotalProcessed,
                "total_errors", h.metrics.TotalErrors,
                "total_retries", h.metrics.TotalRetries,
                "average_latency", h.metrics.AverageLatency,
                "processing_rate", h.metrics.ProcessingRate,
                "error_rate", h.metrics.ErrorRate,
        )</span>
}

// GetMetrics returns current metrics
func (h *BaseEventHandler) GetMetrics() *EventHandlerMetrics <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := &amp;EventHandlerMetrics{
                TotalProcessed:   h.metrics.TotalProcessed,
                TotalErrors:      h.metrics.TotalErrors,
                TotalRetries:     h.metrics.TotalRetries,
                AverageLatency:   h.metrics.AverageLatency,
                ProcessingRate:   h.metrics.ProcessingRate,
                ErrorRate:        h.metrics.ErrorRate,
                LastProcessedAt:  h.metrics.LastProcessedAt,
                EventTypeMetrics: make(map[domain.EventType]int64),
                HandlerMetrics:   make(map[string]int64),
                ReplayMetrics:    make(map[string]int64),
        }

        // Copy maps
        for k, v := range h.metrics.EventTypeMetrics </span><span class="cov0" title="0">{
                metrics.EventTypeMetrics[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range h.metrics.HandlerMetrics </span><span class="cov0" title="0">{
                metrics.HandlerMetrics[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range h.metrics.ReplayMetrics </span><span class="cov0" title="0">{
                metrics.ReplayMetrics[k] = v
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// NotificationEventHandler handles events that require notifications
type NotificationEventHandler struct {
        *BaseEventHandler
        reviewService       domain.ReviewService
        notificationService NotificationService
}

// NotificationService represents the interface for sending notifications
type NotificationService interface {
        SendEmail(ctx context.Context, to []string, subject, body string) error
        SendSlack(ctx context.Context, channel, message string) error
        SendWebhook(ctx context.Context, url string, payload interface{}) error
        SendSMS(ctx context.Context, to []string, message string) error
}

// NewNotificationEventHandler creates a new notification event handler
func NewNotificationEventHandler(
        config *EventHandlerConfig,
        logger *logger.Logger,
        reviewService domain.ReviewService,
        notificationService NotificationService,
) *NotificationEventHandler <span class="cov0" title="0">{
        base := NewBaseEventHandler("notification", config, logger)

        return &amp;NotificationEventHandler{
                BaseEventHandler:    base,
                reviewService:       reviewService,
                notificationService: notificationService,
        }
}</span>

// handleEvent handles notification events
func (h *NotificationEventHandler) handleEvent(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        switch event.GetType() </span>{
        case domain.FileProcessingStartedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingStarted(ctx, event, result)</span>
        case domain.FileProcessingCompletedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingCompleted(ctx, event, result)</span>
        case domain.FileProcessingFailedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingFailed(ctx, event, result)</span>
        case domain.ReviewBatchProcessedEventType:<span class="cov0" title="0">
                return h.handleReviewBatchProcessed(ctx, event, result)</span>
        case domain.SystemErrorEvent:<span class="cov0" title="0">
                return h.handleSystemError(ctx, event, result)</span>
        default:<span class="cov0" title="0">
                return nil</span> // Ignore unknown events
        }
}

// handleFileProcessingStarted handles file processing started events
func (h *NotificationEventHandler) handleFileProcessingStarted(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        startedEvent, ok := event.(*domain.FileProcessingStartedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingStartedEvent, got %T", event)
        }</span>

        // Send notification for large files
        <span class="cov0" title="0">if startedEvent.FileSize &gt; 100*1024*1024 </span><span class="cov0" title="0">{ // 100MB
                message := fmt.Sprintf("Large file processing started: %s (%.2f MB)",
                        startedEvent.FileName, float64(startedEvent.FileSize)/(1024*1024))

                if err := h.notificationService.SendSlack(ctx, "processing-alerts", message); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to send Slack notification", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">result.Metadata["notification_sent"] = "slack"</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleFileProcessingCompleted handles file processing completed events
func (h *NotificationEventHandler) handleFileProcessingCompleted(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        completedEvent, ok := event.(*domain.FileProcessingCompletedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingCompletedEvent, got %T", event)
        }</span>

        // Send completion notification
        <span class="cov0" title="0">message := fmt.Sprintf("File processing completed: %d records processed in %s",
                completedEvent.RecordsProcessed, completedEvent.ProcessingDuration)

        if err := h.notificationService.SendSlack(ctx, "processing-status", message); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to send completion notification", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["notification_sent"] = "slack"
        result.Metadata["records_processed"] = completedEvent.RecordsProcessed

        return nil</span>
}

// handleFileProcessingFailed handles file processing failed events
func (h *NotificationEventHandler) handleFileProcessingFailed(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        failedEvent, ok := event.(*domain.FileProcessingFailedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingFailedEvent, got %T", event)
        }</span>

        // Send failure alert
        <span class="cov0" title="0">message := fmt.Sprintf("üö® File processing failed: %s (Retry %d/%d)",
                failedEvent.ErrorMessage, failedEvent.RetryCount, failedEvent.MaxRetries)

        if err := h.notificationService.SendSlack(ctx, "processing-alerts", message); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to send failure notification", "error", err)
                return err
        }</span>

        // Send email for critical failures
        <span class="cov0" title="0">if failedEvent.RetryCount &gt;= failedEvent.MaxRetries </span><span class="cov0" title="0">{
                subject := "Critical: File Processing Failed"
                body := fmt.Sprintf("Job %s has failed after %d retries.\n\nError: %s\n\nJob Details:\n%+v",
                        failedEvent.JobID, failedEvent.RetryCount, failedEvent.ErrorMessage, failedEvent)

                if err := h.notificationService.SendEmail(ctx, []string{"ops@company.com"}, subject, body); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to send email notification", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">result.Metadata["critical_alert_sent"] = true</span>
        }

        <span class="cov0" title="0">result.Metadata["notification_sent"] = "slack"
        return nil</span>
}

// handleReviewBatchProcessed handles review batch processed events
func (h *NotificationEventHandler) handleReviewBatchProcessed(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        batchEvent, ok := event.(*domain.ReviewBatchProcessedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewBatchProcessedEvent, got %T", event)
        }</span>

        // Send notification for large batches
        <span class="cov0" title="0">if batchEvent.BatchSize &gt; 1000 </span><span class="cov0" title="0">{
                message := fmt.Sprintf("Large review batch processed: %d reviews in %s",
                        batchEvent.ReviewsProcessed, batchEvent.ProcessingTime)

                if err := h.notificationService.SendSlack(ctx, "processing-status", message); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to send batch notification", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">result.Metadata["notification_sent"] = "slack"</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleSystemError handles system error events
func (h *NotificationEventHandler) handleSystemError(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        // Send critical system error notifications
        message := fmt.Sprintf("üö® System Error: %s", event.GetMetadata()["error"])

        if err := h.notificationService.SendSlack(ctx, "system-alerts", message); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to send system error notification", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["notification_sent"] = "slack"
        return nil</span>
}

// CanHandle returns true if this handler can handle the event type
func (h *NotificationEventHandler) CanHandle(eventType domain.EventType) bool <span class="cov0" title="0">{
        switch eventType </span>{
        case domain.FileProcessingStartedEventType,
                domain.FileProcessingCompletedEventType,
                domain.FileProcessingFailedEventType,
                domain.ReviewBatchProcessedEventType,
                domain.SystemErrorEvent:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetHandledEventTypes returns the event types this handler can handle
func (h *NotificationEventHandler) GetHandledEventTypes() []domain.EventType <span class="cov0" title="0">{
        return []domain.EventType{
                domain.FileProcessingStartedEventType,
                domain.FileProcessingCompletedEventType,
                domain.FileProcessingFailedEventType,
                domain.ReviewBatchProcessedEventType,
                domain.SystemErrorEvent,
        }
}</span>

// MetricsEventHandler handles events for metrics collection
type MetricsEventHandler struct {
        *BaseEventHandler
        metricsCollector MetricsCollector
}

// MetricsCollector represents the interface for collecting metrics
type MetricsCollector interface {
        IncrementCounter(name string, tags map[string]string, value float64) error
        RecordGauge(name string, tags map[string]string, value float64) error
        RecordHistogram(name string, tags map[string]string, value float64) error
        RecordTimer(name string, tags map[string]string, duration time.Duration) error
}

// NewMetricsEventHandler creates a new metrics event handler
func NewMetricsEventHandler(
        config *EventHandlerConfig,
        logger *logger.Logger,
        metricsCollector MetricsCollector,
) *MetricsEventHandler <span class="cov0" title="0">{
        base := NewBaseEventHandler("metrics", config, logger)

        return &amp;MetricsEventHandler{
                BaseEventHandler: base,
                metricsCollector: metricsCollector,
        }
}</span>

// handleEvent handles metrics collection events
func (h *MetricsEventHandler) handleEvent(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        switch event.GetType() </span>{
        case domain.FileProcessingStartedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingStartedMetrics(ctx, event, result)</span>
        case domain.FileProcessingCompletedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingCompletedMetrics(ctx, event, result)</span>
        case domain.FileProcessingFailedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingFailedMetrics(ctx, event, result)</span>
        case domain.ReviewProcessedEventType:<span class="cov0" title="0">
                return h.handleReviewProcessedMetrics(ctx, event, result)</span>
        case domain.ReviewBatchProcessedEventType:<span class="cov0" title="0">
                return h.handleReviewBatchProcessedMetrics(ctx, event, result)</span>
        default:<span class="cov0" title="0">
                return nil</span> // Ignore unknown events
        }
}

// handleFileProcessingStartedMetrics handles metrics for file processing started events
func (h *MetricsEventHandler) handleFileProcessingStartedMetrics(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        startedEvent, ok := event.(*domain.FileProcessingStartedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingStartedEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "provider": startedEvent.ProviderName,
                "priority": fmt.Sprintf("%d", startedEvent.Priority),
        }

        // Increment processing started counter
        if err := h.metricsCollector.IncrementCounter("file_processing_started", tags, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record file size
        <span class="cov0" title="0">if err := h.metricsCollector.RecordGauge("file_size_bytes", tags, float64(startedEvent.FileSize)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record estimated records
        <span class="cov0" title="0">if err := h.metricsCollector.RecordGauge("estimated_records", tags, float64(startedEvent.EstimatedRecords)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["metrics_recorded"] = []string{"file_processing_started", "file_size_bytes", "estimated_records"}
        return nil</span>
}

// handleFileProcessingCompletedMetrics handles metrics for file processing completed events
func (h *MetricsEventHandler) handleFileProcessingCompletedMetrics(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        completedEvent, ok := event.(*domain.FileProcessingCompletedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingCompletedEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "status": "completed",
        }

        // Increment processing completed counter
        if err := h.metricsCollector.IncrementCounter("file_processing_completed", tags, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record processing duration
        <span class="cov0" title="0">if err := h.metricsCollector.RecordTimer("processing_duration", tags, completedEvent.ProcessingDuration); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record records processed
        <span class="cov0" title="0">if err := h.metricsCollector.RecordGauge("records_processed", tags, float64(completedEvent.RecordsProcessed)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record processing rate
        <span class="cov0" title="0">if err := h.metricsCollector.RecordGauge("processing_rate", tags, completedEvent.ProcessingRate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["metrics_recorded"] = []string{"file_processing_completed", "processing_duration", "records_processed", "processing_rate"}
        return nil</span>
}

// handleFileProcessingFailedMetrics handles metrics for file processing failed events
func (h *MetricsEventHandler) handleFileProcessingFailedMetrics(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        failedEvent, ok := event.(*domain.FileProcessingFailedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingFailedEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "status":     "failed",
                "error_type": failedEvent.ErrorType,
                "retryable":  fmt.Sprintf("%t", failedEvent.IsRetryable),
        }

        // Increment processing failed counter
        if err := h.metricsCollector.IncrementCounter("file_processing_failed", tags, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record retry count
        <span class="cov0" title="0">if err := h.metricsCollector.RecordHistogram("retry_count", tags, float64(failedEvent.RetryCount)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["metrics_recorded"] = []string{"file_processing_failed", "retry_count"}
        return nil</span>
}

// handleReviewProcessedMetrics handles metrics for review processed events
func (h *MetricsEventHandler) handleReviewProcessedMetrics(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        reviewEvent, ok := event.(*domain.ReviewProcessedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewProcessedEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "sentiment": reviewEvent.Sentiment,
                "language":  reviewEvent.Language,
        }

        // Increment review processed counter
        if err := h.metricsCollector.IncrementCounter("review_processed", tags, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record rating
        <span class="cov0" title="0">if err := h.metricsCollector.RecordHistogram("review_rating", tags, reviewEvent.Rating); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record word count
        <span class="cov0" title="0">if err := h.metricsCollector.RecordHistogram("review_word_count", tags, float64(reviewEvent.WordCount)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["metrics_recorded"] = []string{"review_processed", "review_rating", "review_word_count"}
        return nil</span>
}

// handleReviewBatchProcessedMetrics handles metrics for review batch processed events
func (h *MetricsEventHandler) handleReviewBatchProcessedMetrics(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        batchEvent, ok := event.(*domain.ReviewBatchProcessedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewBatchProcessedEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "batch_id": batchEvent.BatchID,
        }

        // Increment batch processed counter
        if err := h.metricsCollector.IncrementCounter("review_batch_processed", tags, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record batch size
        <span class="cov0" title="0">if err := h.metricsCollector.RecordHistogram("batch_size", tags, float64(batchEvent.BatchSize)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record processing time
        <span class="cov0" title="0">if err := h.metricsCollector.RecordTimer("batch_processing_time", tags, batchEvent.ProcessingTime); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record success rate
        <span class="cov0" title="0">successRate := float64(batchEvent.ReviewsProcessed) / float64(batchEvent.BatchSize) * 100
        if err := h.metricsCollector.RecordGauge("batch_success_rate", tags, successRate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result.Metadata["metrics_recorded"] = []string{"review_batch_processed", "batch_size", "batch_processing_time", "batch_success_rate"}
        return nil</span>
}

// CanHandle returns true if this handler can handle the event type
func (h *MetricsEventHandler) CanHandle(eventType domain.EventType) bool <span class="cov0" title="0">{
        switch eventType </span>{
        case domain.FileProcessingStartedEventType,
                domain.FileProcessingCompletedEventType,
                domain.FileProcessingFailedEventType,
                domain.ReviewProcessedEventType,
                domain.ReviewBatchProcessedEventType:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetHandledEventTypes returns the event types this handler can handle
func (h *MetricsEventHandler) GetHandledEventTypes() []domain.EventType <span class="cov0" title="0">{
        return []domain.EventType{
                domain.FileProcessingStartedEventType,
                domain.FileProcessingCompletedEventType,
                domain.FileProcessingFailedEventType,
                domain.ReviewProcessedEventType,
                domain.ReviewBatchProcessedEventType,
        }
}</span>

// StateUpdateEventHandler handles events for state updates and projections
type StateUpdateEventHandler struct {
        *BaseEventHandler
        reviewService   domain.ReviewService
        projectionStore ProjectionStore
}

// ProjectionStore represents the interface for projection storage
type ProjectionStore interface {
        UpdateHotelSummary(ctx context.Context, hotelID uuid.UUID, summary interface{}) error
        UpdateProviderStats(ctx context.Context, providerID uuid.UUID, stats interface{}) error
        UpdateProcessingStats(ctx context.Context, jobID uuid.UUID, stats interface{}) error
        UpdateReviewAnalytics(ctx context.Context, reviewID uuid.UUID, analytics interface{}) error
}

// NewStateUpdateEventHandler creates a new state update event handler
func NewStateUpdateEventHandler(
        config *EventHandlerConfig,
        logger *logger.Logger,
        reviewService domain.ReviewService,
        projectionStore ProjectionStore,
) *StateUpdateEventHandler <span class="cov0" title="0">{
        base := NewBaseEventHandler("state_update", config, logger)

        return &amp;StateUpdateEventHandler{
                BaseEventHandler: base,
                reviewService:    reviewService,
                projectionStore:  projectionStore,
        }
}</span>

// handleEvent handles state update events
func (h *StateUpdateEventHandler) handleEvent(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        switch event.GetType() </span>{
        case domain.ReviewProcessedEventType:<span class="cov0" title="0">
                return h.handleReviewProcessedStateUpdate(ctx, event, result)</span>
        case domain.ReviewBatchProcessedEventType:<span class="cov0" title="0">
                return h.handleReviewBatchProcessedStateUpdate(ctx, event, result)</span>
        case domain.FileProcessingCompletedEventType:<span class="cov0" title="0">
                return h.handleFileProcessingCompletedStateUpdate(ctx, event, result)</span>
        case domain.HotelSummaryUpdatedEventType:<span class="cov0" title="0">
                return h.handleHotelSummaryUpdatedStateUpdate(ctx, event, result)</span>
        default:<span class="cov0" title="0">
                return nil</span> // Ignore unknown events
        }
}

// handleReviewProcessedStateUpdate handles state updates for review processed events
func (h *StateUpdateEventHandler) handleReviewProcessedStateUpdate(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        reviewEvent, ok := event.(*domain.ReviewProcessedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewProcessedEvent, got %T", event)
        }</span>

        // Update review analytics projection
        <span class="cov0" title="0">analytics := map[string]interface{}{
                "review_id":       reviewEvent.ReviewID,
                "sentiment":       reviewEvent.Sentiment,
                "language":        reviewEvent.Language,
                "word_count":      reviewEvent.WordCount,
                "rating":          reviewEvent.Rating,
                "processed_at":    reviewEvent.ProcessedAt,
                "enrichment_data": reviewEvent.EnrichmentData,
        }

        if err := h.projectionStore.UpdateReviewAnalytics(ctx, reviewEvent.ReviewID, analytics); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update review analytics: %w", err)
        }</span>

        <span class="cov0" title="0">result.Metadata["projection_updated"] = "review_analytics"
        return nil</span>
}

// handleReviewBatchProcessedStateUpdate handles state updates for review batch processed events
func (h *StateUpdateEventHandler) handleReviewBatchProcessedStateUpdate(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        batchEvent, ok := event.(*domain.ReviewBatchProcessedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewBatchProcessedEvent, got %T", event)
        }</span>

        // Update hotel summaries for affected hotels
        <span class="cov0" title="0">for hotelID, reviewCount := range batchEvent.HotelStats </span><span class="cov0" title="0">{
                summary := map[string]interface{}{
                        "hotel_id":         hotelID,
                        "new_review_count": reviewCount,
                        "batch_id":         batchEvent.BatchID,
                        "processing_time":  batchEvent.ProcessingTime,
                        "last_updated":     batchEvent.ProcessedAt,
                }

                if err := h.projectionStore.UpdateHotelSummary(ctx, hotelID, summary); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to update hotel summary",
                                "hotel_id", hotelID,
                                "error", err,
                        )
                        // Continue with other hotels instead of failing completely
                }</span>
        }

        // Update provider stats
        <span class="cov0" title="0">stats := map[string]interface{}{
                "provider_id":       batchEvent.ProviderID,
                "batch_id":          batchEvent.BatchID,
                "reviews_processed": batchEvent.ReviewsProcessed,
                "reviews_failed":    batchEvent.ReviewsFailed,
                "processing_time":   batchEvent.ProcessingTime,
                "validation_stats":  batchEvent.ValidationStats,
                "enrichment_stats":  batchEvent.EnrichmentStats,
                "last_updated":      batchEvent.ProcessedAt,
        }

        if err := h.projectionStore.UpdateProviderStats(ctx, batchEvent.ProviderID, stats); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update provider stats: %w", err)
        }</span>

        <span class="cov0" title="0">result.Metadata["projections_updated"] = []string{"hotel_summary", "provider_stats"}
        return nil</span>
}

// handleFileProcessingCompletedStateUpdate handles state updates for file processing completed events
func (h *StateUpdateEventHandler) handleFileProcessingCompletedStateUpdate(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        completedEvent, ok := event.(*domain.FileProcessingCompletedEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileProcessingCompletedEvent, got %T", event)
        }</span>

        // Update processing stats
        <span class="cov0" title="0">stats := map[string]interface{}{
                "job_id":              completedEvent.JobID,
                "records_processed":   completedEvent.RecordsProcessed,
                "records_total":       completedEvent.RecordsTotal,
                "records_failed":      completedEvent.RecordsFailed,
                "records_skipped":     completedEvent.RecordsSkipped,
                "processing_duration": completedEvent.ProcessingDuration,
                "processing_rate":     completedEvent.ProcessingRate,
                "completed_at":        completedEvent.CompletedAt,
                "summary":             completedEvent.Summary,
                "metrics":             completedEvent.Metrics,
        }

        if err := h.projectionStore.UpdateProcessingStats(ctx, completedEvent.JobID, stats); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update processing stats: %w", err)
        }</span>

        <span class="cov0" title="0">result.Metadata["projection_updated"] = "processing_stats"
        return nil</span>
}

// handleHotelSummaryUpdatedStateUpdate handles state updates for hotel summary updated events
func (h *StateUpdateEventHandler) handleHotelSummaryUpdatedStateUpdate(ctx context.Context, event domain.DomainEvent, result *EventHandlerResult) error <span class="cov0" title="0">{
        // This would handle HotelSummaryUpdatedEvent when it's implemented
        // For now, we'll just log it
        h.logger.Info("Hotel summary updated event received", "event_id", event.GetID())
        return nil
}</span>

// CanHandle returns true if this handler can handle the event type
func (h *StateUpdateEventHandler) CanHandle(eventType domain.EventType) bool <span class="cov0" title="0">{
        switch eventType </span>{
        case domain.ReviewProcessedEventType,
                domain.ReviewBatchProcessedEventType,
                domain.FileProcessingCompletedEventType,
                domain.HotelSummaryUpdatedEventType:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetHandledEventTypes returns the event types this handler can handle
func (h *StateUpdateEventHandler) GetHandledEventTypes() []domain.EventType <span class="cov0" title="0">{
        return []domain.EventType{
                domain.ReviewProcessedEventType,
                domain.ReviewBatchProcessedEventType,
                domain.FileProcessingCompletedEventType,
                domain.HotelSummaryUpdatedEventType,
        }
}</span>

// EventHandlerRegistry manages all event handlers
type EventHandlerRegistry struct {
        handlers map[domain.EventType][]domain.EventHandler
        mu       sync.RWMutex
        logger   *logger.Logger
        started  bool
}

// NewEventHandlerRegistry creates a new event handler registry
func NewEventHandlerRegistry(logger *logger.Logger) *EventHandlerRegistry <span class="cov0" title="0">{
        return &amp;EventHandlerRegistry{
                handlers: make(map[domain.EventType][]domain.EventHandler),
                logger:   logger,
        }
}</span>

// RegisterHandler registers an event handler for specific event types
func (r *EventHandlerRegistry) RegisterHandler(handler domain.EventHandler, eventTypes ...domain.EventType) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for _, eventType := range eventTypes </span><span class="cov0" title="0">{
                if r.handlers[eventType] == nil </span><span class="cov0" title="0">{
                        r.handlers[eventType] = make([]domain.EventHandler, 0)
                }</span>
                <span class="cov0" title="0">r.handlers[eventType] = append(r.handlers[eventType], handler)</span>
        }

        <span class="cov0" title="0">r.logger.Info("Event handler registered",
                "handler", fmt.Sprintf("%T", handler),
                "event_types", eventTypes,
        )

        return nil</span>
}

// UnregisterHandler unregisters an event handler
func (r *EventHandlerRegistry) UnregisterHandler(handler domain.EventHandler, eventTypes ...domain.EventType) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for _, eventType := range eventTypes </span><span class="cov0" title="0">{
                if handlers, exists := r.handlers[eventType]; exists </span><span class="cov0" title="0">{
                        // Remove the handler from the slice
                        for i, h := range handlers </span><span class="cov0" title="0">{
                                if h == handler </span><span class="cov0" title="0">{
                                        r.handlers[eventType] = append(handlers[:i], handlers[i+1:]...)
                                        break</span>
                                }
                        }

                        // Remove the event type if no handlers remain
                        <span class="cov0" title="0">if len(r.handlers[eventType]) == 0 </span><span class="cov0" title="0">{
                                delete(r.handlers, eventType)
                        }</span>
                }
        }

        <span class="cov0" title="0">r.logger.Info("Event handler unregistered",
                "handler", fmt.Sprintf("%T", handler),
                "event_types", eventTypes,
        )

        return nil</span>
}

// HandleEvent handles an event by dispatching it to all registered handlers
func (r *EventHandlerRegistry) HandleEvent(ctx context.Context, event domain.DomainEvent) error <span class="cov0" title="0">{
        r.mu.RLock()
        handlers, exists := r.handlers[event.GetType()]
        r.mu.RUnlock()

        if !exists || len(handlers) == 0 </span><span class="cov0" title="0">{
                r.logger.Debug("No handlers registered for event type",
                        "event_type", event.GetType(),
                        "event_id", event.GetID(),
                )
                return nil
        }</span>

        // Handle event with all registered handlers
        <span class="cov0" title="0">var errors []error
        for _, handler := range handlers </span><span class="cov0" title="0">{
                if handler.CanHandle(event.GetType()) </span><span class="cov0" title="0">{
                        if err := handler.HandleEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Errorf("handler %T failed: %w", handler, err))
                        }</span>
                }
        }

        // Return combined errors if any
        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("event handling failed: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHandlers returns all handlers for an event type
func (r *EventHandlerRegistry) GetHandlers(eventType domain.EventType) []domain.EventHandler <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        handlers, exists := r.handlers[eventType]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy to prevent modification
        <span class="cov0" title="0">result := make([]domain.EventHandler, len(handlers))
        copy(result, handlers)
        return result</span>
}

// GetRegisteredEventTypes returns all registered event types
func (r *EventHandlerRegistry) GetRegisteredEventTypes() []domain.EventType <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        eventTypes := make([]domain.EventType, 0, len(r.handlers))
        for eventType := range r.handlers </span><span class="cov0" title="0">{
                eventTypes = append(eventTypes, eventType)
        }</span>

        <span class="cov0" title="0">return eventTypes</span>
}

// Start starts all handlers that implement a Start method
func (r *EventHandlerRegistry) Start() error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.started </span><span class="cov0" title="0">{
                return fmt.Errorf("event handler registry already started")
        }</span>

        // Start all handlers that have a Start method
        <span class="cov0" title="0">for _, handlerSlice := range r.handlers </span><span class="cov0" title="0">{
                for _, handler := range handlerSlice </span><span class="cov0" title="0">{
                        if starter, ok := handler.(interface{ Start() error }); ok </span><span class="cov0" title="0">{
                                if err := starter.Start(); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to start handler %T: %w", handler, err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">r.started = true
        r.logger.Info("Event handler registry started")
        return nil</span>
}

// Stop stops all handlers that implement a Stop method
func (r *EventHandlerRegistry) Stop() error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if !r.started </span><span class="cov0" title="0">{
                return fmt.Errorf("event handler registry not started")
        }</span>

        // Stop all handlers that have a Stop method
        <span class="cov0" title="0">var errors []error
        for _, handlerSlice := range r.handlers </span><span class="cov0" title="0">{
                for _, handler := range handlerSlice </span><span class="cov0" title="0">{
                        if stopper, ok := handler.(interface{ Stop() error }); ok </span><span class="cov0" title="0">{
                                if err := stopper.Stop(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, fmt.Errorf("failed to stop handler %T: %w", handler, err))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">r.started = false
        r.logger.Info("Event handler registry stopped")

        // Return combined errors if any
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors stopping handlers: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMetrics returns metrics for all handlers that support metrics
func (r *EventHandlerRegistry) GetMetrics() map[string]*EventHandlerMetrics <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        metrics := make(map[string]*EventHandlerMetrics)

        for _, handlerSlice := range r.handlers </span><span class="cov0" title="0">{
                for _, handler := range handlerSlice </span><span class="cov0" title="0">{
                        if metricsProvider, ok := handler.(interface{ GetMetrics() *EventHandlerMetrics }); ok </span><span class="cov0" title="0">{
                                handlerName := fmt.Sprintf("%T", handler)
                                metrics[handlerName] = metricsProvider.GetMetrics()
                        }</span>
                }
        }

        <span class="cov0" title="0">return metrics</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package application

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/google/uuid"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

type HotelHandlers struct {
        hotelService domain.HotelService
        logger       *logger.Logger
}

func NewHotelHandlers(hotelService domain.HotelService, logger *logger.Logger) *HotelHandlers <span class="cov1" title="1">{
        return &amp;HotelHandlers{
                hotelService: hotelService,
                logger:       logger,
        }
}</span>

// GetHotels handles GET /api/v1/hotels
func (h *HotelHandlers) GetHotels(c *gin.Context) <span class="cov0" title="0">{
        // Parse query parameters
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        city := c.Query("city")
        country := c.Query("country")
        minRating, _ := strconv.Atoi(c.Query("min_rating"))
        maxRating, _ := strconv.Atoi(c.Query("max_rating"))

        // Validate pagination parameters
        if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Create filter
        <span class="cov0" title="0">filter := domain.HotelFilter{
                City:      city,
                Country:   country,
                MinRating: minRating,
                MaxRating: maxRating,
                Limit:     limit,
                Offset:    offset,
        }

        // Get hotels from service
        hotels, err := h.hotelService.GetHotels(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(c.Request.Context(), "Failed to get hotels", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to retrieve hotels",
                })
                return
        }</span>

        // Return response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "hotels": hotels,
                "pagination": gin.H{
                        "limit":  limit,
                        "offset": offset,
                        "total":  len(hotels), // In a real implementation, this would be a separate count query
                },
        })</span>
}

// GetHotel handles GET /api/v1/hotels/:id
func (h *HotelHandlers) GetHotel(c *gin.Context) <span class="cov10" title="3">{
        // Parse hotel ID
        hotelIDStr := c.Param("id")
        hotelID, err := uuid.Parse(hotelIDStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid hotel ID format",
                })
                return
        }</span>

        // Get hotel from service
        <span class="cov6" title="2">hotel, err := h.hotelService.GetHotel(c.Request.Context(), hotelID)
        if err != nil </span><span class="cov1" title="1">{
                if err == domain.ErrHotelNotFound </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "HOTEL_NOT_FOUND",
                                "message": "Hotel not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">h.logger.ErrorContext(c.Request.Context(), "Failed to get hotel", "error", err, "hotel_id", hotelID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to retrieve hotel",
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, hotel)</span>
}

// CreateHotel handles POST /api/v1/hotels
func (h *HotelHandlers) CreateHotel(c *gin.Context) <span class="cov10" title="3">{
        var hotel domain.Hotel
        if err := c.ShouldBindJSON(&amp;hotel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_INPUT",
                        "message": "Invalid hotel data",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="3">if err := h.validateHotelInput(&amp;hotel); err != nil </span><span class="cov6" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "VALIDATION_FAILED",
                        "message": err.Error(),
                })
                return
        }</span>

        // Generate ID if not provided
        <span class="cov1" title="1">if hotel.ID == uuid.Nil </span><span class="cov1" title="1">{
                hotel.ID = uuid.New()
        }</span>

        // Create hotel
        <span class="cov1" title="1">if err := h.hotelService.CreateHotel(c.Request.Context(), &amp;hotel); err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrHotelAlreadyExists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{
                                "error":   "HOTEL_ALREADY_EXISTS",
                                "message": "Hotel already exists",
                        })
                        return
                }</span>

                // Check if it's a validation error from the service
                <span class="cov0" title="0">if strings.Contains(err.Error(), "validation failed") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "VALIDATION_FAILED",
                                "message": err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">h.logger.ErrorContext(c.Request.Context(), "Failed to create hotel", "error", err, "hotel", hotel)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to create hotel",
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{
                "message": "Hotel created successfully",
                "hotel":   hotel,
        })</span>
}

// UpdateHotel handles PUT /api/v1/hotels/:id
func (h *HotelHandlers) UpdateHotel(c *gin.Context) <span class="cov0" title="0">{
        // Parse hotel ID
        hotelIDStr := c.Param("id")
        hotelID, err := uuid.Parse(hotelIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid hotel ID format",
                })
                return
        }</span>

        <span class="cov0" title="0">var hotel domain.Hotel
        if err := c.ShouldBindJSON(&amp;hotel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_INPUT",
                        "message": "Invalid hotel data",
                        "details": err.Error(),
                })
                return
        }</span>

        // Set the ID from URL
        <span class="cov0" title="0">hotel.ID = hotelID

        // Validate input
        if err := h.validateHotelInput(&amp;hotel); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "VALIDATION_ERROR",
                        "message": err.Error(),
                })
                return
        }</span>

        // Update hotel
        <span class="cov0" title="0">if err := h.hotelService.UpdateHotel(c.Request.Context(), &amp;hotel); err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrHotelNotFound </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "HOTEL_NOT_FOUND",
                                "message": "Hotel not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">h.logger.ErrorContext(c.Request.Context(), "Failed to update hotel", "error", err, "hotel_id", hotelID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to update hotel",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, hotel)</span>
}

// DeleteHotel handles DELETE /api/v1/hotels/:id
func (h *HotelHandlers) DeleteHotel(c *gin.Context) <span class="cov0" title="0">{
        // Parse hotel ID
        hotelIDStr := c.Param("id")
        hotelID, err := uuid.Parse(hotelIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid hotel ID format",
                })
                return
        }</span>

        // Delete hotel
        <span class="cov0" title="0">if err := h.hotelService.DeleteHotel(c.Request.Context(), hotelID); err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrHotelNotFound </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "HOTEL_NOT_FOUND",
                                "message": "Hotel not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">h.logger.ErrorContext(c.Request.Context(), "Failed to delete hotel", "error", err, "hotel_id", hotelID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to delete hotel",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// validateHotelInput validates hotel input data
func (h *HotelHandlers) validateHotelInput(hotel *domain.Hotel) error <span class="cov10" title="3">{
        if hotel.Name == "" </span><span class="cov1" title="1">{
                return domain.NewValidationError("name", "Hotel name is required")
        }</span>
        <span class="cov6" title="2">if len(hotel.Name) &lt; 2 </span><span class="cov0" title="0">{
                return domain.NewValidationError("name", "Hotel name must be at least 2 characters")
        }</span>
        <span class="cov6" title="2">if len(hotel.Name) &gt; 100 </span><span class="cov0" title="0">{
                return domain.NewValidationError("name", "Hotel name must be less than 100 characters")
        }</span>

        <span class="cov6" title="2">if hotel.Address == "" </span><span class="cov1" title="1">{
                return domain.NewValidationError("address", "Hotel address is required")
        }</span>
        <span class="cov1" title="1">if len(hotel.Address) &gt; 255 </span><span class="cov0" title="0">{
                return domain.NewValidationError("address", "Hotel address must be less than 255 characters")
        }</span>

        <span class="cov1" title="1">if hotel.City == "" </span><span class="cov0" title="0">{
                return domain.NewValidationError("city", "Hotel city is required")
        }</span>
        <span class="cov1" title="1">if len(hotel.City) &gt; 100 </span><span class="cov0" title="0">{
                return domain.NewValidationError("city", "Hotel city must be less than 100 characters")
        }</span>

        <span class="cov1" title="1">if hotel.Country == "" </span><span class="cov0" title="0">{
                return domain.NewValidationError("country", "Hotel country is required")
        }</span>
        <span class="cov1" title="1">if len(hotel.Country) &gt; 100 </span><span class="cov0" title="0">{
                return domain.NewValidationError("country", "Hotel country must be less than 100 characters")
        }</span>

        <span class="cov1" title="1">if hotel.StarRating &lt; 0 || hotel.StarRating &gt; 5 </span><span class="cov0" title="0">{
                return domain.NewValidationError("star_rating", "Star rating must be between 0 and 5")
        }</span>

        <span class="cov1" title="1">if hotel.Email != "" &amp;&amp; !isValidEmail(hotel.Email) </span><span class="cov0" title="0">{
                return domain.NewValidationError("email", "Invalid email format")
        }</span>

        <span class="cov1" title="1">if len(hotel.Description) &gt; 1000 </span><span class="cov0" title="0">{
                return domain.NewValidationError("description", "Description must be less than 1000 characters")
        }</span>

        // Validate coordinates if provided
        <span class="cov1" title="1">if hotel.Latitude != 0 || hotel.Longitude != 0 </span><span class="cov0" title="0">{
                if hotel.Latitude &lt; -90 || hotel.Latitude &gt; 90 </span><span class="cov0" title="0">{
                        return domain.NewValidationError("latitude", "Latitude must be between -90 and 90")
                }</span>
                <span class="cov0" title="0">if hotel.Longitude &lt; -180 || hotel.Longitude &gt; 180 </span><span class="cov0" title="0">{
                        return domain.NewValidationError("longitude", "Longitude must be between -180 and 180")
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Helper function to validate email format
func isValidEmail(email string) bool <span class="cov0" title="0">{
        // Basic email validation - in production, use a proper email validation library
        return len(email) &gt; 0 &amp;&amp; 
                   len(email) &lt;= 254 &amp;&amp; 
                   containsAt(email) &amp;&amp; 
                   containsDot(email)
}</span>

func containsAt(s string) bool <span class="cov0" title="0">{
        for _, c := range s </span><span class="cov0" title="0">{
                if c == '@' </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func containsDot(s string) bool <span class="cov0" title="0">{
        for _, c := range s </span><span class="cov0" title="0">{
                if c == '.' </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package application

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ProcessingEngine orchestrates file processing with worker pools and concurrency control
type ProcessingEngine struct {
        reviewService domain.ReviewService
        s3Client      domain.S3Client
        jsonProcessor domain.JSONProcessor
        logger        *logger.Logger

        // Worker pool configuration
        maxWorkers         int
        maxConcurrentFiles int
        workerPool         chan *worker
        fileQueue          chan *ProcessingJob

        // Processing state
        activeJobs map[uuid.UUID]*ProcessingJob
        jobsMutex  sync.RWMutex

        // Metrics and monitoring
        metrics *ProcessingMetrics

        // Lifecycle management
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
        started  bool
        shutdown chan struct{}
}

// ProcessingJob represents a file processing job
type ProcessingJob struct {
        mu               sync.RWMutex
        ID               uuid.UUID
        ProviderID       uuid.UUID
        FileURL          string
        Status           ProcessingStatus
        StartTime        time.Time
        EndTime          time.Time
        RecordsTotal     int64
        RecordsProcessed int64
        ErrorCount       int64
        ErrorMessage     string
        RetryCount       int
        MaxRetries       int
        Worker           *worker
        Context          context.Context
        Cancel           context.CancelFunc
}

// ProcessingStatus represents the status of a processing job
type ProcessingStatus string

const (
        StatusPending   ProcessingStatus = "pending"
        StatusRunning   ProcessingStatus = "running"
        StatusCompleted ProcessingStatus = "completed"
        StatusFailed    ProcessingStatus = "failed"
        StatusCancelled ProcessingStatus = "cancelled"
        StatusRetrying  ProcessingStatus = "retrying"
)

// worker represents a processing worker
type worker struct {
        mu           sync.RWMutex
        id           int
        engine       *ProcessingEngine
        busy         bool
        currentJob   *ProcessingJob
        lastActivity time.Time
}

// ProcessingMetrics tracks processing statistics
type ProcessingMetrics struct {
        mu                    sync.RWMutex
        TotalJobsProcessed    int64
        TotalRecordsProcessed int64
        TotalErrors           int64
        ActiveWorkers         int
        QueuedJobs            int
        ProcessingRate        float64
        AverageProcessingTime time.Duration
        LastProcessingTime    time.Time
}

// ProcessingConfig contains configuration for the processing engine
type ProcessingConfig struct {
        MaxWorkers         int
        MaxConcurrentFiles int
        MaxRetries         int
        RetryDelay         time.Duration
        ProcessingTimeout  time.Duration
        WorkerIdleTimeout  time.Duration
        MetricsInterval    time.Duration
}

// NewProcessingEngine creates a new processing engine
func NewProcessingEngine(
        reviewService domain.ReviewService,
        s3Client domain.S3Client,
        jsonProcessor domain.JSONProcessor,
        logger *logger.Logger,
        config *ProcessingConfig,
) *ProcessingEngine <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        engine := &amp;ProcessingEngine{
                reviewService:      reviewService,
                s3Client:           s3Client,
                jsonProcessor:      jsonProcessor,
                logger:             logger,
                maxWorkers:         config.MaxWorkers,
                maxConcurrentFiles: config.MaxConcurrentFiles,
                workerPool:         make(chan *worker, config.MaxWorkers),
                fileQueue:          make(chan *ProcessingJob, config.MaxConcurrentFiles*2),
                activeJobs:         make(map[uuid.UUID]*ProcessingJob),
                metrics:            &amp;ProcessingMetrics{},
                ctx:                ctx,
                cancel:             cancel,
                shutdown:           make(chan struct{}),
        }

        return engine
}</span>

// Start starts the processing engine
func (e *ProcessingEngine) Start() error <span class="cov0" title="0">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()

        if e.started </span><span class="cov0" title="0">{
                return fmt.Errorf("processing engine already started")
        }</span>

        <span class="cov0" title="0">e.logger.Info("Starting processing engine",
                "max_workers", e.maxWorkers,
                "max_concurrent_files", e.maxConcurrentFiles,
        )

        // Start worker pool
        e.startWorkerPool()

        // Start job dispatcher
        e.wg.Add(1)
        go e.jobDispatcher()

        // Start metrics collector
        e.wg.Add(1)
        go e.metricsCollector()

        e.started = true
        e.logger.Info("Processing engine started successfully")

        return nil</span>
}

// Stop stops the processing engine gracefully
func (e *ProcessingEngine) Stop() error <span class="cov0" title="0">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()

        if !e.started </span><span class="cov0" title="0">{
                return fmt.Errorf("processing engine not started")
        }</span>

        <span class="cov0" title="0">e.logger.Info("Stopping processing engine...")

        // Cancel all active jobs
        for _, job := range e.activeJobs </span><span class="cov0" title="0">{
                if job.Cancel != nil </span><span class="cov0" title="0">{
                        job.Cancel()
                }</span>
        }

        // Signal shutdown
        <span class="cov0" title="0">e.cancel()
        close(e.shutdown)

        // Wait for all goroutines to finish
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                e.wg.Wait()
                close(done)
        }</span>()

        // Mark as stopped first to prevent double stopping
        <span class="cov0" title="0">e.started = false

        // Wait for graceful shutdown with timeout
        select </span>{
        case &lt;-done:<span class="cov0" title="0">
                e.logger.Info("Processing engine stopped gracefully")
                return nil</span>
        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                e.logger.Warn("Processing engine shutdown timeout, forcing stop")
                return fmt.Errorf("shutdown timeout")</span>
        }
}

// SubmitJob submits a new file processing job
func (e *ProcessingEngine) SubmitJob(ctx context.Context, providerID uuid.UUID, fileURL string) (*ProcessingJob, error) <span class="cov0" title="0">{
        // Check if engine is started
        if !e.started </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("processing engine not started")
        }</span>

        // Validate file URL format
        <span class="cov0" title="0">_, _, err := e.parseS3URL(fileURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file URL: %w", err)
        }</span>

        // Check for idempotency
        <span class="cov0" title="0">if existingJob, exists := e.checkIdempotency(providerID, fileURL); exists </span><span class="cov0" title="0">{
                e.logger.InfoContext(ctx, "Idempotent job found, returning existing job",
                        "job_id", existingJob.ID,
                        "provider_id", providerID,
                        "file_url", fileURL,
                )
                return existingJob, nil
        }</span>

        // Create new job
        <span class="cov0" title="0">jobCtx, jobCancel := context.WithCancel(ctx)
        job := &amp;ProcessingJob{
                ID:         uuid.New(),
                ProviderID: providerID,
                FileURL:    fileURL,
                Status:     StatusPending,
                StartTime:  time.Now(),
                MaxRetries: 3,
                Context:    jobCtx,
                Cancel:     jobCancel,
        }

        // Register job
        e.jobsMutex.Lock()
        e.activeJobs[job.ID] = job
        e.jobsMutex.Unlock()

        // Submit to queue
        select </span>{
        case e.fileQueue &lt;- job:<span class="cov0" title="0">
                e.logger.InfoContext(ctx, "Job submitted successfully",
                        "job_id", job.ID,
                        "provider_id", providerID,
                        "file_url", fileURL,
                )
                return job, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                e.removeJob(job.ID)
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                e.removeJob(job.ID)
                return nil, fmt.Errorf("processing queue full, try again later")</span>
        }
}

// GetJobStatus returns the status of a processing job
func (e *ProcessingEngine) GetJobStatus(jobID uuid.UUID) (*ProcessingJob, bool) <span class="cov0" title="0">{
        e.jobsMutex.RLock()
        defer e.jobsMutex.RUnlock()

        job, exists := e.activeJobs[jobID]
        return job, exists
}</span>

// CancelJob cancels a processing job
func (e *ProcessingEngine) CancelJob(jobID uuid.UUID) error <span class="cov0" title="0">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()

        job, exists := e.activeJobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("job not found")
        }</span>

        <span class="cov0" title="0">if job.Cancel != nil </span><span class="cov0" title="0">{
                job.Cancel()
        }</span>

        <span class="cov0" title="0">job.mu.Lock()
        job.Status = StatusCancelled
        job.EndTime = time.Now()
        job.mu.Unlock()

        e.logger.Info("Job cancelled", "job_id", jobID)
        return nil</span>
}

// GetMetrics returns current processing metrics
func (e *ProcessingEngine) GetMetrics() *ProcessingMetrics <span class="cov0" title="0">{
        e.metrics.mu.RLock()
        defer e.metrics.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := &amp;ProcessingMetrics{
                TotalJobsProcessed:    e.metrics.TotalJobsProcessed,
                TotalRecordsProcessed: e.metrics.TotalRecordsProcessed,
                TotalErrors:           e.metrics.TotalErrors,
                ActiveWorkers:         e.metrics.ActiveWorkers,
                QueuedJobs:            e.metrics.QueuedJobs,
                ProcessingRate:        e.metrics.ProcessingRate,
                AverageProcessingTime: e.metrics.AverageProcessingTime,
                LastProcessingTime:    e.metrics.LastProcessingTime,
        }

        return metrics
}</span>

// startWorkerPool initializes and starts the worker pool
func (e *ProcessingEngine) startWorkerPool() <span class="cov0" title="0">{
        for i := 0; i &lt; e.maxWorkers; i++ </span><span class="cov0" title="0">{
                worker := &amp;worker{
                        id:           i,
                        engine:       e,
                        lastActivity: time.Now(),
                }

                e.workerPool &lt;- worker

                e.wg.Add(1)
                go e.workerLoop(worker)
        }</span>

        <span class="cov0" title="0">e.logger.Info("Worker pool started", "workers", e.maxWorkers)</span>
}

// workerLoop is the main loop for a worker
func (e *ProcessingEngine) workerLoop(w *worker) <span class="cov0" title="0">{
        defer e.wg.Done()

        e.logger.Debug("Worker started", "worker_id", w.id)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        e.logger.Debug("Worker stopping", "worker_id", w.id)
                        return</span>
                default:<span class="cov0" title="0">
                        // Worker is available, put it back in pool
                        select </span>{
                        case e.workerPool &lt;- w:<span class="cov0" title="0">
                                w.mu.Lock()
                                w.busy = false
                                w.lastActivity = time.Now()
                                w.mu.Unlock()</span>
                        case &lt;-e.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

// jobDispatcher dispatches jobs to available workers
func (e *ProcessingEngine) jobDispatcher() <span class="cov0" title="0">{
        defer e.wg.Done()

        e.logger.Info("Job dispatcher started")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        e.logger.Info("Job dispatcher stopping")
                        return</span>
                case job := &lt;-e.fileQueue:<span class="cov0" title="0">
                        e.dispatchJob(job)</span>
                }
        }
}

// dispatchJob dispatches a single job to an available worker
func (e *ProcessingEngine) dispatchJob(job *ProcessingJob) <span class="cov0" title="0">{
        select </span>{
        case &lt;-e.ctx.Done():<span class="cov0" title="0">
                e.updateJobStatus(job, StatusCancelled, "System shutdown")
                return</span>
        case worker := &lt;-e.workerPool:<span class="cov0" title="0">
                worker.mu.Lock()
                worker.busy = true
                worker.currentJob = job
                worker.mu.Unlock()
                job.Worker = worker

                e.wg.Add(1)
                go e.processJobWithWorker(worker, job)

                e.logger.Info("Job dispatched to worker",
                        "job_id", job.ID,
                        "worker_id", worker.id,
                        "file_url", job.FileURL,
                )</span>
        }
}

// processJobWithWorker processes a job with a specific worker
func (e *ProcessingEngine) processJobWithWorker(w *worker, job *ProcessingJob) <span class="cov0" title="0">{
        defer e.wg.Done()

        e.updateJobStatus(job, StatusRunning, "")

        // Process the job
        err := e.processFile(job)

        // Handle job completion
        if err != nil </span><span class="cov0" title="0">{
                job.mu.Lock()
                retryCount := job.RetryCount
                maxRetries := job.MaxRetries
                if retryCount &lt; maxRetries </span><span class="cov0" title="0">{
                        job.RetryCount++
                        retryCount = job.RetryCount
                        job.mu.Unlock()

                        e.updateJobStatus(job, StatusRetrying, fmt.Sprintf("Retry %d/%d: %v", retryCount, maxRetries, err))

                        // Retry with exponential backoff
                        retryDelay := time.Duration(retryCount) * time.Second
                        time.Sleep(retryDelay)

                        // Requeue the job
                        select </span>{
                        case e.fileQueue &lt;- job:<span class="cov0" title="0">
                                e.logger.Info("Job requeued for retry",
                                        "job_id", job.ID,
                                        "retry_count", retryCount,
                                )</span>
                        default:<span class="cov0" title="0">
                                e.updateJobStatus(job, StatusFailed, "Failed to requeue for retry")</span>
                        }
                } else<span class="cov0" title="0"> {
                        job.mu.Unlock()
                        e.updateJobStatus(job, StatusFailed, err.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                e.updateJobStatus(job, StatusCompleted, "")
        }</span>

        // Clean up worker
        <span class="cov0" title="0">w.mu.Lock()
        w.currentJob = nil
        w.lastActivity = time.Now()
        w.mu.Unlock()</span>
}

// processFile processes a single file
func (e *ProcessingEngine) processFile(job *ProcessingJob) error <span class="cov0" title="0">{
        ctx := job.Context

        e.logger.InfoContext(ctx, "Starting file processing",
                "job_id", job.ID,
                "file_url", job.FileURL,
                "provider_id", job.ProviderID,
        )

        // Download file from S3
        bucket, key, err := e.parseS3URL(job.FileURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid S3 URL: %w", err)
        }</span>

        // Check if file exists
        <span class="cov0" title="0">exists, err := e.s3Client.FileExists(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check file existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("file does not exist: %s", job.FileURL)
        }</span>

        // Get file size for progress tracking
        <span class="cov0" title="0">fileSize, err := e.s3Client.GetFileSize(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.WarnContext(ctx, "Failed to get file size", "error", err)
        }</span>

        // Download file
        <span class="cov0" title="0">reader, err := e.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := reader.Close(); err != nil </span><span class="cov0" title="0">{
                        e.logger.Warn("Failed to close reader", "error", err)
                }</span>
        }()

        // Count records for progress tracking
        <span class="cov0" title="0">recordCount, err := e.jsonProcessor.CountRecords(ctx, reader)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.WarnContext(ctx, "Failed to count records", "error", err)
        }</span> else<span class="cov0" title="0"> {
                job.RecordsTotal = int64(recordCount)
        }</span>

        // Re-download for processing (since we consumed the reader)
        <span class="cov0" title="0">reader, err = e.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to re-download file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := reader.Close(); err != nil </span><span class="cov0" title="0">{
                        e.logger.Warn("Failed to close reader", "error", err)
                }</span>
        }()

        // Process the file
        <span class="cov0" title="0">err = e.jsonProcessor.ProcessFile(ctx, reader, job.ProviderID, job.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process file: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.InfoContext(ctx, "File processing completed successfully",
                "job_id", job.ID,
                "file_url", job.FileURL,
                "file_size", fileSize,
                "records_total", job.RecordsTotal,
        )

        return nil</span>
}

// updateJobStatus updates the status of a job
func (e *ProcessingEngine) updateJobStatus(job *ProcessingJob, status ProcessingStatus, errorMessage string) <span class="cov0" title="0">{
        job.mu.Lock()
        job.Status = status
        job.ErrorMessage = errorMessage
        job.mu.Unlock()

        if status == StatusCompleted || status == StatusFailed || status == StatusCancelled </span><span class="cov0" title="0">{
                job.EndTime = time.Now()

                // Update metrics
                e.metrics.mu.Lock()
                e.metrics.TotalJobsProcessed++
                e.metrics.TotalRecordsProcessed += job.RecordsProcessed
                if status == StatusFailed </span><span class="cov0" title="0">{
                        e.metrics.TotalErrors++
                }</span>
                <span class="cov0" title="0">e.metrics.LastProcessingTime = time.Now()
                e.metrics.mu.Unlock()

                // Remove from active jobs after a delay to allow status queries
                go func() </span><span class="cov0" title="0">{
                        time.Sleep(5 * time.Minute)
                        e.removeJob(job.ID)
                }</span>()
        }

        // Note: Processing status updates are handled by the ReviewService layer

        <span class="cov0" title="0">e.logger.InfoContext(job.Context, "Job status updated",
                "job_id", job.ID,
                "status", status,
                "error_message", errorMessage,
        )</span>
}

// checkIdempotency checks if a similar job is already running
func (e *ProcessingEngine) checkIdempotency(providerID uuid.UUID, fileURL string) (*ProcessingJob, bool) <span class="cov0" title="0">{
        e.jobsMutex.RLock()
        defer e.jobsMutex.RUnlock()

        for _, job := range e.activeJobs </span><span class="cov0" title="0">{
                if job.ProviderID == providerID &amp;&amp; job.FileURL == fileURL </span><span class="cov0" title="0">{
                        job.mu.RLock()
                        status := job.Status
                        job.mu.RUnlock()
                        if status == StatusPending || status == StatusRunning || status == StatusRetrying </span><span class="cov0" title="0">{
                                return job, true
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, false</span>
}

// removeJob removes a job from active jobs
func (e *ProcessingEngine) removeJob(jobID uuid.UUID) <span class="cov0" title="0">{
        e.jobsMutex.Lock()
        defer e.jobsMutex.Unlock()

        delete(e.activeJobs, jobID)
}</span>

// metricsCollector collects and updates processing metrics
func (e *ProcessingEngine) metricsCollector() <span class="cov0" title="0">{
        defer e.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        e.updateMetrics()</span>
                }
        }
}

// updateMetrics updates processing metrics
func (e *ProcessingEngine) updateMetrics() <span class="cov0" title="0">{
        e.metrics.mu.Lock()
        defer e.metrics.mu.Unlock()

        e.jobsMutex.RLock()
        activeJobs := len(e.activeJobs)
        e.jobsMutex.RUnlock()

        e.metrics.QueuedJobs = len(e.fileQueue)
        e.metrics.ActiveWorkers = e.maxWorkers - len(e.workerPool)

        // Calculate processing rate (jobs per minute)
        if e.metrics.TotalJobsProcessed &gt; 0 </span><span class="cov0" title="0">{
                duration := time.Since(e.metrics.LastProcessingTime)
                if duration &gt; 0 </span><span class="cov0" title="0">{
                        e.metrics.ProcessingRate = float64(e.metrics.TotalJobsProcessed) / duration.Minutes()
                }</span>
        }

        <span class="cov0" title="0">e.logger.Debug("Metrics updated",
                "total_jobs_processed", e.metrics.TotalJobsProcessed,
                "total_records_processed", e.metrics.TotalRecordsProcessed,
                "total_errors", e.metrics.TotalErrors,
                "active_workers", e.metrics.ActiveWorkers,
                "queued_jobs", e.metrics.QueuedJobs,
                "processing_rate", e.metrics.ProcessingRate,
                "active_jobs", activeJobs,
        )</span>
}

// parseS3URL parses an S3 URL into bucket and key components
func (e *ProcessingEngine) parseS3URL(url string) (bucket, key string, err error) <span class="cov0" title="0">{
        var path string

        // Handle different S3 URL formats
        if strings.HasPrefix(url, "s3://") </span><span class="cov0" title="0">{
                // s3://bucket/key format
                path = strings.TrimPrefix(url, "s3://")
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                // Handle HTTPS S3 URLs
                if strings.Contains(url, ".s3.amazonaws.com/") </span><span class="cov0" title="0">{
                        // https://bucket.s3.amazonaws.com/key format
                        url = strings.TrimPrefix(url, "https://")
                        parts := strings.SplitN(url, ".s3.amazonaws.com/", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                        }</span>
                        <span class="cov0" title="0">return parts[0], parts[1], nil</span>
                } else<span class="cov0" title="0"> if strings.Contains(url, "s3.amazonaws.com/") </span><span class="cov0" title="0">{
                        // https://s3.amazonaws.com/bucket/key format
                        url = strings.TrimPrefix(url, "https://s3.amazonaws.com/")
                        parts := strings.SplitN(url, "/", 2)
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                        }</span>
                        <span class="cov0" title="0">return parts[0], parts[1], nil</span>
                } else<span class="cov0" title="0"> {
                        return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
                }</span>
        } else<span class="cov0" title="0"> {
                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
        }</span>

        // For s3:// format
        <span class="cov0" title="0">parts := strings.SplitN(path, "/", 2)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid S3 URL format: %s", url)
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], nil</span>
}

// BackpressureController manages backpressure for the processing engine
type BackpressureController struct {
        engine             *ProcessingEngine
        maxQueueSize       int
        maxMemoryUsage     int64
        currentMemoryUsage int64
        mu                 sync.RWMutex
}

// NewBackpressureController creates a new backpressure controller
func NewBackpressureController(engine *ProcessingEngine, maxQueueSize int, maxMemoryUsage int64) *BackpressureController <span class="cov0" title="0">{
        return &amp;BackpressureController{
                engine:         engine,
                maxQueueSize:   maxQueueSize,
                maxMemoryUsage: maxMemoryUsage,
        }
}</span>

// ShouldAcceptJob determines if a new job should be accepted based on backpressure
func (bc *BackpressureController) ShouldAcceptJob() bool <span class="cov0" title="0">{
        bc.mu.RLock()
        defer bc.mu.RUnlock()

        // Check queue size
        if len(bc.engine.fileQueue) &gt;= bc.maxQueueSize </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check memory usage
        <span class="cov0" title="0">if bc.currentMemoryUsage &gt;= bc.maxMemoryUsage </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// UpdateMemoryUsage updates the current memory usage
func (bc *BackpressureController) UpdateMemoryUsage(usage int64) <span class="cov0" title="0">{
        bc.mu.Lock()
        defer bc.mu.Unlock()

        bc.currentMemoryUsage = usage
}</span>

// JobProgressTracker tracks the progress of individual jobs
type JobProgressTracker struct {
        job        *ProcessingJob
        logger     *logger.Logger
        lastUpdate time.Time
        mu         sync.RWMutex
}

// NewJobProgressTracker creates a new job progress tracker
func NewJobProgressTracker(job *ProcessingJob, logger *logger.Logger) *JobProgressTracker <span class="cov0" title="0">{
        return &amp;JobProgressTracker{
                job:        job,
                logger:     logger,
                lastUpdate: time.Now(),
        }
}</span>

// UpdateProgress updates the progress of a job
func (jpt *JobProgressTracker) UpdateProgress(recordsProcessed int64) <span class="cov0" title="0">{
        jpt.mu.Lock()
        defer jpt.mu.Unlock()

        jpt.job.RecordsProcessed = recordsProcessed

        // Log progress every 10 seconds
        if time.Since(jpt.lastUpdate) &gt; 10*time.Second </span><span class="cov0" title="0">{
                progress := float64(recordsProcessed) / float64(jpt.job.RecordsTotal) * 100
                jpt.logger.InfoContext(jpt.job.Context, "Job progress update",
                        "job_id", jpt.job.ID,
                        "records_processed", recordsProcessed,
                        "records_total", jpt.job.RecordsTotal,
                        "progress_percent", fmt.Sprintf("%.2f%%", progress),
                )
                jpt.lastUpdate = time.Now()
        }</span>
}

// GetProgress returns the current progress of a job
func (jpt *JobProgressTracker) GetProgress() (int64, int64, float64) <span class="cov0" title="0">{
        jpt.mu.RLock()
        defer jpt.mu.RUnlock()

        processed := jpt.job.RecordsProcessed
        total := jpt.job.RecordsTotal

        var progress float64
        if total &gt; 0 </span><span class="cov0" title="0">{
                progress = float64(processed) / float64(total) * 100
        }</span>

        <span class="cov0" title="0">return processed, total, progress</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package application

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/google/uuid"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

type ProviderHandlers struct {
        providerService domain.ProviderService
        logger          *logger.Logger
}

func NewProviderHandlers(providerService domain.ProviderService, logger *logger.Logger) *ProviderHandlers <span class="cov10" title="7">{
        return &amp;ProviderHandlers{
                providerService: providerService,
                logger:          logger,
        }
}</span>

// GetProviders handles GET /api/v1/providers
func (p *ProviderHandlers) GetProviders(c *gin.Context) <span class="cov1" title="1">{
        // Parse query parameters
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        isActive := c.Query("is_active")
        name := c.Query("name")

        // Validate pagination parameters
        if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov1" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Create filter
        <span class="cov1" title="1">filter := domain.ProviderFilter{
                Name:   name,
                Limit:  limit,
                Offset: offset,
        }

        // Parse is_active parameter
        if isActive != "" </span><span class="cov1" title="1">{
                if isActive == "true" </span><span class="cov1" title="1">{
                        filter.IsActive = &amp;[]bool{true}[0]
                }</span> else<span class="cov0" title="0"> if isActive == "false" </span><span class="cov0" title="0">{
                        filter.IsActive = &amp;[]bool{false}[0]
                }</span>
        }

        // Get providers from service
        <span class="cov1" title="1">providers, err := p.providerService.GetProviders(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.ErrorContext(c.Request.Context(), "Failed to get providers", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to retrieve providers",
                })
                return
        }</span>

        // Return response
        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "providers": providers,
                "pagination": gin.H{
                        "limit":  limit,
                        "offset": offset,
                        "total":  len(providers), // In a real implementation, this would be a separate count query
                },
        })</span>
}

// GetProvider handles GET /api/v1/providers/:id
func (p *ProviderHandlers) GetProvider(c *gin.Context) <span class="cov4" title="2">{
        // Parse provider ID
        providerIDStr := c.Param("id")
        providerID, err := uuid.Parse(providerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid provider ID format",
                })
                return
        }</span>

        // Get provider from service
        <span class="cov4" title="2">provider, err := p.providerService.GetProvider(c.Request.Context(), providerID)
        if err != nil </span><span class="cov1" title="1">{
                if err == domain.ErrProviderNotFound </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "PROVIDER_NOT_FOUND",
                                "message": "Provider not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">p.logger.ErrorContext(c.Request.Context(), "Failed to get provider", "error", err, "provider_id", providerID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to retrieve provider",
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, provider)</span>
}

// CreateProvider handles POST /api/v1/providers
func (p *ProviderHandlers) CreateProvider(c *gin.Context) <span class="cov6" title="3">{
        var provider domain.Provider
        if err := c.ShouldBindJSON(&amp;provider); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_INPUT",
                        "message": "Invalid provider data",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov6" title="3">if err := p.validateProviderInput(&amp;provider); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "VALIDATION_FAILED",
                        "message": err.Error(),
                })
                return
        }</span>

        // Generate ID if not provided
        <span class="cov4" title="2">if provider.ID == uuid.Nil </span><span class="cov4" title="2">{
                provider.ID = uuid.New()
        }</span>

        // Set default values
        <span class="cov4" title="2">if provider.IsActive == false </span><span class="cov0" title="0">{
                provider.IsActive = true // Default to active
        }</span>

        // Create provider
        <span class="cov4" title="2">if err := p.providerService.CreateProvider(c.Request.Context(), &amp;provider); err != nil </span><span class="cov1" title="1">{
                if err == domain.ErrProviderAlreadyExists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusConflict, gin.H{
                                "error":   "PROVIDER_ALREADY_EXISTS",
                                "message": "Provider already exists",
                        })
                        return
                }</span>

                // Check if it's a validation error from the service
                <span class="cov0" title="0">if strings.Contains(err.Error(), "validation failed") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "VALIDATION_FAILED",
                                "message": err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">p.logger.ErrorContext(c.Request.Context(), "Failed to create provider", "error", err, "provider", provider)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to create provider",
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{
                "message":  "Provider created successfully",
                "provider": provider,
        })</span>
}

// UpdateProvider handles PUT /api/v1/providers/:id
func (p *ProviderHandlers) UpdateProvider(c *gin.Context) <span class="cov0" title="0">{
        // Parse provider ID
        providerIDStr := c.Param("id")
        providerID, err := uuid.Parse(providerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid provider ID format",
                })
                return
        }</span>

        <span class="cov0" title="0">var provider domain.Provider
        if err := c.ShouldBindJSON(&amp;provider); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_INPUT",
                        "message": "Invalid provider data",
                        "details": err.Error(),
                })
                return
        }</span>

        // Set the ID from URL
        <span class="cov0" title="0">provider.ID = providerID

        // Validate input
        if err := p.validateProviderInput(&amp;provider); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "VALIDATION_ERROR",
                        "message": err.Error(),
                })
                return
        }</span>

        // Update provider
        <span class="cov0" title="0">if err := p.providerService.UpdateProvider(c.Request.Context(), &amp;provider); err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrProviderNotFound </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "PROVIDER_NOT_FOUND",
                                "message": "Provider not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">p.logger.ErrorContext(c.Request.Context(), "Failed to update provider", "error", err, "provider_id", providerID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to update provider",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, provider)</span>
}

// DeleteProvider handles DELETE /api/v1/providers/:id
func (p *ProviderHandlers) DeleteProvider(c *gin.Context) <span class="cov0" title="0">{
        // Parse provider ID
        providerIDStr := c.Param("id")
        providerID, err := uuid.Parse(providerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid provider ID format",
                })
                return
        }</span>

        // Delete provider
        <span class="cov0" title="0">if err := p.providerService.DeleteProvider(c.Request.Context(), providerID); err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrProviderNotFound </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "PROVIDER_NOT_FOUND",
                                "message": "Provider not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">p.logger.ErrorContext(c.Request.Context(), "Failed to delete provider", "error", err, "provider_id", providerID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to delete provider",
                })
                return</span>
        }

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// ToggleProviderStatus handles PATCH /api/v1/providers/:id/toggle
func (p *ProviderHandlers) ToggleProviderStatus(c *gin.Context) <span class="cov1" title="1">{
        // Parse provider ID
        providerIDStr := c.Param("id")
        providerID, err := uuid.Parse(providerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "INVALID_ID",
                        "message": "Invalid provider ID format",
                })
                return
        }</span>

        // Get current provider
        <span class="cov1" title="1">provider, err := p.providerService.GetProvider(c.Request.Context(), providerID)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrProviderNotFound </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "error":   "PROVIDER_NOT_FOUND",
                                "message": "Provider not found",
                        })
                        return
                }</span>

                <span class="cov0" title="0">p.logger.ErrorContext(c.Request.Context(), "Failed to get provider for toggle", "error", err, "provider_id", providerID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to retrieve provider",
                })
                return</span>
        }

        // Toggle status
        <span class="cov1" title="1">provider.IsActive = !provider.IsActive

        // Update provider
        if err := p.providerService.UpdateProvider(c.Request.Context(), provider); err != nil </span><span class="cov0" title="0">{
                p.logger.ErrorContext(c.Request.Context(), "Failed to toggle provider status", "error", err, "provider_id", providerID)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "INTERNAL_ERROR",
                        "message": "Failed to update provider status",
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, provider)</span>
}

// validateProviderInput validates provider input data
func (p *ProviderHandlers) validateProviderInput(provider *domain.Provider) error <span class="cov6" title="3">{
        if provider.Name == "" </span><span class="cov1" title="1">{
                return domain.NewValidationError("name", "Provider name is required")
        }</span>
        <span class="cov4" title="2">if len(provider.Name) &lt; 2 </span><span class="cov0" title="0">{
                return domain.NewValidationError("name", "Provider name must be at least 2 characters")
        }</span>
        <span class="cov4" title="2">if len(provider.Name) &gt; 100 </span><span class="cov0" title="0">{
                return domain.NewValidationError("name", "Provider name must be less than 100 characters")
        }</span>

        <span class="cov4" title="2">if provider.BaseURL != "" </span><span class="cov1" title="1">{
                if len(provider.BaseURL) &gt; 255 </span><span class="cov0" title="0">{
                        return domain.NewValidationError("base_url", "Base URL must be less than 255 characters")
                }</span>
                <span class="cov1" title="1">if !isValidURL(provider.BaseURL) </span><span class="cov0" title="0">{
                        return domain.NewValidationError("base_url", "Invalid URL format")
                }</span>
        }

        <span class="cov4" title="2">return nil</span>
}

// Helper function to validate URL format
func isValidURL(url string) bool <span class="cov1" title="1">{
        // Basic URL validation - in production, use a proper URL validation library
        return len(url) &gt; 0 &amp;&amp; 
                   (containsHTTP(url) || containsHTTPS(url))
}</span>

func containsHTTP(s string) bool <span class="cov1" title="1">{
        return len(s) &gt;= 7 &amp;&amp; s[:7] == "http://"
}</span>

func containsHTTPS(s string) bool <span class="cov1" title="1">{
        return len(s) &gt;= 8 &amp;&amp; s[:8] == "https://"
}</pre>
		
		<pre class="file" id="file10" style="display: none">package application

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// SimplifiedIntegratedHandlers provides integrated handlers using existing interfaces
type SimplifiedIntegratedHandlers struct {
        // Core services
        reviewService domain.ReviewService
        logger        *logger.Logger

        // Authentication &amp; Authorization
        authService *infrastructure.AuthenticationService
        rbacService *infrastructure.RBACService

        // Resilience components
        circuitBreaker *infrastructure.CircuitBreakerIntegration
        retryManager   *infrastructure.RetryManager

        // Infrastructure components
        redisClient   *infrastructure.RedisClient
        kafkaProducer *infrastructure.KafkaProducer
        s3Client      domain.S3Client

        // Monitoring components
        errorHandler *infrastructure.ErrorHandler
        tracer       trace.Tracer

        // Processing engine
        processingEngine *ProcessingEngine
}

// NewSimplifiedIntegratedHandlers creates a new simplified integrated handlers instance
func NewSimplifiedIntegratedHandlers(
        reviewService domain.ReviewService,
        authService *infrastructure.AuthenticationService,
        rbacService *infrastructure.RBACService,
        circuitBreaker *infrastructure.CircuitBreakerIntegration,
        retryManager *infrastructure.RetryManager,
        redisClient *infrastructure.RedisClient,
        kafkaProducer *infrastructure.KafkaProducer,
        s3Client domain.S3Client,
        errorHandler *infrastructure.ErrorHandler,
        processingEngine *ProcessingEngine,
        logger *logger.Logger,
) *SimplifiedIntegratedHandlers <span class="cov0" title="0">{
        tracer := otel.Tracer("hotel-reviews-handlers")

        return &amp;SimplifiedIntegratedHandlers{
                reviewService:    reviewService,
                authService:      authService,
                rbacService:      rbacService,
                circuitBreaker:   circuitBreaker,
                retryManager:     retryManager,
                redisClient:      redisClient,
                kafkaProducer:    kafkaProducer,
                s3Client:         s3Client,
                errorHandler:     errorHandler,
                tracer:           tracer,
                processingEngine: processingEngine,
                logger:           logger,
        }
}</span>

// Request and Response types

// CreateReviewRequest represents the request to create a new review
type CreateReviewRequest struct {
        HotelID        string    `json:"hotel_id" binding:"required"`
        ReviewerInfoID string    `json:"reviewer_info_id" binding:"required"`
        ExternalID     *string   `json:"external_id,omitempty"`
        Rating         float64   `json:"rating" binding:"required,min=1,max=5"`
        Title          string    `json:"title" binding:"required"`
        Comment        string    `json:"comment" binding:"required"`
        ReviewDate     time.Time `json:"review_date"`
        Language       string    `json:"language" binding:"required"`
}

// UpdateReviewRequest represents the request to update a review
type UpdateReviewRequest struct {
        Rating   *float64 `json:"rating,omitempty" binding:"omitempty,min=1,max=5"`
        Title    *string  `json:"title,omitempty"`
        Comment  *string  `json:"comment,omitempty"`
        Language *string  `json:"language,omitempty"`
}

// StandardAPIResponse represents the standard API response format
type StandardAPIResponse struct {
        Success   bool        `json:"success"`
        Data      interface{} `json:"data,omitempty"`
        Error     string      `json:"error,omitempty"`
        ErrorCode string      `json:"error_code,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
        TraceID   string      `json:"trace_id,omitempty"`
}

// CreateReview creates a new review with resilience and monitoring
func (h *SimplifiedIntegratedHandlers) CreateReview(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(c.Request.Context(), "CreateReview")
        defer span.End()

        // Extract user from context (set by auth middleware)
        user, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusUnauthorized, "UNAUTHORIZED", "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">userObj := user.(*domain.User)
        span.SetAttributes(attribute.String("user.id", userObj.ID.String()))

        // Check permissions with RBAC and resilience
        hasPermission, err := h.executeWithResilience(ctx, "rbac", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.rbacService.CheckPermission(ctx, userObj.ID, "reviews", "create")
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to check permissions")
                return
        }</span>
        <span class="cov0" title="0">if !hasPermission.(bool) </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusForbidden, "FORBIDDEN", "Insufficient permissions")
                return
        }</span>

        // Parse request
        <span class="cov0" title="0">var req CreateReviewRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")
                return
        }</span>

        // Create review with resilience
        <span class="cov0" title="0">review, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.createReviewInternal(ctx, &amp;req, userObj.ID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to create review")
                return
        }</span>

        <span class="cov0" title="0">reviewObj := review.(*domain.Review)

        // Publish event to Kafka (asynchronously)
        go h.publishReviewEvent(context.Background(), "review.created", reviewObj)

        span.SetAttributes(
                attribute.String("review.id", reviewObj.ID.String()),
                attribute.Float64("review.rating", reviewObj.Rating),
        )

        h.respondWithSuccess(c, http.StatusCreated, "Review created successfully", reviewObj)</span>
}

// GetReview retrieves a review by ID
func (h *SimplifiedIntegratedHandlers) GetReview(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(c.Request.Context(), "GetReview")
        defer span.End()

        reviewID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, "INVALID_ID", "Invalid review ID")
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String("review.id", reviewID.String()))

        // Get from database with resilience
        review, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.reviewService.GetReviewByID(ctx, reviewID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to get review")
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, http.StatusOK, "Review retrieved successfully", review)</span>
}

// ListReviews lists reviews with pagination
func (h *SimplifiedIntegratedHandlers) ListReviews(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(c.Request.Context(), "ListReviews")
        defer span.End()

        // Parse query parameters
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        hotelID := c.Query("hotel_id")

        // Limit maximum page size
        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int("query.limit", limit),
                attribute.Int("query.offset", offset),
                attribute.String("query.hotel_id", hotelID),
        )

        // Get from database with resilience
        reviews, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                if hotelID != "" </span><span class="cov0" title="0">{
                        hotelUUID, err := uuid.Parse(hotelID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return h.reviewService.GetReviewsByHotel(ctx, hotelUUID, limit, offset)</span>
                }
                // For general listing, use search with empty query
                <span class="cov0" title="0">return h.reviewService.SearchReviews(ctx, "", make(map[string]interface{}), limit, offset)</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to list reviews")
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, http.StatusOK, "Reviews retrieved successfully", reviews)</span>
}

// UpdateReview updates a review
func (h *SimplifiedIntegratedHandlers) UpdateReview(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(c.Request.Context(), "UpdateReview")
        defer span.End()

        user, _ := c.Get("user")
        userObj := user.(*domain.User)

        reviewID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, "INVALID_ID", "Invalid review ID")
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("review.id", reviewID.String()),
                attribute.String("user.id", userObj.ID.String()),
        )

        // Parse request
        var req UpdateReviewRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")
                return
        }</span>

        // Get existing review to check ownership
        <span class="cov0" title="0">existingReview, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.reviewService.GetReviewByID(ctx, reviewID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to get existing review")
                return
        }</span>

        <span class="cov0" title="0">existingReviewObj := existingReview.(*domain.Review)

        // Check ownership (unless user is admin)
        if existingReviewObj.ProviderID != userObj.ID </span><span class="cov0" title="0">{
                adminCheck, err := h.rbacService.CheckPermission(ctx, userObj.ID, "reviews", "admin")
                if err != nil || !adminCheck </span><span class="cov0" title="0">{
                        h.respondWithError(c, http.StatusForbidden, "FORBIDDEN", "Can only update own reviews")
                        return
                }</span>
        }

        // Update review with resilience
        <span class="cov0" title="0">updatedReview, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.updateReviewInternal(ctx, existingReviewObj, &amp;req)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to update review")
                return
        }</span>

        // Publish update event
        <span class="cov0" title="0">go h.publishReviewEvent(context.Background(), "review.updated", updatedReview.(*domain.Review))

        h.respondWithSuccess(c, http.StatusOK, "Review updated successfully", updatedReview)</span>
}

// DeleteReview deletes a review
func (h *SimplifiedIntegratedHandlers) DeleteReview(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(c.Request.Context(), "DeleteReview")
        defer span.End()

        user, _ := c.Get("user")
        userObj := user.(*domain.User)

        reviewID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, "INVALID_ID", "Invalid review ID")
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("review.id", reviewID.String()),
                attribute.String("user.id", userObj.ID.String()),
        )

        // Get existing review to check ownership
        existingReview, err := h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return h.reviewService.GetReviewByID(ctx, reviewID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to get existing review")
                return
        }</span>

        <span class="cov0" title="0">existingReviewObj := existingReview.(*domain.Review)

        // Check ownership (unless user is admin)
        if existingReviewObj.ProviderID != userObj.ID </span><span class="cov0" title="0">{
                adminCheck, err := h.rbacService.CheckPermission(ctx, userObj.ID, "reviews", "admin")
                if err != nil || !adminCheck </span><span class="cov0" title="0">{
                        h.respondWithError(c, http.StatusForbidden, "FORBIDDEN", "Can only delete own reviews")
                        return
                }</span>
        }

        // Delete review with resilience
        <span class="cov0" title="0">_, err = h.executeWithResilience(ctx, "database", func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return nil, h.reviewService.DeleteReview(ctx, reviewID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err, "Failed to delete review")
                return
        }</span>

        // Publish delete event
        <span class="cov0" title="0">go h.publishReviewEvent(context.Background(), "review.deleted", existingReviewObj)

        h.respondWithSuccess(c, http.StatusOK, "Review deleted successfully", nil)</span>
}

// HealthCheck provides comprehensive health check
func (h *SimplifiedIntegratedHandlers) HealthCheck(c *gin.Context) <span class="cov0" title="0">{
        _, span := h.tracer.Start(c.Request.Context(), "HealthCheck")
        defer span.End()

        health := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC(),
                "version":   "1.0.0",
                "services":  make(map[string]interface{}),
        }

        // Check circuit breakers
        if h.circuitBreaker != nil </span><span class="cov0" title="0">{
                health["services"].(map[string]interface{})["circuit_breakers"] = h.circuitBreaker.GetHealthStatus()
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, http.StatusOK, "Health check completed", health)</span>
}

// GetMetrics returns application metrics
func (h *SimplifiedIntegratedHandlers) GetMetrics(c *gin.Context) <span class="cov0" title="0">{
        _, span := h.tracer.Start(c.Request.Context(), "GetMetrics")
        defer span.End()

        metrics := map[string]interface{}{
                "timestamp": time.Now().UTC(),
        }

        if h.circuitBreaker != nil </span><span class="cov0" title="0">{
                metrics["circuit_breakers"] = h.circuitBreaker.GetHealthStatus()
        }</span>

        <span class="cov0" title="0">if h.retryManager != nil </span><span class="cov0" title="0">{
                metrics["retry"] = h.retryManager.GetMetrics()
        }</span>

        <span class="cov0" title="0">if h.processingEngine != nil </span><span class="cov0" title="0">{
                metrics["processing"] = h.processingEngine.GetMetrics()
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, http.StatusOK, "Metrics retrieved successfully", metrics)</span>
}

// Helper methods

// executeWithResilience executes a function with circuit breaker and retry protection
func (h *SimplifiedIntegratedHandlers) executeWithResilience(
        ctx context.Context,
        serviceName string,
        operation func(ctx context.Context) (interface{}, error),
) (interface{}, error) <span class="cov0" title="0">{
        ctx, span := h.tracer.Start(ctx, fmt.Sprintf("ExecuteWithResilience-%s", serviceName))
        defer span.End()

        span.SetAttributes(attribute.String("service.name", serviceName))

        // Try circuit breaker first
        if h.circuitBreaker != nil </span><span class="cov0" title="0">{
                breaker, exists := h.circuitBreaker.GetManager().GetCircuitBreaker(serviceName)
                if exists </span><span class="cov0" title="0">{
                        result, err := breaker.Execute(ctx, operation)
                        if err != nil </span><span class="cov0" title="0">{
                                span.RecordError(err)
                        }</span>
                        <span class="cov0" title="0">return result, err</span>
                }
        }

        // Direct execution as fallback
        <span class="cov0" title="0">return operation(ctx)</span>
}

// createReviewInternal creates a review internally
func (h *SimplifiedIntegratedHandlers) createReviewInternal(ctx context.Context, req *CreateReviewRequest, providerID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        hotelID, err := uuid.Parse(req.HotelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid hotel ID: %w", err)
        }</span>

        <span class="cov0" title="0">reviewerInfoID, err := uuid.Parse(req.ReviewerInfoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid reviewer info ID: %w", err)
        }</span>

        <span class="cov0" title="0">review := &amp;domain.Review{
                ID:             uuid.New(),
                ProviderID:     providerID,
                HotelID:        hotelID,
                ReviewerInfoID: &amp;reviewerInfoID,
                Rating:         req.Rating,
                Title:          req.Title,
                Comment:        req.Comment,
                ReviewDate:     req.ReviewDate,
                Language:       req.Language,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        // Set ExternalID if provided
        if req.ExternalID != nil </span><span class="cov0" title="0">{
                review.ExternalID = *req.ExternalID
        }</span>

        <span class="cov0" title="0">err = h.reviewService.CreateReview(ctx, review)
        return review, err</span>
}

// updateReviewInternal updates a review internally
func (h *SimplifiedIntegratedHandlers) updateReviewInternal(ctx context.Context, review *domain.Review, req *UpdateReviewRequest) (*domain.Review, error) <span class="cov0" title="0">{
        // Update fields
        if req.Rating != nil </span><span class="cov0" title="0">{
                review.Rating = *req.Rating
        }</span>
        <span class="cov0" title="0">if req.Title != nil </span><span class="cov0" title="0">{
                review.Title = *req.Title
        }</span>
        <span class="cov0" title="0">if req.Comment != nil </span><span class="cov0" title="0">{
                review.Comment = *req.Comment
        }</span>
        <span class="cov0" title="0">if req.Language != nil </span><span class="cov0" title="0">{
                review.Language = *req.Language
        }</span>

        <span class="cov0" title="0">review.UpdatedAt = time.Now()

        err := h.reviewService.UpdateReview(ctx, review)
        return review, err</span>
}

// publishReviewEvent publishes review events to Kafka
func (h *SimplifiedIntegratedHandlers) publishReviewEvent(ctx context.Context, eventType string, review *domain.Review) <span class="cov0" title="0">{
        if h.kafkaProducer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a ReviewEvent using the proper Kafka event structure
        <span class="cov0" title="0">reviewEvent := &amp;infrastructure.ReviewEvent{
                BaseEvent: infrastructure.BaseEvent{
                        ID:            uuid.New().String(),
                        Type:          infrastructure.EventType(eventType),
                        Timestamp:     time.Now().UTC(),
                        Source:        "hotel-reviews-service",
                        CorrelationID: review.ID.String(),
                },
                ReviewID:   review.ID,
                HotelID:    review.HotelID,
                ProviderID: review.ProviderID,
                Rating:     review.Rating,
                Language:   review.Language,
        }

        err := h.kafkaProducer.PublishReviewEvent(ctx, reviewEvent)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to publish review event", "error", err, "event_type", eventType, "review_id", review.ID)
        }</span>
}

// Response helpers

// respondWithSuccess sends a successful API response
func (h *SimplifiedIntegratedHandlers) respondWithSuccess(c *gin.Context, statusCode int, message string, data interface{}) <span class="cov0" title="0">{
        traceID := ""
        if span := trace.SpanFromContext(c.Request.Context()); span != nil </span><span class="cov0" title="0">{
                traceID = span.SpanContext().TraceID().String()
        }</span>

        <span class="cov0" title="0">response := StandardAPIResponse{
                Success:   true,
                Data:      data,
                Timestamp: time.Now().UTC(),
                TraceID:   traceID,
        }

        c.JSON(statusCode, response)</span>
}

// respondWithError sends an error API response
func (h *SimplifiedIntegratedHandlers) respondWithError(c *gin.Context, statusCode int, errorCode, message string) <span class="cov0" title="0">{
        traceID := ""
        if span := trace.SpanFromContext(c.Request.Context()); span != nil </span><span class="cov0" title="0">{
                traceID = span.SpanContext().TraceID().String()
        }</span>

        <span class="cov0" title="0">response := StandardAPIResponse{
                Success:   false,
                Error:     message,
                ErrorCode: errorCode,
                Timestamp: time.Now().UTC(),
                TraceID:   traceID,
        }

        c.JSON(statusCode, response)

        // Log the error
        h.logger.Error("API Error",
                "status_code", statusCode,
                "error_code", errorCode,
                "message", message,
                "trace_id", traceID,
        )</span>
}

// handleError handles errors with proper logging and response
func (h *SimplifiedIntegratedHandlers) handleError(c *gin.Context, err error, message string) <span class="cov0" title="0">{
        var statusCode int
        var errorCode string

        // Use error handler if available
        if h.errorHandler != nil </span><span class="cov0" title="0">{
                appError := h.errorHandler.Handle(c.Request.Context(), err)
                if appError != nil </span><span class="cov0" title="0">{
                        switch appError.Type </span>{
                        case "NotFound":<span class="cov0" title="0">
                                statusCode = http.StatusNotFound
                                errorCode = "NOT_FOUND"</span>
                        case "Validation":<span class="cov0" title="0">
                                statusCode = http.StatusBadRequest
                                errorCode = "VALIDATION_ERROR"</span>
                        case "Authorization":<span class="cov0" title="0">
                                statusCode = http.StatusForbidden
                                errorCode = "FORBIDDEN"</span>
                        case "Authentication":<span class="cov0" title="0">
                                statusCode = http.StatusUnauthorized
                                errorCode = "UNAUTHORIZED"</span>
                        case "RateLimit":<span class="cov0" title="0">
                                statusCode = http.StatusTooManyRequests
                                errorCode = "RATE_LIMITED"</span>
                        case "CircuitBreaker":<span class="cov0" title="0">
                                statusCode = http.StatusServiceUnavailable
                                errorCode = "SERVICE_UNAVAILABLE"</span>
                        default:<span class="cov0" title="0">
                                statusCode = http.StatusInternalServerError
                                errorCode = "INTERNAL_ERROR"</span>
                        }
                } else<span class="cov0" title="0"> {
                        statusCode = http.StatusInternalServerError
                        errorCode = "INTERNAL_ERROR"
                }</span>
        } else<span class="cov0" title="0"> {
                // Fallback error handling
                statusCode = http.StatusInternalServerError
                errorCode = "INTERNAL_ERROR"
        }</span>

        <span class="cov0" title="0">h.respondWithError(c, statusCode, errorCode, message)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/application"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// AppConfig represents the complete application configuration
type AppConfig struct {
        // Server configuration
        Server ServerConfig `json:"server" yaml:"server" validate:"required"`

        // Database configuration
        Database infrastructure.DatabaseConfig `json:"database" yaml:"database" validate:"required"`

        // Redis configuration
        Redis infrastructure.RedisConfig `json:"redis" yaml:"redis" validate:"required"`

        // Cache configuration
        Cache infrastructure.CacheConfig `json:"cache" yaml:"cache" validate:"required"`

        // Authentication middleware configuration
        Auth application.AuthMiddlewareConfig `json:"auth" yaml:"auth" validate:"required"`

        // Event handler configuration
        EventHandler application.EventHandlerConfig `json:"event_handler" yaml:"event_handler" validate:"required"`

        // Cache service configuration
        CacheService application.CacheServiceConfig `json:"cache_service" yaml:"cache_service" validate:"required"`

        // Processing configuration
        Processing application.ProcessingConfig `json:"processing" yaml:"processing" validate:"required"`

        // Error handler configuration
        ErrorHandler infrastructure.ErrorHandlerConfig `json:"error_handler" yaml:"error_handler" validate:"required"`

        // Monitoring configuration
        Monitoring monitoring.Config `json:"monitoring" yaml:"monitoring" validate:"required"`

        // Circuit breaker configuration
        CircuitBreaker infrastructure.CircuitBreakerConfig `json:"circuit_breaker" yaml:"circuit_breaker" validate:"required"`

        // Application-specific settings
        App AppSettings `json:"app" yaml:"app" validate:"required"`
}

// ServerConfig represents HTTP server configuration
type ServerConfig struct {
        Host         string        `json:"host" yaml:"host" validate:"required"`
        Port         int           `json:"port" yaml:"port" validate:"min=1,max=65535"`
        ReadTimeout  time.Duration `json:"read_timeout" yaml:"read_timeout" validate:"min=1s"`
        WriteTimeout time.Duration `json:"write_timeout" yaml:"write_timeout" validate:"min=1s"`
        IdleTimeout  time.Duration `json:"idle_timeout" yaml:"idle_timeout" validate:"min=1s"`
        EnableTLS    bool          `json:"enable_tls" yaml:"enable_tls"`
        TLSCertFile  string        `json:"tls_cert_file" yaml:"tls_cert_file"`
        TLSKeyFile   string        `json:"tls_key_file" yaml:"tls_key_file"`
        EnablePprof  bool          `json:"enable_pprof" yaml:"enable_pprof"`
        PprofPort    int           `json:"pprof_port" yaml:"pprof_port" validate:"min=1,max=65535"`
}

// AppSettings represents application-specific settings
type AppSettings struct {
        Name                 string        `json:"name" yaml:"name" validate:"required"`
        Version              string        `json:"version" yaml:"version" validate:"required"`
        Environment          string        `json:"environment" yaml:"environment" validate:"required,oneof=development staging production"`
        LogLevel             string        `json:"log_level" yaml:"log_level" validate:"required,oneof=debug info warn error"`
        EnableMetrics        bool          `json:"enable_metrics" yaml:"enable_metrics"`
        EnableTracing        bool          `json:"enable_tracing" yaml:"enable_tracing"`
        EnableHealthChecks   bool          `json:"enable_health_checks" yaml:"enable_health_checks"`
        ShutdownTimeout      time.Duration `json:"shutdown_timeout" yaml:"shutdown_timeout" validate:"min=1s"`
        MaxRequestSize       int64         `json:"max_request_size" yaml:"max_request_size" validate:"min=1"`
        EnableRateLimit      bool          `json:"enable_rate_limit" yaml:"enable_rate_limit"`
        EnableAuthentication bool          `json:"enable_authentication" yaml:"enable_authentication"`
}

// GetDefaultConfig returns the default application configuration
func GetDefaultConfig() *AppConfig <span class="cov6" title="10">{
        return &amp;AppConfig{
                Server: ServerConfig{
                        Host:         "localhost",
                        Port:         8080,
                        ReadTimeout:  30 * time.Second,
                        WriteTimeout: 30 * time.Second,
                        IdleTimeout:  60 * time.Second,
                        EnableTLS:    false,
                        TLSCertFile:  "",
                        TLSKeyFile:   "",
                        EnablePprof:  false,
                        PprofPort:    6060,
                },
                Database: infrastructure.DatabaseConfig{
                        Host:         "localhost",
                        Port:         5432,
                        Database:     "hotel_reviews",
                        Username:     "postgres",
                        Password:     "",
                        SSLMode:      "disable",
                        MaxConns:     25,
                        MinConns:     5,
                        ConnTTL:      time.Hour,
                        QueryTimeout: 30 * time.Second,
                },
                Redis: infrastructure.RedisConfig{
                        Host:               "localhost",
                        Port:               6379,
                        Password:           "",
                        Database:           0,
                        MaxRetries:         3,
                        MinRetryBackoff:    8 * time.Millisecond,
                        MaxRetryBackoff:    512 * time.Millisecond,
                        DialTimeout:        5 * time.Second,
                        ReadTimeout:        3 * time.Second,
                        WriteTimeout:       3 * time.Second,
                        PoolSize:           10,
                        MinIdleConns:       5,
                        MaxConnAge:         time.Hour,
                        PoolTimeout:        4 * time.Second,
                        IdleTimeout:        5 * time.Minute,
                        IdleCheckFrequency: time.Minute,
                },
                Cache: infrastructure.CacheConfig{
                        ReviewTTL:         time.Hour,
                        HotelTTL:          2 * time.Hour,
                        ProviderTTL:       4 * time.Hour,
                        StatisticsTTL:     30 * time.Minute,
                        SearchTTL:         15 * time.Minute,
                        DefaultTTL:        time.Hour,
                        MaxKeyLength:      250,
                        EnableCompression: true,
                        CompressionLevel:  6,
                        PrefixSeparator:   ":",
                },
                Auth: *application.DefaultAuthMiddlewareConfig(),
                EventHandler: application.EventHandlerConfig{
                        MaxWorkers:          10,
                        MaxRetries:          3,
                        RetryDelay:          time.Second,
                        RetryBackoffFactor:  2.0,
                        MaxRetryDelay:       30 * time.Second,
                        ProcessingTimeout:   30 * time.Second,
                        BufferSize:          100,
                        EnableMetrics:       true,
                        EnableNotifications: true,
                        EnableReplay:        false,
                        DeadLetterThreshold: 5,
                },
                CacheService: application.CacheServiceConfig{
                        ReviewTTL:               time.Hour,
                        HotelTTL:                2 * time.Hour,
                        ProcessingTTL:           30 * time.Minute,
                        AnalyticsTTL:            time.Hour,
                        DefaultTTL:              time.Hour,
                        ReviewKeyPrefix:         "review",
                        HotelKeyPrefix:          "hotel",
                        ProcessingKeyPrefix:     "processing",
                        AnalyticsKeyPrefix:      "analytics",
                        WarmupConcurrency:       5,
                        WarmupBatchSize:         100,
                        EnableBackgroundWarmup:  true,
                        WarmupInterval:          time.Hour,
                        InvalidationBatchSize:   50,
                        InvalidationDelay:       time.Second,
                        EnableSmartInvalidation: true,
                        MaxConcurrentOperations: 10,
                        OperationTimeout:        30 * time.Second,
                        RetryAttempts:           3,
                        RetryDelay:              time.Second,
                },
                Processing: application.ProcessingConfig{
                        MaxWorkers:         5,
                        MaxConcurrentFiles: 3,
                        MaxRetries:         3,
                        RetryDelay:         5 * time.Second,
                        ProcessingTimeout:  5 * time.Minute,
                        WorkerIdleTimeout:  30 * time.Second,
                        MetricsInterval:    30 * time.Second,
                },
                ErrorHandler: infrastructure.ErrorHandlerConfig{
                        EnableMetrics:          true,
                        EnableAlerting:         true,
                        EnableStackTrace:       true,
                        EnableDetailedLogging:  true,
                        EnableErrorAggregation: true,
                        EnableRateLimiting:     true,
                        MaxStackTraceDepth:     50,
                        ErrorRetentionPeriod:   24 * time.Hour,
                        MetricsInterval:        time.Minute,
                        AlertingThreshold:      100,
                        AlertingWindow:         5 * time.Minute,
                        RateLimitWindow:        time.Minute,
                        RateLimitThreshold:     10,
                        DefaultFormat:          infrastructure.FormatJSON,
                        IncludeInternalErrors:  false,
                },
                Monitoring: monitoring.Config{
                        MetricsEnabled:      true,
                        MetricsPath:         "/metrics",
                        TracingEnabled:      false,
                        TracingServiceName:  "hotel-reviews",
                        TracingVersion:      "1.0.0",
                        TracingEnvironment:  "development",
                        JaegerEndpoint:      "http://localhost:14268/api/traces",
                        TracingSamplingRate: 0.1,
                        HealthEnabled:       true,
                        HealthPath:          "/health",
                },
                CircuitBreaker: *infrastructure.DefaultCircuitBreakerConfig(),
                App: AppSettings{
                        Name:                 "hotel-reviews-service",
                        Version:              "1.0.0",
                        Environment:          "development",
                        LogLevel:             "info",
                        EnableMetrics:        true,
                        EnableTracing:        false,
                        EnableHealthChecks:   true,
                        ShutdownTimeout:      30 * time.Second,
                        MaxRequestSize:       10 * 1024 * 1024, // 10MB
                        EnableRateLimit:      true,
                        EnableAuthentication: true,
                },
        }
}</span>

// Validate validates the entire application configuration
func (c *AppConfig) Validate() error <span class="cov10" title="39">{
        // Custom validation logic can be added here
        // For example, check that TLS settings are consistent
        if c.Server.EnableTLS </span><span class="cov0" title="0">{
                if c.Server.TLSCertFile == "" || c.Server.TLSKeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS enabled but cert or key file not specified")
                }</span>
        }

        // Validate that database and Redis configurations are compatible
        <span class="cov10" title="39">if c.Database.MaxConns &lt; c.Database.MinConns </span><span class="cov2" title="2">{
                return fmt.Errorf("database max_conns (%d) cannot be less than min_conns (%d)",
                        c.Database.MaxConns, c.Database.MinConns)
        }</span>

        // Validate processing configuration
        <span class="cov9" title="37">if c.Processing.MaxConcurrentFiles &gt; c.Processing.MaxWorkers </span><span class="cov0" title="0">{
                return fmt.Errorf("max_concurrent_files (%d) cannot exceed max_workers (%d)",
                        c.Processing.MaxConcurrentFiles, c.Processing.MaxWorkers)
        }</span>

        // Validate environment-specific settings
        <span class="cov9" title="37">if c.App.Environment == "production" </span><span class="cov0" title="0">{
                if c.App.LogLevel == "debug" </span><span class="cov0" title="0">{
                        return fmt.Errorf("debug log level not allowed in production")
                }</span>
                <span class="cov0" title="0">if !c.Server.EnableTLS </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS must be enabled in production")
                }</span>
        }

        <span class="cov9" title="37">return nil</span>
}

// GetServerAddr returns the full server address
func (c *AppConfig) GetServerAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetDatabaseDSN returns the database connection string
func (c *AppConfig) GetDatabaseDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Database.Host, c.Database.Port, c.Database.Username,
                c.Database.Password, c.Database.Database, c.Database.SSLMode)
}</span>

// GetRedisAddr returns the Redis connection address
func (c *AppConfig) GetRedisAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Redis.Host, c.Redis.Port)
}</span>

// IsProduction returns true if running in production environment
func (c *AppConfig) IsProduction() bool <span class="cov0" title="0">{
        return c.App.Environment == "production"
}</span>

// IsDevelopment returns true if running in development environment
func (c *AppConfig) IsDevelopment() bool <span class="cov0" title="0">{
        return c.App.Environment == "development"
}</span>

// GetConfigSummary returns a summary of key configuration values
func (c *AppConfig) GetConfigSummary() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "app_name":        c.App.Name,
                "app_version":     c.App.Version,
                "environment":     c.App.Environment,
                "server_addr":     c.GetServerAddr(),
                "database_host":   fmt.Sprintf("%s:%d", c.Database.Host, c.Database.Port),
                "redis_addr":      c.GetRedisAddr(),
                "log_level":       c.App.LogLevel,
                "metrics_enabled": c.App.EnableMetrics,
                "tracing_enabled": c.App.EnableTracing,
                "auth_enabled":    c.App.EnableAuthentication,
                "tls_enabled":     c.Server.EnableTLS,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "reflect"
        "sync"
        "time"

        "github.com/mitchellh/mapstructure"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/application"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// ConfigManager manages application configuration with hot-reloading
type ConfigManager struct {
        watcher     *infrastructure.ConfigWatcher
        config      *AppConfig
        configMutex sync.RWMutex
        logger      monitoring.Logger
        ctx         context.Context
        cancel      context.CancelFunc

        // Component references for reconfiguration
        server           *http.Server
        dbPool           interface{} // Database pool interface
        redisClient      interface{} // Redis client interface
        cacheService     *application.CacheService
        authMiddleware   *application.AuthMiddleware
        eventHandler     *application.BaseEventHandler
        errorHandler     *infrastructure.ErrorHandler
        monitoringSystem *monitoring.Service
        circuitBreaker   *infrastructure.CircuitBreaker

        // Configuration change metrics
        reloadCount    int64
        lastReloadTime time.Time
        errorCount     int64

        // Callbacks for component updates
        componentCallbacks map[string][]ComponentUpdateCallback
}

// ComponentUpdateCallback is called when a component needs reconfiguration
type ComponentUpdateCallback func(oldConfig, newConfig interface{}) error

// NewConfigManager creates a new configuration manager with hot-reloading
func NewConfigManager(logger monitoring.Logger) (*ConfigManager, error) <span class="cov3" title="10">{
        ctx, cancel := context.WithCancel(context.Background())

        // Create config watcher with optimized settings
        watcherOptions := &amp;infrastructure.ConfigWatcherOptions{
                WatchIntervalSec:    2,
                FileChecksum:        true,
                IgnoreHiddenFiles:   true,
                EnvCheckIntervalSec: 30,
                EnvVarPrefix:        "APP_",
                ValidateOnLoad:      true,
                EnableRollback:      true,
                MaxHistorySize:      50,
                RollbackTimeoutSec:  30,
                MaxRetries:          3,
                RetryDelaySec:       5,
                FailOnValidation:    false,
                BatchUpdates:        true,
                BatchIntervalMs:     1000,
                EnableDebugLogging:  true,
                LogConfigChanges:    true,
        }

        watcher, err := infrastructure.NewConfigWatcher(logger, watcherOptions)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create config watcher: %w", err)
        }</span>

        <span class="cov3" title="10">manager := &amp;ConfigManager{
                watcher:            watcher,
                logger:             logger,
                ctx:                ctx,
                cancel:             cancel,
                componentCallbacks: make(map[string][]ComponentUpdateCallback),
        }

        // Setup configuration monitoring
        if err := manager.setupConfigurationWatching(); err != nil </span><span class="cov1" title="1">{
                cancel()
                watcher.Stop()
                return nil, fmt.Errorf("failed to setup configuration watching: %w", err)
        }</span>

        <span class="cov3" title="9">return manager, nil</span>
}

// setupConfigurationWatching configures all configuration monitoring
func (cm *ConfigManager) setupConfigurationWatching() error <span class="cov3" title="10">{
        // Register main config change callback
        cm.watcher.RegisterChangeCallback("app_config", cm.handleAppConfigChange)

        // Register environment variable callbacks
        envCallbacks := map[string]func(string, interface{}, interface{}) error{
                "env:APP_LOG_LEVEL":       cm.handleLogLevelChange,
                "env:APP_DB_HOST":         cm.handleDatabaseHostChange,
                "env:APP_DB_PORT":         cm.handleDatabasePortChange,
                "env:APP_REDIS_HOST":      cm.handleRedisHostChange,
                "env:APP_REDIS_PORT":      cm.handleRedisPortChange,
                "env:APP_SERVER_PORT":     cm.handleServerPortChange,
                "env:APP_JWT_SECRET":      cm.handleJWTSecretChange,
                "env:APP_ENVIRONMENT":     cm.handleEnvironmentChange,
                "env:APP_MAX_CONNECTIONS": cm.handleMaxConnectionsChange,
        }

        for envKey, callback := range envCallbacks </span><span class="cov6" title="90">{
                cm.watcher.RegisterChangeCallback(envKey, callback)
        }</span>

        // Register custom validators
        <span class="cov3" title="10">cm.watcher.RegisterValidator("app_config", cm.validateAppConfig)

        // Watch main configuration file
        configPath := cm.getConfigFilePath()
        if _, err := os.Stat(configPath); err == nil </span><span class="cov3" title="10">{
                if err := cm.watcher.WatchFile("app_config", configPath); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to watch config file %s: %w", configPath, err)
                }</span>
                <span class="cov3" title="9">cm.logger.Info("Watching main configuration file", "path", configPath)</span>
        } else<span class="cov0" title="0"> {
                cm.logger.Info("Configuration file not found, using defaults", "path", configPath)

                // Register default configuration
                defaultConfig := GetDefaultConfig()
                if err := cm.watcher.RegisterConfig("app_config", defaultConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register default config: %w", err)
                }</span>
                <span class="cov0" title="0">cm.setConfig(defaultConfig)</span>
        }

        // Watch environment variables
        <span class="cov3" title="9">envVars := []string{
                "APP_LOG_LEVEL", "APP_DB_HOST", "APP_DB_PORT", "APP_REDIS_HOST",
                "APP_REDIS_PORT", "APP_SERVER_PORT", "APP_JWT_SECRET",
                "APP_ENVIRONMENT", "APP_MAX_CONNECTIONS",
        }

        for _, envVar := range envVars </span><span class="cov6" title="81">{
                if err := cm.watcher.WatchEnvVar("env_monitoring", envVar); err != nil </span><span class="cov0" title="0">{
                        cm.logger.Warn("Failed to watch environment variable", "var", envVar, "error", err)
                }</span>
        }

        <span class="cov3" title="9">return nil</span>
}

// getConfigFilePath determines the configuration file path
func (cm *ConfigManager) getConfigFilePath() string <span class="cov3" title="10">{
        // Check environment variable first
        if configPath := os.Getenv("CONFIG_PATH"); configPath != "" </span><span class="cov3" title="10">{
                return configPath
        }</span>

        // Check common locations
        <span class="cov0" title="0">possiblePaths := []string{
                "./config/app.json",
                "./config/app.yaml",
                "./app.json",
                "./app.yaml",
                "/etc/hotel-reviews/app.json",
                "/etc/hotel-reviews/app.yaml",
        }

        for _, path := range possiblePaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        // Default to JSON in config directory
        <span class="cov0" title="0">return "./config/app.json"</span>
}

// handleAppConfigChange handles changes to the main application configuration
func (cm *ConfigManager) handleAppConfigChange(configName string, oldConfig, newConfig interface{}) error <span class="cov4" title="19">{
        cm.logger.Info("Application configuration change detected", "config", configName)

        // Convert to AppConfig
        var appConfig AppConfig
        if err := cm.mapToStruct(newConfig, &amp;appConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert config to AppConfig: %w", err)
        }</span>

        // Validate the new configuration
        <span class="cov4" title="19">if err := appConfig.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov4" title="18">oldAppConfig := cm.GetConfig()

        // Update configuration atomically
        cm.setConfig(&amp;appConfig)

        // Reconfigure components
        if err := cm.reconfigureComponents(oldAppConfig, &amp;appConfig); err != nil </span><span class="cov0" title="0">{
                // Rollback on failure
                cm.setConfig(oldAppConfig)
                return fmt.Errorf("failed to reconfigure components, rolled back: %w", err)
        }</span>

        <span class="cov4" title="18">cm.reloadCount++
        cm.lastReloadTime = time.Now()

        cm.logger.Info("Application configuration successfully updated",
                "reload_count", cm.reloadCount,
                "changes", cm.getConfigChanges(oldAppConfig, &amp;appConfig))

        return nil</span>
}

// Environment variable change handlers
func (cm *ConfigManager) handleLogLevelChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newLevel := newConfig.(string)
        cm.logger.Info("Log level changed", "old", oldConfig, "new", newLevel)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.App.LogLevel = newLevel
                // Note: Monitoring config doesn't have LogLevel field, handle separately if needed

                if err := cm.reconfigureLogging(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure logging: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleDatabaseHostChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newHost := newConfig.(string)
        cm.logger.Info("Database host changed", "old", oldConfig, "new", newHost)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Database.Host = newHost

                if err := cm.reconfigureDatabase(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure database: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleDatabasePortChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newPort := int(newConfig.(float64)) // JSON numbers are float64
        cm.logger.Info("Database port changed", "old", oldConfig, "new", newPort)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Database.Port = newPort

                if err := cm.reconfigureDatabase(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure database: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleRedisHostChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newHost := newConfig.(string)
        cm.logger.Info("Redis host changed", "old", oldConfig, "new", newHost)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Redis.Host = newHost

                if err := cm.reconfigureRedis(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure Redis: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleRedisPortChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newPort := int(newConfig.(float64))
        cm.logger.Info("Redis port changed", "old", oldConfig, "new", newPort)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Redis.Port = newPort

                if err := cm.reconfigureRedis(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure Redis: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleServerPortChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newPort := int(newConfig.(float64))
        cm.logger.Info("Server port changed", "old", oldConfig, "new", newPort)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Server.Port = newPort

                if err := cm.reconfigureServer(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure server: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleJWTSecretChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newSecret := newConfig.(string)

        if len(newSecret) &lt; 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret must be at least 32 characters long")
        }</span>

        <span class="cov0" title="0">cm.logger.Info("JWT secret changed", "length", len(newSecret))

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Auth.JWTSecret = newSecret

                if err := cm.reconfigureAuth(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure auth: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleEnvironmentChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newEnv := newConfig.(string)
        cm.logger.Info("Environment changed", "old", oldConfig, "new", newEnv)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.App.Environment = newEnv

                // Environment changes may require full reconfiguration
                if err := cm.reconfigureComponents(config, &amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure for new environment: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cm *ConfigManager) handleMaxConnectionsChange(configName string, oldConfig, newConfig interface{}) error <span class="cov0" title="0">{
        newMaxConns := int(newConfig.(float64))
        cm.logger.Info("Max connections changed", "old", oldConfig, "new", newMaxConns)

        config := cm.GetConfig()
        if config != nil </span><span class="cov0" title="0">{
                configCopy := *config
                configCopy.Database.MaxConns = newMaxConns

                if err := cm.reconfigureDatabase(&amp;configCopy); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reconfigure database connections: %w", err)
                }</span>

                <span class="cov0" title="0">cm.setConfig(&amp;configCopy)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAppConfig provides comprehensive validation
func (cm *ConfigManager) validateAppConfig(config interface{}) error <span class="cov4" title="20">{
        // Handle nil config
        if config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config is nil")
        }</span>

        // If it's already an AppConfig struct, validate directly
        <span class="cov4" title="20">if appConfig, ok := config.(*AppConfig); ok </span><span class="cov0" title="0">{
                return appConfig.Validate()
        }</span>
        <span class="cov4" title="20">if appConfig, ok := config.(AppConfig); ok </span><span class="cov0" title="0">{
                return appConfig.Validate()
        }</span>

        // Otherwise, try to convert from map to struct
        <span class="cov4" title="20">var appConfig AppConfig
        if err := cm.mapToStruct(config, &amp;appConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config format: %w", err)
        }</span>

        <span class="cov4" title="20">return appConfig.Validate()</span>
}

// Component reconfiguration methods
func (cm *ConfigManager) reconfigureComponents(oldConfig, newConfig *AppConfig) error <span class="cov4" title="18">{
        var errors []error

        // If oldConfig is nil, treat all components as changed (initial configuration)
        // Reconfigure in dependency order
        if oldConfig == nil || !reflect.DeepEqual(oldConfig.Monitoring, newConfig.Monitoring) </span><span class="cov3" title="9">{
                if err := cm.reconfigureMonitoring(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("monitoring: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.Database, newConfig.Database) </span><span class="cov4" title="12">{
                if err := cm.reconfigureDatabase(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("database: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.Redis, newConfig.Redis) </span><span class="cov3" title="9">{
                if err := cm.reconfigureRedis(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("redis: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.Auth, newConfig.Auth) </span><span class="cov3" title="10">{
                if err := cm.reconfigureAuth(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("auth: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.Server, newConfig.Server) </span><span class="cov4" title="18">{
                if err := cm.reconfigureServer(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("server: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.CacheService, newConfig.CacheService) </span><span class="cov3" title="9">{
                if err := cm.reconfigureCacheService(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("cache service: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if oldConfig == nil || !reflect.DeepEqual(oldConfig.EventHandler, newConfig.EventHandler) </span><span class="cov3" title="9">{
                if err := cm.reconfigureEventHandler(newConfig); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("event handler: %w", err))
                }</span>
        }

        <span class="cov4" title="18">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("reconfiguration errors: %v", errors)
        }</span>

        <span class="cov4" title="18">return nil</span>
}

func (cm *ConfigManager) reconfigureLogging(config *AppConfig) error <span class="cov0" title="0">{
        cm.logger.Info("Reconfiguring logging", "level", config.App.LogLevel)
        // Implementation would reconfigure the logging system
        // This is a placeholder for actual logging reconfiguration
        return nil
}</span>

func (cm *ConfigManager) reconfigureMonitoring(config *AppConfig) error <span class="cov3" title="9">{
        cm.logger.Info("Reconfiguring monitoring system")
        if cm.monitoringSystem != nil </span>{<span class="cov0" title="0">
                // Implementation would reconfigure the monitoring system
                // This is a placeholder for actual monitoring reconfiguration
        }</span>
        <span class="cov3" title="9">return nil</span>
}

func (cm *ConfigManager) reconfigureDatabase(config *AppConfig) error <span class="cov4" title="12">{
        cm.logger.Info("Reconfiguring database connection",
                "host", config.Database.Host,
                "port", config.Database.Port,
                "max_conns", config.Database.MaxConns)

        // Implementation would reconfigure the database pool
        // This is a placeholder for actual database reconfiguration
        return nil
}</span>

func (cm *ConfigManager) reconfigureRedis(config *AppConfig) error <span class="cov3" title="9">{
        cm.logger.Info("Reconfiguring Redis connection",
                "host", config.Redis.Host,
                "port", config.Redis.Port,
                "pool_size", config.Redis.PoolSize)

        // Implementation would reconfigure the Redis client
        // This is a placeholder for actual Redis reconfiguration
        return nil
}</span>

func (cm *ConfigManager) reconfigureAuth(config *AppConfig) error <span class="cov3" title="10">{
        cm.logger.Info("Reconfiguring authentication middleware")
        if cm.authMiddleware != nil </span>{<span class="cov0" title="0">
                // Implementation would reconfigure the auth middleware
                // This is a placeholder for actual auth reconfiguration
        }</span>
        <span class="cov3" title="10">return nil</span>
}

func (cm *ConfigManager) reconfigureServer(config *AppConfig) error <span class="cov4" title="18">{
        cm.logger.Info("Reconfiguring HTTP server",
                "host", config.Server.Host,
                "port", config.Server.Port,
                "tls_enabled", config.Server.EnableTLS)

        // For server reconfiguration, we might need to restart the server
        // This is a placeholder for actual server reconfiguration
        return nil
}</span>

func (cm *ConfigManager) reconfigureCacheService(config *AppConfig) error <span class="cov3" title="9">{
        cm.logger.Info("Reconfiguring cache service")
        if cm.cacheService != nil </span>{<span class="cov0" title="0">
                // Implementation would reconfigure the cache service
                // This is a placeholder for actual cache service reconfiguration
        }</span>
        <span class="cov3" title="9">return nil</span>
}

func (cm *ConfigManager) reconfigureEventHandler(config *AppConfig) error <span class="cov3" title="9">{
        cm.logger.Info("Reconfiguring event handler",
                "max_workers", config.EventHandler.MaxWorkers,
                "buffer_size", config.EventHandler.BufferSize)

        if cm.eventHandler != nil </span>{<span class="cov0" title="0">
                // Implementation would reconfigure the event handler
                // This is a placeholder for actual event handler reconfiguration
        }</span>
        <span class="cov3" title="9">return nil</span>
}

// Utility methods
func (cm *ConfigManager) mapToStruct(input interface{}, output interface{}) error <span class="cov5" title="39">{
        // Handle nil input
        if input == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("input is nil")
        }</span>

        <span class="cov5" title="39">config := &amp;mapstructure.DecoderConfig{
                Metadata: nil,
                Result:   output,
                TagName:  "json",
                DecodeHook: mapstructure.ComposeDecodeHookFunc(
                        mapstructure.StringToTimeDurationHookFunc(),
                        mapstructure.StringToSliceHookFunc(","),
                ),
                WeaklyTypedInput: true,  // Allow type coercion
                ErrorUnused:      false, // Don't error on unused fields
        }

        decoder, err := mapstructure.NewDecoder(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create decoder: %w", err)
        }</span>

        <span class="cov5" title="39">if err := decoder.Decode(input); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode input to struct: %w", err)
        }</span>

        <span class="cov5" title="39">return nil</span>
}

func (cm *ConfigManager) getConfigChanges(oldConfig, newConfig *AppConfig) map[string]interface{} <span class="cov4" title="18">{
        changes := make(map[string]interface{})

        // If oldConfig is nil, don't show changes (initial configuration)
        if oldConfig == nil </span><span class="cov3" title="9">{
                return changes
        }</span>

        <span class="cov3" title="9">if oldConfig.Server.Port != newConfig.Server.Port </span><span class="cov3" title="9">{
                changes["server_port"] = fmt.Sprintf("%d -&gt; %d", oldConfig.Server.Port, newConfig.Server.Port)
        }</span>
        <span class="cov3" title="9">if oldConfig.Database.Host != newConfig.Database.Host </span><span class="cov0" title="0">{
                changes["db_host"] = fmt.Sprintf("%s -&gt; %s", oldConfig.Database.Host, newConfig.Database.Host)
        }</span>
        <span class="cov3" title="9">if oldConfig.App.LogLevel != newConfig.App.LogLevel </span><span class="cov2" title="3">{
                changes["log_level"] = fmt.Sprintf("%s -&gt; %s", oldConfig.App.LogLevel, newConfig.App.LogLevel)
        }</span>

        <span class="cov3" title="9">return changes</span>
}

// Public API methods
func (cm *ConfigManager) GetConfig() *AppConfig <span class="cov10" title="1027">{
        cm.configMutex.RLock()
        defer cm.configMutex.RUnlock()

        if cm.config == nil </span><span class="cov3" title="9">{
                return nil
        }</span>

        // Return a copy to prevent external modifications
        <span class="cov9" title="1018">configCopy := *cm.config
        return &amp;configCopy</span>
}

func (cm *ConfigManager) setConfig(config *AppConfig) <span class="cov4" title="18">{
        cm.configMutex.Lock()
        defer cm.configMutex.Unlock()
        cm.config = config
}</span>

func (cm *ConfigManager) GetConfigHistory() []infrastructure.ConfigSnapshot <span class="cov1" title="2">{
        return cm.watcher.GetConfigHistory("app_config")
}</span>

func (cm *ConfigManager) RollbackConfig(targetHash string) error <span class="cov1" title="1">{
        cm.logger.Info("Rolling back configuration", "target_hash", targetHash)

        if err := cm.watcher.RollbackConfig("app_config", targetHash); err != nil </span><span class="cov0" title="0">{
                cm.errorCount++
                return fmt.Errorf("rollback failed: %w", err)
        }</span>

        <span class="cov1" title="1">cm.logger.Info("Configuration rollback completed", "target_hash", targetHash)
        return nil</span>
}

func (cm *ConfigManager) GetMetrics() map[string]interface{} <span class="cov2" title="4">{
        watcherMetrics := cm.watcher.GetMetrics()

        // Add our own metrics
        watcherMetrics["config_reload_count"] = cm.reloadCount
        watcherMetrics["config_error_count"] = cm.errorCount
        watcherMetrics["last_config_reload"] = cm.lastReloadTime

        return watcherMetrics
}</span>

func (cm *ConfigManager) HealthCheck() error <span class="cov1" title="2">{
        if err := cm.watcher.HealthCheck(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config watcher health check failed: %w", err)
        }</span>

        <span class="cov1" title="2">if cm.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration loaded")
        }</span>

        <span class="cov1" title="2">return nil</span>
}

func (cm *ConfigManager) Stop() error <span class="cov3" title="9">{
        cm.logger.Info("Stopping configuration manager")

        cm.cancel()

        if cm.watcher != nil </span><span class="cov3" title="9">{
                return cm.watcher.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RegisterComponent allows components to register for configuration updates
func (cm *ConfigManager) RegisterComponent(componentName string, callback ComponentUpdateCallback) <span class="cov3" title="5">{
        cm.componentCallbacks[componentName] = append(cm.componentCallbacks[componentName], callback)
        cm.logger.Debug("Registered component for config updates", "component", componentName)
}</span>

// SetComponentReferences allows setting references to application components
func (cm *ConfigManager) SetComponentReferences(components map[string]interface{}) <span class="cov0" title="0">{
        if server, ok := components["server"].(*http.Server); ok </span><span class="cov0" title="0">{
                cm.server = server
        }</span>
        <span class="cov0" title="0">if dbPool, ok := components["database"]; ok </span><span class="cov0" title="0">{
                cm.dbPool = dbPool
        }</span>
        <span class="cov0" title="0">if redisClient, ok := components["redis"]; ok </span><span class="cov0" title="0">{
                cm.redisClient = redisClient
        }</span>
        <span class="cov0" title="0">if cacheService, ok := components["cache_service"].(*application.CacheService); ok </span><span class="cov0" title="0">{
                cm.cacheService = cacheService
        }</span>
        <span class="cov0" title="0">if authMiddleware, ok := components["auth_middleware"].(*application.AuthMiddleware); ok </span><span class="cov0" title="0">{
                cm.authMiddleware = authMiddleware
        }</span>
        <span class="cov0" title="0">if eventHandler, ok := components["event_handler"].(*application.BaseEventHandler); ok </span><span class="cov0" title="0">{
                cm.eventHandler = eventHandler
        }</span>
        <span class="cov0" title="0">if errorHandler, ok := components["error_handler"].(*infrastructure.ErrorHandler); ok </span><span class="cov0" title="0">{
                cm.errorHandler = errorHandler
        }</span>
        <span class="cov0" title="0">if monitoringSystem, ok := components["monitoring"].(*monitoring.Service); ok </span><span class="cov0" title="0">{
                cm.monitoringSystem = monitoringSystem
        }</span>
        <span class="cov0" title="0">if circuitBreaker, ok := components["circuit_breaker"].(*infrastructure.CircuitBreaker); ok </span><span class="cov0" title="0">{
                cm.circuitBreaker = circuitBreaker
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package domain

import (
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Provider represents a review provider (e.g., Booking.com, Expedia)
type Provider struct {
        ID        uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Name      string         `json:"name" gorm:"type:varchar(100);not null;unique" validate:"required,min=1,max=100"`
        BaseURL   string         `json:"base_url" gorm:"type:varchar(255)" validate:"url"`
        IsActive  bool           `json:"is_active" gorm:"default:true"`
        CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
}

// Hotel represents a hotel entity
type Hotel struct {
        ID          uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Name        string         `json:"name" gorm:"type:varchar(255);not null" validate:"required,min=1,max=255"`
        Address     string         `json:"address" gorm:"type:text"`
        City        string         `json:"city" gorm:"type:varchar(100)" validate:"max=100"`
        Country     string         `json:"country" gorm:"type:varchar(100)" validate:"max=100"`
        PostalCode  string         `json:"postal_code" gorm:"type:varchar(20)" validate:"max=20"`
        Phone       string         `json:"phone" gorm:"type:varchar(20)" validate:"max=20"`
        Email       string         `json:"email" gorm:"type:varchar(255)" validate:"email,max=255"`
        StarRating  int            `json:"star_rating" gorm:"type:int;check:star_rating &gt;= 1 AND star_rating &lt;= 5" validate:"min=1,max=5"`
        Description string         `json:"description" gorm:"type:text"`
        Website     string         `json:"website" gorm:"type:varchar(255)" validate:"url,max=255"`
        Amenities   []string       `json:"amenities" gorm:"type:jsonb"`
        Images      []string       `json:"images" gorm:"type:jsonb"`
        Latitude    float64        `json:"latitude" gorm:"type:decimal(10,8)" validate:"min=-90,max=90"`
        Longitude   float64        `json:"longitude" gorm:"type:decimal(11,8)" validate:"min=-180,max=180"`
        CreatedAt   time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt   time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt   gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Reviews []Review `json:"reviews,omitempty" gorm:"foreignKey:HotelID"`
}

// ReviewerInfo represents reviewer information
type ReviewerInfo struct {
        ID              uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Name            string         `json:"name" gorm:"type:varchar(255)" validate:"max=255"`
        Email           string         `json:"email" gorm:"type:varchar(255)" validate:"email,max=255"`
        Location        string         `json:"location" gorm:"type:varchar(100)" validate:"max=100"`
        ReviewerLevel   string         `json:"reviewer_level" gorm:"type:varchar(50)" validate:"max=50"`
        HelpfulVotes    int            `json:"helpful_votes" gorm:"default:0"`
        IsVerified      bool           `json:"is_verified" gorm:"default:false"`
        TotalReviews    int            `json:"total_reviews" gorm:"default:0"`
        AverageRating   float64        `json:"average_rating" gorm:"type:decimal(3,2);default:0.0"`
        MemberSince     *time.Time     `json:"member_since,omitempty"`
        ProfileImageURL string         `json:"profile_image_url" gorm:"type:varchar(500)" validate:"url,max=500"`
        Bio             string         `json:"bio" gorm:"type:text"`
        CreatedAt       time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt       time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt       gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Reviews []Review `json:"reviews,omitempty" gorm:"foreignKey:ReviewerInfoID"`
}

// Review represents a hotel review
type Review struct {
        ID             uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        ProviderID     uuid.UUID  `json:"provider_id" gorm:"type:uuid;not null" validate:"required"`
        HotelID        uuid.UUID  `json:"hotel_id" gorm:"type:uuid;not null" validate:"required"`
        UserID         *uuid.UUID `json:"user_id,omitempty" gorm:"type:uuid"`
        ReviewerInfoID *uuid.UUID `json:"reviewer_info_id,omitempty" gorm:"type:uuid"`
        ExternalID     string     `json:"external_id" gorm:"type:varchar(255)" validate:"max=255"`
        Rating         float64    `json:"rating" gorm:"type:decimal(3,2);not null;check:rating &gt;= 1.0 AND rating &lt;= 5.0" validate:"required,min=1.0,max=5.0"`
        Title          string     `json:"title" gorm:"type:varchar(500)" validate:"max=500"`
        Comment        string     `json:"comment" gorm:"type:text"`
        ReviewDate     time.Time  `json:"review_date" gorm:"not null" validate:"required"`
        StayDate       *time.Time `json:"stay_date,omitempty"`
        TravelDate     *time.Time `json:"travel_date,omitempty"`
        TripType       string     `json:"trip_type" gorm:"type:varchar(50)" validate:"max=50"`
        TravelType     string     `json:"travel_type" gorm:"type:varchar(50)" validate:"max=50"`
        RoomType       string     `json:"room_type" gorm:"type:varchar(100)" validate:"max=100"`
        IsVerified     bool       `json:"is_verified" gorm:"default:false"`
        HelpfulVotes   int        `json:"helpful_votes" gorm:"default:0"`
        HelpfulCount   int        `json:"helpful_count" gorm:"default:0"`
        TotalVotes     int        `json:"total_votes" gorm:"default:0"`
        Pros           []string   `json:"pros" gorm:"type:jsonb"`
        Cons           []string   `json:"cons" gorm:"type:jsonb"`
        Images         []string   `json:"images" gorm:"type:jsonb"`
        Language       string     `json:"language" gorm:"type:varchar(10);default:'en'" validate:"max=10"`
        Sentiment      string     `json:"sentiment" gorm:"type:varchar(20)" validate:"max=20"`
        Source         string     `json:"source" gorm:"type:varchar(100)" validate:"max=100"`

        // Detailed ratings
        ServiceRating     *float64 `json:"service_rating,omitempty" gorm:"type:decimal(3,2);check:service_rating &gt;= 1.0 AND service_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`
        CleanlinessRating *float64 `json:"cleanliness_rating,omitempty" gorm:"type:decimal(3,2);check:cleanliness_rating &gt;= 1.0 AND cleanliness_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`
        LocationRating    *float64 `json:"location_rating,omitempty" gorm:"type:decimal(3,2);check:location_rating &gt;= 1.0 AND location_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`
        ValueRating       *float64 `json:"value_rating,omitempty" gorm:"type:decimal(3,2);check:value_rating &gt;= 1.0 AND value_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`
        ComfortRating     *float64 `json:"comfort_rating,omitempty" gorm:"type:decimal(3,2);check:comfort_rating &gt;= 1.0 AND comfort_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`
        FacilitiesRating  *float64 `json:"facilities_rating,omitempty" gorm:"type:decimal(3,2);check:facilities_rating &gt;= 1.0 AND facilities_rating &lt;= 5.0" validate:"omitempty,min=1.0,max=5.0"`

        // Metadata
        Metadata       map[string]interface{} `json:"metadata,omitempty" gorm:"type:jsonb"`
        ProcessedAt    *time.Time             `json:"processed_at,omitempty"`
        ProcessingHash string                 `json:"processing_hash" gorm:"type:varchar(64)" validate:"max=64"`

        // Timestamps
        CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Provider     Provider     `json:"provider" gorm:"foreignKey:ProviderID"`
        Hotel        Hotel        `json:"hotel" gorm:"foreignKey:HotelID"`
        ReviewerInfo ReviewerInfo `json:"reviewer_info" gorm:"foreignKey:ReviewerInfoID"`
}

// ReviewSummary represents aggregated review statistics for a hotel
type ReviewSummary struct {
        ID                 uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        HotelID            uuid.UUID      `json:"hotel_id" gorm:"type:uuid;not null;unique" validate:"required"`
        TotalReviews       int            `json:"total_reviews" gorm:"default:0"`
        AverageRating      float64        `json:"average_rating" gorm:"type:decimal(3,2);default:0.0"`
        RatingDistribution map[string]int `json:"rating_distribution" gorm:"type:jsonb"`

        // Average detailed ratings
        AvgServiceRating     float64 `json:"avg_service_rating" gorm:"type:decimal(3,2);default:0.0"`
        AvgCleanlinessRating float64 `json:"avg_cleanliness_rating" gorm:"type:decimal(3,2);default:0.0"`
        AvgLocationRating    float64 `json:"avg_location_rating" gorm:"type:decimal(3,2);default:0.0"`
        AvgValueRating       float64 `json:"avg_value_rating" gorm:"type:decimal(3,2);default:0.0"`
        AvgComfortRating     float64 `json:"avg_comfort_rating" gorm:"type:decimal(3,2);default:0.0"`
        AvgFacilitiesRating  float64 `json:"avg_facilities_rating" gorm:"type:decimal(3,2);default:0.0"`

        LastReviewDate time.Time      `json:"last_review_date"`
        CreatedAt      time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt      gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Hotel Hotel `json:"hotel" gorm:"foreignKey:HotelID"`
}

// ReviewProcessingStatus represents the status of review processing
type ReviewProcessingStatus struct {
        ID               uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        ProviderID       uuid.UUID      `json:"provider_id" gorm:"type:uuid;not null" validate:"required"`
        Status           string         `json:"status" gorm:"type:varchar(50);not null" validate:"required,oneof=pending processing completed failed"`
        StartedAt        *time.Time     `json:"started_at,omitempty"`
        CompletedAt      *time.Time     `json:"completed_at,omitempty"`
        ErrorMsg         string         `json:"error_msg,omitempty" gorm:"type:text"`
        RecordsProcessed int            `json:"records_processed" gorm:"default:0"`
        RecordsTotal     int            `json:"records_total" gorm:"default:0"`
        FileURL          string         `json:"file_url" gorm:"type:varchar(500)" validate:"url,max=500"`
        CreatedAt        time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt        time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt        gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Provider Provider `json:"provider" gorm:"foreignKey:ProviderID"`
}

// User represents a system user
type User struct {
        ID               uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Username         string         `json:"username" gorm:"type:varchar(50);not null;unique" validate:"required,min=3,max=50"`
        Email            string         `json:"email" gorm:"type:varchar(255);not null;unique" validate:"required,email,max=255"`
        PasswordHash     string         `json:"-" gorm:"type:varchar(255);not null"`
        FirstName        string         `json:"first_name" gorm:"type:varchar(100)" validate:"max=100"`
        LastName         string         `json:"last_name" gorm:"type:varchar(100)" validate:"max=100"`
        IsActive         bool           `json:"is_active" gorm:"default:true"`
        IsVerified       bool           `json:"is_verified" gorm:"default:false"`
        LastLoginAt      *time.Time     `json:"last_login_at,omitempty"`
        PasswordExpiry   *time.Time     `json:"password_expiry,omitempty"`
        FailedAttempts   int            `json:"failed_attempts" gorm:"default:0"`
        LockedUntil      *time.Time     `json:"locked_until,omitempty"`
        TwoFactorEnabled bool           `json:"two_factor_enabled" gorm:"default:false"`
        TwoFactorSecret  string         `json:"-" gorm:"type:varchar(255)"`
        CreatedAt        time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt        time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt        gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Roles     []Role     `json:"roles,omitempty" gorm:"many2many:user_roles;"`
        Sessions  []Session  `json:"sessions,omitempty" gorm:"foreignKey:UserID"`
        ApiKeys   []ApiKey   `json:"api_keys,omitempty" gorm:"foreignKey:UserID"`
        AuditLogs []AuditLog `json:"audit_logs,omitempty" gorm:"foreignKey:UserID"`
}

// Role represents a user role
type Role struct {
        ID          uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Name        string         `json:"name" gorm:"type:varchar(50);not null;unique" validate:"required,min=1,max=50"`
        Description string         `json:"description" gorm:"type:text"`
        IsActive    bool           `json:"is_active" gorm:"default:true"`
        CreatedAt   time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt   time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt   gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Users       []User       `json:"users,omitempty" gorm:"many2many:user_roles;"`
        Permissions []Permission `json:"permissions,omitempty" gorm:"many2many:role_permissions;"`
}

// Permission represents a system permission
type Permission struct {
        ID          uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Name        string         `json:"name" gorm:"type:varchar(100);not null;unique" validate:"required,min=1,max=100"`
        Resource    string         `json:"resource" gorm:"type:varchar(50);not null" validate:"required,max=50"`
        Action      string         `json:"action" gorm:"type:varchar(20);not null" validate:"required,oneof=create read update delete execute"`
        Description string         `json:"description" gorm:"type:text"`
        IsActive    bool           `json:"is_active" gorm:"default:true"`
        CreatedAt   time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt   time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt   gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        Roles []Role `json:"roles,omitempty" gorm:"many2many:role_permissions;"`
}

// Session represents a user session
type Session struct {
        ID               uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        UserID           uuid.UUID      `json:"user_id" gorm:"type:uuid;not null" validate:"required"`
        AccessToken      string         `json:"access_token" gorm:"type:text;not null"`
        RefreshToken     string         `json:"refresh_token" gorm:"type:text;not null"`
        ExpiresAt        time.Time      `json:"expires_at" gorm:"not null"`
        RefreshExpiresAt time.Time      `json:"refresh_expires_at" gorm:"not null"`
        IsActive         bool           `json:"is_active" gorm:"default:true"`
        UserAgent        string         `json:"user_agent" gorm:"type:text"`
        IpAddress        string         `json:"ip_address" gorm:"type:varchar(45)"`
        DeviceId         string         `json:"device_id" gorm:"type:varchar(255)"`
        LastUsedAt       time.Time      `json:"last_used_at" gorm:"autoUpdateTime"`
        CreatedAt        time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt        time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt        gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        User User `json:"user" gorm:"foreignKey:UserID"`
}

// ApiKey represents an API key for service-to-service authentication
type ApiKey struct {
        ID         uuid.UUID      `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        UserID     uuid.UUID      `json:"user_id" gorm:"type:uuid;not null" validate:"required"`
        Name       string         `json:"name" gorm:"type:varchar(100);not null" validate:"required,min=1,max=100"`
        Key        string         `json:"key" gorm:"type:varchar(255);not null;unique"`
        KeyHash    string         `json:"-" gorm:"type:varchar(255);not null"`
        IsActive   bool           `json:"is_active" gorm:"default:true"`
        ExpiresAt  *time.Time     `json:"expires_at,omitempty"`
        LastUsedAt *time.Time     `json:"last_used_at,omitempty"`
        UsageCount int            `json:"usage_count" gorm:"default:0"`
        RateLimit  int            `json:"rate_limit" gorm:"default:1000"`
        Scopes     []string       `json:"scopes" gorm:"type:jsonb"`
        CreatedAt  time.Time      `json:"created_at" gorm:"autoCreateTime"`
        UpdatedAt  time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
        DeletedAt  gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`

        // Relationships
        User User `json:"user" gorm:"foreignKey:UserID"`
}

// AuditLog represents an audit log entry
type AuditLog struct {
        ID         uuid.UUID              `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        UserID     *uuid.UUID             `json:"user_id,omitempty" gorm:"type:uuid"`
        Action     string                 `json:"action" gorm:"type:varchar(50);not null" validate:"required,max=50"`
        Resource   string                 `json:"resource" gorm:"type:varchar(50);not null" validate:"required,max=50"`
        ResourceID *uuid.UUID             `json:"resource_id,omitempty" gorm:"type:uuid"`
        OldValues  map[string]interface{} `json:"old_values,omitempty" gorm:"type:jsonb"`
        NewValues  map[string]interface{} `json:"new_values,omitempty" gorm:"type:jsonb"`
        IpAddress  string                 `json:"ip_address" gorm:"type:varchar(45)"`
        UserAgent  string                 `json:"user_agent" gorm:"type:text"`
        Result     string                 `json:"result" gorm:"type:varchar(20);not null" validate:"required,oneof=success failure"`
        ErrorMsg   string                 `json:"error_msg,omitempty" gorm:"type:text"`
        CreatedAt  time.Time              `json:"created_at" gorm:"autoCreateTime"`

        // Relationships
        User *User `json:"user,omitempty" gorm:"foreignKey:UserID"`
}

// LoginAttempt represents a login attempt for rate limiting
type LoginAttempt struct {
        ID            uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()" validate:"required"`
        Email         string    `json:"email" gorm:"type:varchar(255);not null" validate:"required,email,max=255"`
        IpAddress     string    `json:"ip_address" gorm:"type:varchar(45);not null" validate:"required"`
        UserAgent     string    `json:"user_agent" gorm:"type:text"`
        Success       bool      `json:"success" gorm:"default:false"`
        FailureReason string    `json:"failure_reason,omitempty" gorm:"type:varchar(100)"`
        CreatedAt     time.Time `json:"created_at" gorm:"autoCreateTime"`
}

// ReviewStatistics represents statistics for reviews
type ReviewStatistics struct {
        TotalReviews       int64          `json:"total_reviews"`
        AverageRating      float64        `json:"average_rating"`
        LastUpdated        time.Time      `json:"last_updated"`
        RatingDistribution map[int]int    `json:"rating_distribution"`
        ReviewsByProvider  map[string]int `json:"reviews_by_provider"`
}

// Common errors
var (
        // Review errors
        ErrReviewNotFound      = fmt.Errorf("review not found")
        ErrReviewAlreadyExists = fmt.Errorf("review already exists")
        
        // Hotel errors
        ErrHotelNotFound      = fmt.Errorf("hotel not found")
        ErrHotelAlreadyExists = fmt.Errorf("hotel already exists")
        
        // Provider errors
        ErrProviderNotFound      = fmt.Errorf("provider not found")
        ErrProviderAlreadyExists = fmt.Errorf("provider already exists")
        
        // Validation errors
        ErrValidationFailed = fmt.Errorf("validation failed")
)

// ValidationError represents a validation error with field-specific details
type ValidationError struct {
        Field   string      `json:"field"`
        Message string      `json:"message"`
        Value   interface{} `json:"value,omitempty"`
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("validation failed for field '%s': %s", e.Field, e.Message)
}</span>

// NewValidationError creates a new validation error
func NewValidationError(field, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:   field,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package domain

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// EventVersion represents the version of an event schema
type EventVersion string

const (
        // Event schema versions
        EventVersionV1 EventVersion = "1.0"
        EventVersionV2 EventVersion = "2.0"
        EventVersionV3 EventVersion = "3.0"
)

// EventType represents the type of domain event
type EventType string

const (
        // File Processing Events
        FileProcessingStartedEventType   EventType = "FileProcessingStarted"
        FileProcessingProgressEventType  EventType = "FileProcessingProgress"
        FileProcessingCompletedEventType EventType = "FileProcessingCompleted"
        FileProcessingFailedEventType    EventType = "FileProcessingFailed"
        FileProcessingCancelledEventType EventType = "FileProcessingCancelled"
        FileProcessingRetryEventType     EventType = "FileProcessingRetry"

        // Review Processing Events
        ReviewProcessedEventType         EventType = "ReviewProcessed"
        ReviewValidatedEventType         EventType = "ReviewValidated"
        ReviewEnrichedEventType          EventType = "ReviewEnriched"
        ReviewBatchProcessedEventType    EventType = "ReviewBatchProcessed"
        ReviewProcessingFailedEventType  EventType = "ReviewProcessingFailed"
        ReviewDuplicateDetectedEventType EventType = "ReviewDuplicateDetected"

        // Hotel Events
        HotelCreatedEventType          EventType = "HotelCreated"
        HotelUpdatedEventType          EventType = "HotelUpdated"
        HotelSummaryUpdatedEventType   EventType = "HotelSummaryUpdated"
        HotelAnalyticsUpdatedEventType EventType = "HotelAnalyticsUpdated"

        // Provider Events
        ProviderActivatedEventType   EventType = "ProviderActivated"
        ProviderDeactivatedEventType EventType = "ProviderDeactivated"
        ProviderErrorEvent           EventType = "ProviderError"
        ProviderSyncedEvent          EventType = "ProviderSynced"

        // System Events
        SystemHealthCheckEvent EventType = "SystemHealthCheck"
        SystemErrorEvent       EventType = "SystemError"
        SystemMetricsEvent     EventType = "SystemMetrics"
)

// EventStatus represents the status of an event
type EventStatus string

const (
        EventStatusPublished  EventStatus = "published"
        EventStatusProcessing EventStatus = "processing"
        EventStatusProcessed  EventStatus = "processed"
        EventStatusFailed     EventStatus = "failed"
        EventStatusRetry      EventStatus = "retry"
)

// DomainEvent represents the base interface for all domain events
type DomainEvent interface {
        // GetID returns the unique identifier of the event
        GetID() uuid.UUID

        // GetType returns the type of the event
        GetType() EventType

        // GetVersion returns the schema version of the event
        GetVersion() EventVersion

        // GetAggregateID returns the ID of the aggregate that generated this event
        GetAggregateID() uuid.UUID

        // GetAggregateType returns the type of the aggregate
        GetAggregateType() string

        // GetOccurredAt returns when the event occurred
        GetOccurredAt() time.Time

        // GetSequenceNumber returns the sequence number of this event for the aggregate
        GetSequenceNumber() int64

        // GetCorrelationID returns the correlation ID for tracing
        GetCorrelationID() string

        // GetCausationID returns the ID of the event that caused this event
        GetCausationID() string

        // GetMetadata returns additional metadata
        GetMetadata() map[string]interface{}

        // GetPayload returns the event payload
        GetPayload() interface{}

        // Validate validates the event
        Validate() error

        // Serialize serializes the event to JSON
        Serialize() ([]byte, error)

        // IsReplayable returns true if the event can be replayed
        IsReplayable() bool
}

// BaseEvent provides common functionality for all domain events
type BaseEvent struct {
        ID             uuid.UUID              `json:"id"`
        Type           EventType              `json:"type"`
        Version        EventVersion           `json:"version"`
        AggregateID    uuid.UUID              `json:"aggregate_id"`
        AggregateType  string                 `json:"aggregate_type"`
        OccurredAt     time.Time              `json:"occurred_at"`
        SequenceNumber int64                  `json:"sequence_number"`
        CorrelationID  string                 `json:"correlation_id,omitempty"`
        CausationID    string                 `json:"causation_id,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
        Payload        interface{}            `json:"payload"`
        IsReplay       bool                   `json:"is_replay"`
}

// GetID returns the unique identifier of the event
func (e *BaseEvent) GetID() uuid.UUID <span class="cov6" title="5">{
        return e.ID
}</span>

// GetType returns the type of the event
func (e *BaseEvent) GetType() EventType <span class="cov8" title="9">{
        return e.Type
}</span>

// GetVersion returns the schema version of the event
func (e *BaseEvent) GetVersion() EventVersion <span class="cov3" title="2">{
        return e.Version
}</span>

// GetAggregateID returns the ID of the aggregate that generated this event
func (e *BaseEvent) GetAggregateID() uuid.UUID <span class="cov5" title="4">{
        return e.AggregateID
}</span>

// GetAggregateType returns the type of the aggregate
func (e *BaseEvent) GetAggregateType() string <span class="cov7" title="6">{
        return e.AggregateType
}</span>

// GetOccurredAt returns when the event occurred
func (e *BaseEvent) GetOccurredAt() time.Time <span class="cov5" title="4">{
        return e.OccurredAt
}</span>

// GetSequenceNumber returns the sequence number of this event for the aggregate
func (e *BaseEvent) GetSequenceNumber() int64 <span class="cov5" title="4">{
        return e.SequenceNumber
}</span>

// GetCorrelationID returns the correlation ID for tracing
func (e *BaseEvent) GetCorrelationID() string <span class="cov5" title="4">{
        return e.CorrelationID
}</span>

// GetCausationID returns the ID of the event that caused this event
func (e *BaseEvent) GetCausationID() string <span class="cov4" title="3">{
        return e.CausationID
}</span>

// GetMetadata returns additional metadata
func (e *BaseEvent) GetMetadata() map[string]interface{} <span class="cov4" title="3">{
        return e.Metadata
}</span>

// GetPayload returns the event payload
func (e *BaseEvent) GetPayload() interface{} <span class="cov1" title="1">{
        return e.Payload
}</span>

// Validate validates the base event
func (e *BaseEvent) Validate() error <span class="cov10" title="13">{
        if e.ID == uuid.Nil </span><span class="cov1" title="1">{
                return fmt.Errorf("event ID cannot be nil")
        }</span>
        <span class="cov9" title="12">if e.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("event type cannot be empty")
        }</span>
        <span class="cov9" title="11">if e.Version == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("event version cannot be empty")
        }</span>
        <span class="cov9" title="10">if e.AggregateID == uuid.Nil </span><span class="cov1" title="1">{
                return fmt.Errorf("aggregate ID cannot be nil")
        }</span>
        <span class="cov8" title="9">if e.AggregateType == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("aggregate type cannot be empty")
        }</span>
        <span class="cov8" title="8">if e.OccurredAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("occurred at cannot be zero")
        }</span>
        <span class="cov7" title="7">if e.SequenceNumber &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("sequence number must be positive")
        }</span>
        <span class="cov7" title="6">return nil</span>
}

// Serialize serializes the event to JSON
func (e *BaseEvent) Serialize() ([]byte, error) <span class="cov1" title="1">{
        return json.Marshal(e)
}</span>

// IsReplayable returns true if the event can be replayed
func (e *BaseEvent) IsReplayable() bool <span class="cov1" title="1">{
        return e.IsReplay
}</span>

// File Processing Events

// FileProcessingStartedEventPayload represents the payload for file processing started event
type FileProcessingStartedEventPayload struct {
        JobID            uuid.UUID              `json:"job_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        ProviderName     string                 `json:"provider_name"`
        FileURL          string                 `json:"file_url"`
        FileName         string                 `json:"file_name"`
        FileSize         int64                  `json:"file_size"`
        EstimatedRecords int64                  `json:"estimated_records"`
        ProcessingConfig map[string]interface{} `json:"processing_config"`
        StartedBy        string                 `json:"started_by"`
        Priority         int                    `json:"priority"`
        TimeoutAt        time.Time              `json:"timeout_at"`
}

// FileProcessingStartedEvent represents a file processing started event
type FileProcessingStartedEvent struct {
        BaseEvent
        JobID            uuid.UUID              `json:"job_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        ProviderName     string                 `json:"provider_name"`
        FileURL          string                 `json:"file_url"`
        FileName         string                 `json:"file_name"`
        FileSize         int64                  `json:"file_size"`
        EstimatedRecords int64                  `json:"estimated_records"`
        ProcessingConfig map[string]interface{} `json:"processing_config"`
        StartedBy        string                 `json:"started_by"`
        Priority         int                    `json:"priority"`
        TimeoutAt        time.Time              `json:"timeout_at"`
}

// NewFileProcessingStartedEvent creates a new file processing started event
func NewFileProcessingStartedEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *FileProcessingStartedEventPayload,
        correlationID string,
) *FileProcessingStartedEvent <span class="cov9" title="11">{
        return &amp;FileProcessingStartedEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           FileProcessingStartedEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "FileProcessingJob",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                JobID:            payload.JobID,
                ProviderID:       payload.ProviderID,
                ProviderName:     payload.ProviderName,
                FileURL:          payload.FileURL,
                FileName:         payload.FileName,
                FileSize:         payload.FileSize,
                EstimatedRecords: payload.EstimatedRecords,
                ProcessingConfig: payload.ProcessingConfig,
                StartedBy:        payload.StartedBy,
                Priority:         payload.Priority,
                TimeoutAt:        payload.TimeoutAt,
        }
}</span>

// Validate validates the file processing started event
func (e *FileProcessingStartedEvent) Validate() error <span class="cov6" title="5">{
        if err := e.BaseEvent.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="5">if e.JobID == uuid.Nil </span><span class="cov1" title="1">{
                return fmt.Errorf("job ID cannot be nil")
        }</span>
        <span class="cov5" title="4">if e.ProviderID == uuid.Nil </span><span class="cov1" title="1">{
                return fmt.Errorf("provider ID cannot be nil")
        }</span>
        <span class="cov4" title="3">if e.FileURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("file URL cannot be empty")
        }</span>
        <span class="cov3" title="2">if e.FileSize &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("file size cannot be negative")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// FileProcessingProgressEventPayload represents the payload for file processing progress event
type FileProcessingProgressEventPayload struct {
        JobID            uuid.UUID `json:"job_id"`
        RecordsProcessed int64     `json:"records_processed"`
        RecordsTotal     int64     `json:"records_total"`
        RecordsFailed    int64     `json:"records_failed"`
        RecordsSkipped   int64     `json:"records_skipped"`
        CurrentBatch     int       `json:"current_batch"`
        TotalBatches     int       `json:"total_batches"`
        ProcessingRate   float64   `json:"processing_rate"`
        EstimatedETA     time.Time `json:"estimated_eta"`
        LastProcessedAt  time.Time `json:"last_processed_at"`
}

// FileProcessingProgressEvent represents a file processing progress event
type FileProcessingProgressEvent struct {
        BaseEvent
        JobID            uuid.UUID `json:"job_id"`
        RecordsProcessed int64     `json:"records_processed"`
        RecordsTotal     int64     `json:"records_total"`
        RecordsFailed    int64     `json:"records_failed"`
        RecordsSkipped   int64     `json:"records_skipped"`
        CurrentBatch     int       `json:"current_batch"`
        TotalBatches     int       `json:"total_batches"`
        ProcessingRate   float64   `json:"processing_rate"`
        EstimatedETA     time.Time `json:"estimated_eta"`
        LastProcessedAt  time.Time `json:"last_processed_at"`
}

// NewFileProcessingProgressEvent creates a new file processing progress event
func NewFileProcessingProgressEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *FileProcessingProgressEventPayload,
        correlationID string,
) *FileProcessingProgressEvent <span class="cov4" title="3">{
        return &amp;FileProcessingProgressEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           FileProcessingProgressEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "FileProcessingJob",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                JobID:            payload.JobID,
                RecordsProcessed: payload.RecordsProcessed,
                RecordsTotal:     payload.RecordsTotal,
                RecordsFailed:    payload.RecordsFailed,
                RecordsSkipped:   payload.RecordsSkipped,
                CurrentBatch:     payload.CurrentBatch,
                TotalBatches:     payload.TotalBatches,
                ProcessingRate:   payload.ProcessingRate,
                EstimatedETA:     payload.EstimatedETA,
                LastProcessedAt:  payload.LastProcessedAt,
        }
}</span>

// FileProcessingCompletedEventPayload represents the payload for file processing completed event
type FileProcessingCompletedEventPayload struct {
        JobID              uuid.UUID              `json:"job_id"`
        RecordsProcessed   int64                  `json:"records_processed"`
        RecordsTotal       int64                  `json:"records_total"`
        RecordsFailed      int64                  `json:"records_failed"`
        RecordsSkipped     int64                  `json:"records_skipped"`
        ProcessingDuration time.Duration          `json:"processing_duration"`
        ProcessingRate     float64                `json:"processing_rate"`
        CompletedAt        time.Time              `json:"completed_at"`
        Summary            map[string]interface{} `json:"summary"`
        Metrics            map[string]interface{} `json:"metrics"`
}

// FileProcessingCompletedEvent represents a file processing completed event
type FileProcessingCompletedEvent struct {
        BaseEvent
        JobID              uuid.UUID              `json:"job_id"`
        RecordsProcessed   int64                  `json:"records_processed"`
        RecordsTotal       int64                  `json:"records_total"`
        RecordsFailed      int64                  `json:"records_failed"`
        RecordsSkipped     int64                  `json:"records_skipped"`
        ProcessingDuration time.Duration          `json:"processing_duration"`
        ProcessingRate     float64                `json:"processing_rate"`
        CompletedAt        time.Time              `json:"completed_at"`
        Summary            map[string]interface{} `json:"summary"`
        Metrics            map[string]interface{} `json:"metrics"`
}

// NewFileProcessingCompletedEvent creates a new file processing completed event
func NewFileProcessingCompletedEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *FileProcessingCompletedEventPayload,
        correlationID string,
) *FileProcessingCompletedEvent <span class="cov1" title="1">{
        return &amp;FileProcessingCompletedEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           FileProcessingCompletedEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "FileProcessingJob",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                JobID:              payload.JobID,
                RecordsProcessed:   payload.RecordsProcessed,
                RecordsTotal:       payload.RecordsTotal,
                RecordsFailed:      payload.RecordsFailed,
                RecordsSkipped:     payload.RecordsSkipped,
                ProcessingDuration: payload.ProcessingDuration,
                ProcessingRate:     payload.ProcessingRate,
                CompletedAt:        payload.CompletedAt,
                Summary:            payload.Summary,
                Metrics:            payload.Metrics,
        }
}</span>

// FileProcessingFailedEventPayload represents the payload for file processing failed event
type FileProcessingFailedEventPayload struct {
        JobID              uuid.UUID              `json:"job_id"`
        ErrorMessage       string                 `json:"error_message"`
        ErrorCode          string                 `json:"error_code"`
        ErrorType          string                 `json:"error_type"`
        RecordsProcessed   int64                  `json:"records_processed"`
        RecordsTotal       int64                  `json:"records_total"`
        ProcessingDuration time.Duration          `json:"processing_duration"`
        FailedAt           time.Time              `json:"failed_at"`
        RetryCount         int                    `json:"retry_count"`
        MaxRetries         int                    `json:"max_retries"`
        IsRetryable        bool                   `json:"is_retryable"`
        StackTrace         string                 `json:"stack_trace,omitempty"`
        Context            map[string]interface{} `json:"context,omitempty"`
}

// FileProcessingFailedEvent represents a file processing failed event
type FileProcessingFailedEvent struct {
        BaseEvent
        JobID              uuid.UUID              `json:"job_id"`
        ErrorMessage       string                 `json:"error_message"`
        ErrorCode          string                 `json:"error_code"`
        ErrorType          string                 `json:"error_type"`
        RecordsProcessed   int64                  `json:"records_processed"`
        RecordsTotal       int64                  `json:"records_total"`
        ProcessingDuration time.Duration          `json:"processing_duration"`
        FailedAt           time.Time              `json:"failed_at"`
        RetryCount         int                    `json:"retry_count"`
        MaxRetries         int                    `json:"max_retries"`
        IsRetryable        bool                   `json:"is_retryable"`
        StackTrace         string                 `json:"stack_trace,omitempty"`
        Context            map[string]interface{} `json:"context,omitempty"`
}

// NewFileProcessingFailedEvent creates a new file processing failed event
func NewFileProcessingFailedEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *FileProcessingFailedEventPayload,
        correlationID string,
) *FileProcessingFailedEvent <span class="cov1" title="1">{
        return &amp;FileProcessingFailedEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           FileProcessingFailedEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "FileProcessingJob",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                JobID:              payload.JobID,
                ErrorMessage:       payload.ErrorMessage,
                ErrorCode:          payload.ErrorCode,
                ErrorType:          payload.ErrorType,
                RecordsProcessed:   payload.RecordsProcessed,
                RecordsTotal:       payload.RecordsTotal,
                ProcessingDuration: payload.ProcessingDuration,
                FailedAt:           payload.FailedAt,
                RetryCount:         payload.RetryCount,
                MaxRetries:         payload.MaxRetries,
                IsRetryable:        payload.IsRetryable,
                StackTrace:         payload.StackTrace,
                Context:            payload.Context,
        }
}</span>

// Review Processing Events

// ReviewProcessedEventPayload represents the payload for review processed event
type ReviewProcessedEventPayload struct {
        ReviewID         uuid.UUID              `json:"review_id"`
        HotelID          uuid.UUID              `json:"hotel_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        ExternalID       string                 `json:"external_id"`
        ProcessingJobID  uuid.UUID              `json:"processing_job_id"`
        BatchID          string                 `json:"batch_id"`
        Rating           float64                `json:"rating"`
        Sentiment        string                 `json:"sentiment"`
        Language         string                 `json:"language"`
        WordCount        int                    `json:"word_count"`
        ProcessingStages []string               `json:"processing_stages"`
        ValidationResult map[string]interface{} `json:"validation_result"`
        EnrichmentData   map[string]interface{} `json:"enrichment_data"`
        ProcessedAt      time.Time              `json:"processed_at"`
}

// ReviewProcessedEvent represents a review processed event
type ReviewProcessedEvent struct {
        BaseEvent
        ReviewID         uuid.UUID              `json:"review_id"`
        HotelID          uuid.UUID              `json:"hotel_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        ExternalID       string                 `json:"external_id"`
        ProcessingJobID  uuid.UUID              `json:"processing_job_id"`
        BatchID          string                 `json:"batch_id"`
        Rating           float64                `json:"rating"`
        Sentiment        string                 `json:"sentiment"`
        Language         string                 `json:"language"`
        WordCount        int                    `json:"word_count"`
        ProcessingStages []string               `json:"processing_stages"`
        ValidationResult map[string]interface{} `json:"validation_result"`
        EnrichmentData   map[string]interface{} `json:"enrichment_data"`
        ProcessedAt      time.Time              `json:"processed_at"`
}

// NewReviewProcessedEvent creates a new review processed event
func NewReviewProcessedEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *ReviewProcessedEventPayload,
        correlationID string,
) *ReviewProcessedEvent <span class="cov3" title="2">{
        return &amp;ReviewProcessedEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           ReviewProcessedEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "Review",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                ReviewID:         payload.ReviewID,
                HotelID:          payload.HotelID,
                ProviderID:       payload.ProviderID,
                ExternalID:       payload.ExternalID,
                ProcessingJobID:  payload.ProcessingJobID,
                BatchID:          payload.BatchID,
                Rating:           payload.Rating,
                Sentiment:        payload.Sentiment,
                Language:         payload.Language,
                WordCount:        payload.WordCount,
                ProcessingStages: payload.ProcessingStages,
                ValidationResult: payload.ValidationResult,
                EnrichmentData:   payload.EnrichmentData,
                ProcessedAt:      payload.ProcessedAt,
        }
}</span>

// ReviewBatchProcessedEventPayload represents the payload for review batch processed event
type ReviewBatchProcessedEventPayload struct {
        BatchID          string                 `json:"batch_id"`
        ProcessingJobID  uuid.UUID              `json:"processing_job_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        BatchSize        int                    `json:"batch_size"`
        ReviewsProcessed int                    `json:"reviews_processed"`
        ReviewsFailed    int                    `json:"reviews_failed"`
        ProcessingTime   time.Duration          `json:"processing_time"`
        HotelStats       map[uuid.UUID]int      `json:"hotel_stats"`
        ValidationStats  map[string]int         `json:"validation_stats"`
        EnrichmentStats  map[string]int         `json:"enrichment_stats"`
        ProcessedAt      time.Time              `json:"processed_at"`
        Summary          map[string]interface{} `json:"summary"`
}

// ReviewBatchProcessedEvent represents a review batch processed event
type ReviewBatchProcessedEvent struct {
        BaseEvent
        BatchID          string                 `json:"batch_id"`
        ProcessingJobID  uuid.UUID              `json:"processing_job_id"`
        ProviderID       uuid.UUID              `json:"provider_id"`
        BatchSize        int                    `json:"batch_size"`
        ReviewsProcessed int                    `json:"reviews_processed"`
        ReviewsFailed    int                    `json:"reviews_failed"`
        ProcessingTime   time.Duration          `json:"processing_time"`
        HotelStats       map[uuid.UUID]int      `json:"hotel_stats"`
        ValidationStats  map[string]int         `json:"validation_stats"`
        EnrichmentStats  map[string]int         `json:"enrichment_stats"`
        ProcessedAt      time.Time              `json:"processed_at"`
        Summary          map[string]interface{} `json:"summary"`
}

// NewReviewBatchProcessedEvent creates a new review batch processed event
func NewReviewBatchProcessedEvent(
        aggregateID uuid.UUID,
        sequenceNumber int64,
        payload *ReviewBatchProcessedEventPayload,
        correlationID string,
) *ReviewBatchProcessedEvent <span class="cov1" title="1">{
        return &amp;ReviewBatchProcessedEvent{
                BaseEvent: BaseEvent{
                        ID:             uuid.New(),
                        Type:           ReviewBatchProcessedEventType,
                        Version:        EventVersionV1,
                        AggregateID:    aggregateID,
                        AggregateType:  "ReviewBatch",
                        OccurredAt:     time.Now(),
                        SequenceNumber: sequenceNumber,
                        CorrelationID:  correlationID,
                        Metadata:       make(map[string]interface{}),
                        Payload:        payload,
                },
                BatchID:          payload.BatchID,
                ProcessingJobID:  payload.ProcessingJobID,
                ProviderID:       payload.ProviderID,
                BatchSize:        payload.BatchSize,
                ReviewsProcessed: payload.ReviewsProcessed,
                ReviewsFailed:    payload.ReviewsFailed,
                ProcessingTime:   payload.ProcessingTime,
                HotelStats:       payload.HotelStats,
                ValidationStats:  payload.ValidationStats,
                EnrichmentStats:  payload.EnrichmentStats,
                ProcessedAt:      payload.ProcessedAt,
                Summary:          payload.Summary,
        }
}</span>

// Event Sourcing Support

// EventStore represents the interface for event storage
type EventStore interface {
        // AppendEvents appends events to the store
        AppendEvents(ctx context.Context, aggregateID uuid.UUID, expectedVersion int64, events []DomainEvent) error

        // GetEvents retrieves events for an aggregate
        GetEvents(ctx context.Context, aggregateID uuid.UUID, fromVersion int64) ([]DomainEvent, error)

        // GetEventsWithSnapshots retrieves events with snapshots
        GetEventsWithSnapshots(ctx context.Context, aggregateID uuid.UUID, fromVersion int64) ([]DomainEvent, *Snapshot, error)

        // GetEventsByType retrieves events by type
        GetEventsByType(ctx context.Context, eventType EventType, fromTime time.Time, limit int) ([]DomainEvent, error)

        // GetEventsByCorrelationID retrieves events by correlation ID
        GetEventsByCorrelationID(ctx context.Context, correlationID string) ([]DomainEvent, error)

        // SaveSnapshot saves a snapshot
        SaveSnapshot(ctx context.Context, snapshot *Snapshot) error

        // GetSnapshot gets the latest snapshot for an aggregate
        GetSnapshot(ctx context.Context, aggregateID uuid.UUID) (*Snapshot, error)

        // GetAllEvents retrieves all events with pagination
        GetAllEvents(ctx context.Context, offset, limit int) ([]DomainEvent, error)

        // GetEventsCount returns the total count of events
        GetEventsCount(ctx context.Context) (int64, error)

        // DeleteEvents deletes events (for testing/cleanup)
        DeleteEvents(ctx context.Context, aggregateID uuid.UUID) error
}

// Snapshot represents a snapshot of an aggregate state
type Snapshot struct {
        AggregateID   uuid.UUID              `json:"aggregate_id"`
        AggregateType string                 `json:"aggregate_type"`
        Version       int64                  `json:"version"`
        Data          map[string]interface{} `json:"data"`
        CreatedAt     time.Time              `json:"created_at"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// EventHandler represents the interface for handling events
type EventHandler interface {
        // HandleEvent handles a single event
        HandleEvent(ctx context.Context, event DomainEvent) error

        // CanHandle returns true if the handler can handle the event type
        CanHandle(eventType EventType) bool

        // GetHandledEventTypes returns the event types this handler can handle
        GetHandledEventTypes() []EventType
}

// EventBus represents the interface for event bus operations
type EventBus interface {
        // Subscribe subscribes a handler to event types
        Subscribe(handler EventHandler, eventTypes ...EventType) error

        // Unsubscribe unsubscribes a handler from event types
        Unsubscribe(handler EventHandler, eventTypes ...EventType) error

        // PublishEvent publishes an event to all subscribers
        PublishEvent(ctx context.Context, event DomainEvent) error

        // PublishEvents publishes multiple events to all subscribers
        PublishEvents(ctx context.Context, events []DomainEvent) error

        // Start starts the event bus
        Start(ctx context.Context) error

        // Stop stops the event bus
        Stop() error
}

// AggregateRoot represents the base interface for aggregate roots
type AggregateRoot interface {
        // GetID returns the aggregate ID
        GetID() uuid.UUID

        // GetVersion returns the current version
        GetVersion() int64

        // GetUncommittedEvents returns uncommitted events
        GetUncommittedEvents() []DomainEvent

        // ClearUncommittedEvents clears uncommitted events
        ClearUncommittedEvents()

        // LoadFromHistory loads the aggregate from historical events
        LoadFromHistory(events []DomainEvent) error

        // ApplyEvent applies an event to the aggregate
        ApplyEvent(event DomainEvent) error

        // GetType returns the aggregate type
        GetType() string
}

// EventMigrator represents the interface for event migrations
type EventMigrator interface {
        // MigrateEvent migrates an event from one version to another
        MigrateEvent(event DomainEvent, targetVersion EventVersion) (DomainEvent, error)

        // CanMigrate returns true if the migrator can migrate the event
        CanMigrate(fromVersion, toVersion EventVersion) bool

        // GetSupportedVersions returns the supported versions
        GetSupportedVersions() []EventVersion
}

// EventSerializer represents the interface for event serialization
type EventSerializer interface {
        // Serialize serializes an event to bytes
        Serialize(event DomainEvent) ([]byte, error)

        // Deserialize deserializes bytes to an event
        Deserialize(data []byte, eventType EventType, version EventVersion) (DomainEvent, error)

        // GetSupportedVersions returns the supported versions
        GetSupportedVersions() []EventVersion
}

// EventRegistry represents the interface for event type registration
type EventRegistry interface {
        // RegisterEventType registers an event type
        RegisterEventType(eventType EventType, factory EventFactory) error

        // GetEventFactory returns the factory for an event type
        GetEventFactory(eventType EventType) (EventFactory, error)

        // GetRegisteredEventTypes returns all registered event types
        GetRegisteredEventTypes() []EventType

        // IsRegistered returns true if the event type is registered
        IsRegistered(eventType EventType) bool
}

// EventFactory represents the interface for creating events
type EventFactory interface {
        // CreateEvent creates a new event instance
        CreateEvent() DomainEvent

        // CreateEventFromPayload creates an event from payload
        CreateEventFromPayload(payload interface{}) (DomainEvent, error)

        // GetEventType returns the event type this factory creates
        GetEventType() EventType

        // GetSupportedVersions returns the supported versions
        GetSupportedVersions() []EventVersion
}

// EventProjector represents the interface for event projections
type EventProjector interface {
        // Project projects an event to update read models
        Project(ctx context.Context, event DomainEvent) error

        // CanProject returns true if the projector can project the event
        CanProject(eventType EventType) bool

        // GetProjectedEventTypes returns the event types this projector handles
        GetProjectedEventTypes() []EventType

        // Reset resets the projection
        Reset(ctx context.Context) error
}

// EventReplayService represents the interface for event replay
type EventReplayService interface {
        // ReplayEvents replays events from a specific point in time
        ReplayEvents(ctx context.Context, fromTime time.Time, toTime time.Time) error

        // ReplayEventsForAggregate replays events for a specific aggregate
        ReplayEventsForAggregate(ctx context.Context, aggregateID uuid.UUID, fromVersion int64) error

        // ReplayEventsByType replays events of a specific type
        ReplayEventsByType(ctx context.Context, eventType EventType, fromTime time.Time) error

        // GetReplayStatus returns the current replay status
        GetReplayStatus(ctx context.Context) (*ReplayStatus, error)
}

// ReplayStatus represents the status of event replay
type ReplayStatus struct {
        IsRunning      bool      `json:"is_running"`
        StartTime      time.Time `json:"start_time"`
        EndTime        time.Time `json:"end_time"`
        EventsReplayed int64     `json:"events_replayed"`
        TotalEvents    int64     `json:"total_events"`
        LastEventID    uuid.UUID `json:"last_event_id"`
        Progress       float64   `json:"progress"`
        Error          string    `json:"error,omitempty"`
}

// EventMetrics represents event-related metrics
type EventMetrics struct {
        TotalEvents      int64                  `json:"total_events"`
        EventsByType     map[EventType]int64    `json:"events_by_type"`
        EventsByVersion  map[EventVersion]int64 `json:"events_by_version"`
        EventsPerSecond  float64                `json:"events_per_second"`
        LastEventTime    time.Time              `json:"last_event_time"`
        AggregateCount   int64                  `json:"aggregate_count"`
        SnapshotCount    int64                  `json:"snapshot_count"`
        ReplayCount      int64                  `json:"replay_count"`
        PublishFailures  int64                  `json:"publish_failures"`
        HandlingFailures int64                  `json:"handling_failures"`
}

// EventHealthChecker represents the interface for event system health checks
type EventHealthChecker interface {
        // CheckHealth checks the health of the event system
        CheckHealth(ctx context.Context) (*EventHealthStatus, error)

        // CheckEventStore checks the health of the event store
        CheckEventStore(ctx context.Context) error

        // CheckEventBus checks the health of the event bus
        CheckEventBus(ctx context.Context) error

        // CheckEventPublisher checks the health of the event publisher
        CheckEventPublisher(ctx context.Context) error

        // GetMetrics returns event system metrics
        GetMetrics(ctx context.Context) (*EventMetrics, error)
}

// EventHealthStatus represents the health status of the event system
type EventHealthStatus struct {
        IsHealthy       bool                   `json:"is_healthy"`
        EventStore      string                 `json:"event_store"`
        EventBus        string                 `json:"event_bus"`
        EventPublisher  string                 `json:"event_publisher"`
        LastCheck       time.Time              `json:"last_check"`
        Metrics         *EventMetrics          `json:"metrics,omitempty"`
        Issues          []string               `json:"issues,omitempty"`
        ComponentStatus map[string]interface{} `json:"component_status,omitempty"`
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package domain

import (
        "context"
        "log/slog"
        "os"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
        "github.com/google/uuid"
)

// NewReviewServiceWithAdapter creates a new ReviewService instance with logger adapter
func NewReviewServiceWithAdapter(
        reviewRepo ReviewRepository,
        s3Client S3Client,
        jsonProcessor JSONProcessor,
        cacheService CacheService,
        eventPublisher EventPublisher,
        logger *logger.Logger,
) ReviewService <span class="cov0" title="0">{
        // Create a simple slog adapter
        slogger := slog.New(slog.NewTextHandler(os.Stdout, nil))

        // Create a stub notification service for now
        notificationService := &amp;stubNotificationService{}

        // Create a stub metrics service for now
        metricsService := &amp;stubMetricsService{}

        return NewReviewServiceWithDeps(
                reviewRepo,
                s3Client,
                jsonProcessor,
                notificationService,
                cacheService,
                metricsService,
                eventPublisher,
                slogger,
        )
}</span>

// NewReviewServiceWithDeps creates a new ReviewService with all dependencies
func NewReviewServiceWithDeps(
        reviewRepo ReviewRepository,
        s3Client S3Client,
        jsonProcessor JSONProcessor,
        notificationService NotificationService,
        cacheService CacheService,
        metricsService MetricsService,
        eventPublisher EventPublisher,
        logger *slog.Logger,
) ReviewService <span class="cov0" title="0">{
        return &amp;ReviewServiceImpl{
                reviewRepo:          reviewRepo,
                s3Client:            s3Client,
                jsonProcessor:       jsonProcessor,
                notificationService: notificationService,
                cacheService:        cacheService,
                metricsService:      metricsService,
                eventPublisher:      eventPublisher,
                logger:              logger,
        }
}</span>

// Stub implementations for missing services

type stubNotificationService struct{}

func (s *stubNotificationService) SendProcessingComplete(ctx context.Context, processingID uuid.UUID, status string, recordsProcessed int) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubNotificationService) SendProcessingFailed(ctx context.Context, processingID uuid.UUID, errorMsg string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubNotificationService) SendSystemAlert(ctx context.Context, message string, severity string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubNotificationService) SendEmailNotification(ctx context.Context, to []string, subject, body string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubNotificationService) SendSlackNotification(ctx context.Context, channel, message string) error <span class="cov0" title="0">{
        return nil
}</span>

type stubMetricsService struct{}

func (s *stubMetricsService) IncrementCounter(ctx context.Context, name string, labels map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordHistogram(ctx context.Context, name string, value float64, labels map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordGauge(ctx context.Context, name string, value float64, labels map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordProcessingTime(ctx context.Context, processingID uuid.UUID, duration time.Duration) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordProcessingCount(ctx context.Context, providerID uuid.UUID, count int) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordErrorCount(ctx context.Context, errorType string, count int) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *stubMetricsService) RecordAPIRequestCount(ctx context.Context, endpoint string, method string, statusCode int) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package domain

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/google/uuid"
)

// ReviewServiceImpl implements the ReviewService interface
type ReviewServiceImpl struct {
        reviewRepo          ReviewRepository
        s3Client            S3Client
        jsonProcessor       JSONProcessor
        notificationService NotificationService
        cacheService        CacheService
        metricsService      MetricsService
        eventPublisher      EventPublisher
        logger              *slog.Logger
}

// NewReviewService creates a new ReviewService instance
func NewReviewService(
        reviewRepo ReviewRepository,
        s3Client S3Client,
        jsonProcessor JSONProcessor,
        notificationService NotificationService,
        cacheService CacheService,
        metricsService MetricsService,
        eventPublisher EventPublisher,
        logger *slog.Logger,
) ReviewService <span class="cov6" title="74">{
        return &amp;ReviewServiceImpl{
                reviewRepo:          reviewRepo,
                s3Client:            s3Client,
                jsonProcessor:       jsonProcessor,
                notificationService: notificationService,
                cacheService:        cacheService,
                metricsService:      metricsService,
                eventPublisher:      eventPublisher,
                logger:              logger,
        }
}</span>

// Review operations
func (s *ReviewServiceImpl) CreateReview(ctx context.Context, review *Review) error <span class="cov3" title="8">{
        if err := s.ValidateReviewData(ctx, review); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov3" title="7">if err := s.EnrichReviewData(ctx, review); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to enrich review data", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov3" title="7">if err := s.reviewRepo.CreateBatch(ctx, []Review{*review}); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        <span class="cov3" title="6">if err := s.eventPublisher.PublishReviewCreated(ctx, review); err != nil </span><span class="cov1" title="1">{
                s.logger.Error("Failed to publish review created event", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov3" title="6">if err := s.cacheService.InvalidateReviewSummary(ctx, review.HotelID); err != nil </span><span class="cov1" title="1">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", review.HotelID)
        }</span>

        <span class="cov3" title="6">if err := s.metricsService.IncrementCounter(ctx, "reviews_created", map[string]string{
                "provider_id": review.ProviderID.String(),
                "hotel_id":    review.HotelID.String(),
        }); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to increment metrics", "error", err)
        }</span>

        <span class="cov3" title="6">return nil</span>
}

func (s *ReviewServiceImpl) GetReviewByID(ctx context.Context, id uuid.UUID) (*Review, error) <span class="cov1" title="2">{
        review, err := s.reviewRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get review: %w", err)
        }</span>
        <span class="cov1" title="1">return review, nil</span>
}

func (s *ReviewServiceImpl) GetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]Review, error) <span class="cov1" title="1">{
        reviews, err := s.reviewRepo.GetByHotel(ctx, hotelID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>
        <span class="cov1" title="1">return reviews, nil</span>
}

func (s *ReviewServiceImpl) GetReviewsByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]Review, error) <span class="cov1" title="1">{
        reviews, err := s.reviewRepo.GetByProvider(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by provider: %w", err)
        }</span>
        <span class="cov1" title="1">return reviews, nil</span>
}

func (s *ReviewServiceImpl) UpdateReview(ctx context.Context, review *Review) error <span class="cov3" title="6">{
        if err := s.ValidateReviewData(ctx, review); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov3" title="6">existingReview, err := s.reviewRepo.GetByID(ctx, review.ID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get existing review: %w", err)
        }</span>

        <span class="cov3" title="5">if err := s.reviewRepo.CreateBatch(ctx, []Review{*review}); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update review: %w", err)
        }</span>

        <span class="cov2" title="4">if err := s.eventPublisher.PublishReviewUpdated(ctx, review); err != nil </span><span class="cov1" title="1">{
                s.logger.Error("Failed to publish review updated event", "error", err, "review_id", review.ID)
        }</span>

        <span class="cov2" title="4">if existingReview.HotelID != review.HotelID </span><span class="cov1" title="2">{
                if err := s.cacheService.InvalidateReviewSummary(ctx, existingReview.HotelID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to invalidate old hotel cache", "error", err, "hotel_id", existingReview.HotelID)
                }</span>
        }
        <span class="cov2" title="4">if err := s.cacheService.InvalidateReviewSummary(ctx, review.HotelID); err != nil </span><span class="cov1" title="1">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", review.HotelID)
        }</span>

        <span class="cov2" title="4">return nil</span>
}

func (s *ReviewServiceImpl) DeleteReview(ctx context.Context, id uuid.UUID) error <span class="cov2" title="3">{
        review, err := s.reviewRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get review: %w", err)
        }</span>

        <span class="cov2" title="3">if err := s.reviewRepo.DeleteByID(ctx, id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete review: %w", err)
        }</span>

        <span class="cov1" title="2">if err := s.eventPublisher.PublishReviewDeleted(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish review deleted event", "error", err, "review_id", id)
        }</span>

        <span class="cov1" title="2">if err := s.cacheService.InvalidateReviewSummary(ctx, review.HotelID); err != nil </span><span class="cov1" title="1">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", review.HotelID)
        }</span>

        <span class="cov1" title="2">return nil</span>
}

func (s *ReviewServiceImpl) SearchReviews(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]Review, error) <span class="cov1" title="1">{
        reviews, err := s.reviewRepo.Search(ctx, query, filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search reviews: %w", err)
        }</span>
        <span class="cov1" title="1">return reviews, nil</span>
}

// Hotel operations
func (s *ReviewServiceImpl) CreateHotel(ctx context.Context, hotel *Hotel) error <span class="cov1" title="2">{
        if err := s.validateHotel(ctx, hotel); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.reviewRepo.CreateHotel(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create hotel: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.eventPublisher.PublishHotelCreated(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish hotel created event", "error", err, "hotel_id", hotel.ID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) GetHotelByID(ctx context.Context, id uuid.UUID) (*Hotel, error) <span class="cov1" title="1">{
        hotel, err := s.reviewRepo.GetHotelByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get hotel: %w", err)
        }</span>
        <span class="cov1" title="1">return hotel, nil</span>
}

func (s *ReviewServiceImpl) UpdateHotel(ctx context.Context, hotel *Hotel) error <span class="cov2" title="3">{
        if err := s.validateHotel(ctx, hotel); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov1" title="2">if err := s.reviewRepo.UpdateHotel(ctx, hotel); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update hotel: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.eventPublisher.PublishHotelUpdated(ctx, hotel); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish hotel updated event", "error", err, "hotel_id", hotel.ID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) DeleteHotel(ctx context.Context, id uuid.UUID) error <span class="cov1" title="2">{
        if err := s.reviewRepo.DeleteHotel(ctx, id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete hotel: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.cacheService.InvalidateReviewSummary(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to invalidate review summary cache", "error", err, "hotel_id", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) ListHotels(ctx context.Context, limit, offset int) ([]Hotel, error) <span class="cov1" title="1">{
        hotels, err := s.reviewRepo.ListHotels(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list hotels: %w", err)
        }</span>
        <span class="cov1" title="1">return hotels, nil</span>
}

// Provider operations
func (s *ReviewServiceImpl) CreateProvider(ctx context.Context, provider *Provider) error <span class="cov1" title="1">{
        if err := s.validateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.reviewRepo.CreateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create provider: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) GetProviderByID(ctx context.Context, id uuid.UUID) (*Provider, error) <span class="cov1" title="1">{
        provider, err := s.reviewRepo.GetProviderByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider: %w", err)
        }</span>
        <span class="cov1" title="1">return provider, nil</span>
}

func (s *ReviewServiceImpl) GetProviderByName(ctx context.Context, name string) (*Provider, error) <span class="cov1" title="1">{
        provider, err := s.reviewRepo.GetProviderByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider by name: %w", err)
        }</span>
        <span class="cov1" title="1">return provider, nil</span>
}

func (s *ReviewServiceImpl) UpdateProvider(ctx context.Context, provider *Provider) error <span class="cov1" title="2">{
        if err := s.validateProvider(ctx, provider); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.reviewRepo.UpdateProvider(ctx, provider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update provider: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) DeleteProvider(ctx context.Context, id uuid.UUID) error <span class="cov1" title="2">{
        if err := s.reviewRepo.DeleteProvider(ctx, id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete provider: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (s *ReviewServiceImpl) ListProviders(ctx context.Context, limit, offset int) ([]Provider, error) <span class="cov1" title="1">{
        providers, err := s.reviewRepo.ListProviders(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list providers: %w", err)
        }</span>
        <span class="cov1" title="1">return providers, nil</span>
}

// File processing operations
func (s *ReviewServiceImpl) ProcessReviewFile(ctx context.Context, fileURL string, providerID uuid.UUID) (*ReviewProcessingStatus, error) <span class="cov1" title="2">{
        processingID := uuid.New()

        processingStatus := &amp;ReviewProcessingStatus{
                ID:               processingID,
                ProviderID:       providerID,
                Status:           "pending",
                FileURL:          fileURL,
                RecordsProcessed: 0,
                RecordsTotal:     0,
        }

        if err := s.reviewRepo.CreateProcessingStatus(ctx, processingStatus); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create processing status: %w", err)
        }</span>

        <span class="cov1" title="2">go s.processFileAsync(context.Background(), processingID, fileURL, providerID)

        return processingStatus, nil</span>
}

func (s *ReviewServiceImpl) processFileAsync(ctx context.Context, processingID uuid.UUID, fileURL string, providerID uuid.UUID) <span class="cov1" title="2">{
        startTime := time.Now()

        if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "processing", 0, ""); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status", "error", err, "processing_id", processingID)
                return
        }</span>

        <span class="cov1" title="2">if err := s.eventPublisher.PublishProcessingStarted(ctx, processingID, providerID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing started event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov1" title="2">bucket, key, err := s.parseS3URL(fileURL)
        if err != nil </span><span class="cov0" title="0">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Invalid S3 URL: %v", err))
                return
        }</span>

        <span class="cov1" title="2">reader, err := s.s3Client.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov1" title="2">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Failed to download file: %v", err))
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        if err := s.jsonProcessor.ProcessFile(ctx, reader, providerID, processingID); err != nil </span><span class="cov0" title="0">{
                s.handleProcessingError(ctx, processingID, fmt.Sprintf("Failed to process file: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "completed", 0, ""); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status to completed", "error", err, "processing_id", processingID)
                return
        }</span>

        <span class="cov0" title="0">if err := s.eventPublisher.PublishProcessingCompleted(ctx, processingID, 0); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing completed event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov0" title="0">if err := s.notificationService.SendProcessingComplete(ctx, processingID, "completed", 0); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to send processing complete notification", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov0" title="0">s.metricsService.RecordProcessingTime(ctx, processingID, time.Since(startTime))</span>
}

func (s *ReviewServiceImpl) handleProcessingError(ctx context.Context, processingID uuid.UUID, errorMsg string) <span class="cov1" title="2">{
        s.logger.Error("Processing failed", "processing_id", processingID, "error", errorMsg)

        if err := s.reviewRepo.UpdateProcessingStatus(ctx, processingID, "failed", 0, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update processing status to failed", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov1" title="2">if err := s.eventPublisher.PublishProcessingFailed(ctx, processingID, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish processing failed event", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov1" title="2">if err := s.notificationService.SendProcessingFailed(ctx, processingID, errorMsg); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to send processing failed notification", "error", err, "processing_id", processingID)
        }</span>

        <span class="cov1" title="2">s.metricsService.IncrementCounter(ctx, "processing_errors", map[string]string{
                "processing_id": processingID.String(),
        })</span>
}

func (s *ReviewServiceImpl) GetProcessingStatus(ctx context.Context, id uuid.UUID) (*ReviewProcessingStatus, error) <span class="cov1" title="1">{
        status, err := s.reviewRepo.GetProcessingStatusByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing status: %w", err)
        }</span>
        <span class="cov1" title="1">return status, nil</span>
}

func (s *ReviewServiceImpl) GetProcessingHistory(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]ReviewProcessingStatus, error) <span class="cov1" title="1">{
        history, err := s.reviewRepo.GetProcessingStatusByProvider(ctx, providerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing history: %w", err)
        }</span>
        <span class="cov1" title="1">return history, nil</span>
}

func (s *ReviewServiceImpl) CancelProcessing(ctx context.Context, id uuid.UUID) error <span class="cov1" title="2">{
        if err := s.reviewRepo.UpdateProcessingStatus(ctx, id, "cancelled", 0, "Processing cancelled by user"); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to cancel processing: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Analytics operations
func (s *ReviewServiceImpl) GetReviewSummary(ctx context.Context, hotelID uuid.UUID) (*ReviewSummary, error) <span class="cov2" title="3">{
        if summary, err := s.cacheService.GetReviewSummary(ctx, hotelID); err == nil </span><span class="cov1" title="1">{
                return summary, nil
        }</span>

        <span class="cov1" title="2">summary, err := s.reviewRepo.GetReviewSummaryByHotelID(ctx, hotelID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get review summary: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.cacheService.SetReviewSummary(ctx, hotelID, summary, 1*time.Hour); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache review summary", "error", err, "hotel_id", hotelID)
        }</span>

        <span class="cov1" title="1">return summary, nil</span>
}

func (s *ReviewServiceImpl) GetReviewStatsByProvider(ctx context.Context, providerID uuid.UUID, startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov2" title="3">{
        reviews, err := s.reviewRepo.GetByDateRange(ctx, startDate, endDate, 1000, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get reviews by date range: %w", err)
        }</span>

        <span class="cov1" title="2">stats := make(map[string]interface{})
        var totalReviews int
        var totalRating float64

        for _, review := range reviews </span><span class="cov2" title="3">{
                if review.ProviderID == providerID </span><span class="cov1" title="2">{
                        totalReviews++
                        totalRating += review.Rating
                }</span>
        }

        <span class="cov1" title="2">if totalReviews &gt; 0 </span><span class="cov1" title="1">{
                stats["total_reviews"] = totalReviews
                stats["average_rating"] = totalRating / float64(totalReviews)
        }</span>

        <span class="cov1" title="2">return stats, nil</span>
}

func (s *ReviewServiceImpl) GetReviewStatsByHotel(ctx context.Context, hotelID uuid.UUID, startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov2" title="3">{
        reviews, err := s.reviewRepo.GetByHotel(ctx, hotelID, 1000, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>

        <span class="cov1" title="2">stats := make(map[string]interface{})
        var totalReviews int
        var totalRating float64

        for _, review := range reviews </span><span class="cov2" title="4">{
                if review.ReviewDate.After(startDate) &amp;&amp; review.ReviewDate.Before(endDate) </span><span class="cov1" title="2">{
                        totalReviews++
                        totalRating += review.Rating
                }</span>
        }

        <span class="cov1" title="2">if totalReviews &gt; 0 </span><span class="cov1" title="1">{
                stats["total_reviews"] = totalReviews
                stats["average_rating"] = totalRating / float64(totalReviews)
        }</span>

        <span class="cov1" title="2">return stats, nil</span>
}

func (s *ReviewServiceImpl) GetTopRatedHotels(ctx context.Context, limit int) ([]Hotel, error) <span class="cov2" title="3">{
        hotels, err := s.reviewRepo.ListHotels(ctx, limit*2, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get hotels: %w", err)
        }</span>

        <span class="cov1" title="2">if len(hotels) &lt; limit </span><span class="cov1" title="2">{
                return hotels, nil
        }</span>
        <span class="cov0" title="0">return hotels[:limit], nil</span>
}

func (s *ReviewServiceImpl) GetRecentReviews(ctx context.Context, limit int) ([]Review, error) <span class="cov1" title="2">{
        reviews, err := s.reviewRepo.GetByDateRange(ctx, time.Now().AddDate(0, 0, -30), time.Now(), limit, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get recent reviews: %w", err)
        }</span>
        <span class="cov1" title="1">return reviews, nil</span>
}

// Review validation and enrichment
func (s *ReviewServiceImpl) ValidateReviewData(ctx context.Context, review *Review) error <span class="cov10" title="1048">{
        if review.Rating &lt; 1.0 || review.Rating &gt; 5.0 </span><span class="cov3" title="7">{
                return fmt.Errorf("rating must be between 1.0 and 5.0")
        }</span>

        <span class="cov9" title="1041">if review.Comment == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("comment cannot be empty")
        }</span>

        <span class="cov9" title="1039">if review.ReviewDate.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("review date cannot be empty")
        }</span>

        <span class="cov9" title="1039">if review.ReviewDate.After(time.Now()) </span><span class="cov2" title="3">{
                return fmt.Errorf("review date cannot be in the future")
        }</span>

        <span class="cov9" title="1036">if review.ProviderID == uuid.Nil </span><span class="cov1" title="2">{
                return fmt.Errorf("provider ID cannot be empty")
        }</span>

        <span class="cov9" title="1034">if review.HotelID == uuid.Nil </span><span class="cov1" title="2">{
                return fmt.Errorf("hotel ID cannot be empty")
        }</span>

        <span class="cov9" title="1032">return nil</span>
}

func (s *ReviewServiceImpl) EnrichReviewData(ctx context.Context, review *Review) error <span class="cov4" title="16">{
        if review.Language == "" </span><span class="cov3" title="9">{
                review.Language = "en"
        }</span>

        <span class="cov4" title="16">if review.Sentiment == "" </span><span class="cov4" title="16">{
                review.Sentiment = s.detectSentiment(review.Comment)
        }</span>

        <span class="cov4" title="16">if review.ProcessingHash == "" </span><span class="cov4" title="16">{
                review.ProcessingHash = s.generateProcessingHash(review)
        }</span>

        <span class="cov4" title="16">now := time.Now()
        review.ProcessedAt = &amp;now

        return nil</span>
}

func (s *ReviewServiceImpl) DetectDuplicateReviews(ctx context.Context, review *Review) ([]Review, error) <span class="cov1" title="2">{
        filters := map[string]interface{}{
                "hotel_id":    review.HotelID,
                "provider_id": review.ProviderID,
                "rating":      review.Rating,
        }

        duplicates, err := s.reviewRepo.Search(ctx, review.Comment, filters, 10, 0)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to search for duplicates: %w", err)
        }</span>

        <span class="cov1" title="1">return duplicates, nil</span>
}

// Batch operations
func (s *ReviewServiceImpl) ProcessReviewBatch(ctx context.Context, reviews []Review) error <span class="cov3" title="5">{
        for i := range reviews </span><span class="cov3" title="7">{
                if err := s.ValidateReviewData(ctx, &amp;reviews[i]); err != nil </span><span class="cov1" title="2">{
                        return fmt.Errorf("validation failed for review %d: %w", i, err)
                }</span>

                <span class="cov3" title="5">if err := s.EnrichReviewData(ctx, &amp;reviews[i]); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to enrich review data", "error", err, "review_index", i)
                }</span>
        }

        <span class="cov2" title="3">if err := s.reviewRepo.CreateBatch(ctx, reviews); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create review batch: %w", err)
        }</span>

        <span class="cov1" title="2">for _, review := range reviews </span><span class="cov2" title="3">{
                if err := s.eventPublisher.PublishReviewCreated(ctx, &amp;review); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to publish review created event", "error", err, "review_id", review.ID)
                }</span>
        }

        <span class="cov1" title="2">return nil</span>
}

func (s *ReviewServiceImpl) ImportReviewsFromFile(ctx context.Context, fileURL string, providerID uuid.UUID) error <span class="cov1" title="1">{
        _, err := s.ProcessReviewFile(ctx, fileURL, providerID)
        return err
}</span>

func (s *ReviewServiceImpl) ExportReviewsToFile(ctx context.Context, filters map[string]interface{}, format string) (string, error) <span class="cov1" title="1">{
        return "", fmt.Errorf("export functionality not implemented yet")
}</span>

// Helper methods
func (s *ReviewServiceImpl) validateHotel(ctx context.Context, hotel *Hotel) error <span class="cov3" title="5">{
        if hotel.Name == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("hotel name cannot be empty")
        }</span>

        <span class="cov2" title="3">if hotel.StarRating &lt; 1 || hotel.StarRating &gt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("star rating must be between 1 and 5")
        }</span>

        <span class="cov2" title="3">return nil</span>
}

func (s *ReviewServiceImpl) validateProvider(ctx context.Context, provider *Provider) error <span class="cov2" title="3">{
        if provider.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("provider name cannot be empty")
        }</span>

        <span class="cov1" title="2">return nil</span>
}

func (s *ReviewServiceImpl) parseS3URL(url string) (bucket, key string, err error) <span class="cov3" title="6">{
        parts := strings.Split(strings.TrimPrefix(url, "s3://"), "/")
        if len(parts) &lt; 2 </span><span class="cov1" title="2">{
                return "", "", fmt.Errorf("invalid S3 URL format")
        }</span>
        <span class="cov2" title="4">return parts[0], strings.Join(parts[1:], "/"), nil</span>
}

func (s *ReviewServiceImpl) detectSentiment(comment string) string <span class="cov4" title="21">{
        comment = strings.ToLower(comment)

        positiveWords := []string{"good", "great", "excellent", "amazing", "wonderful", "perfect", "love", "fantastic"}
        negativeWords := []string{"bad", "terrible", "awful", "horrible", "worst", "hate", "disappointing", "poor"}

        positiveCount := 0
        negativeCount := 0

        for _, word := range positiveWords </span><span class="cov7" title="168">{
                if strings.Contains(comment, word) </span><span class="cov4" title="19">{
                        positiveCount++
                }</span>
        }

        <span class="cov4" title="21">for _, word := range negativeWords </span><span class="cov7" title="168">{
                if strings.Contains(comment, word) </span><span class="cov2" title="4">{
                        negativeCount++
                }</span>
        }

        <span class="cov4" title="21">if positiveCount &gt; negativeCount </span><span class="cov4" title="17">{
                return "positive"
        }</span> else<span class="cov2" title="4"> if negativeCount &gt; positiveCount </span><span class="cov1" title="2">{
                return "negative"
        }</span>

        <span class="cov1" title="2">return "neutral"</span>
}

func (s *ReviewServiceImpl) generateProcessingHash(review *Review) string <span class="cov4" title="17">{
        return fmt.Sprintf("%x", review.ID)[0:32] // Take first 32 characters
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
        "gopkg.in/gomail.v2"
)

// LoggerAlertChannel sends alerts to the logger
type LoggerAlertChannel struct {
        logger  *logger.Logger
        enabled bool
}

// NewLoggerAlertChannel creates a new logger alert channel
func NewLoggerAlertChannel(logger *logger.Logger) *LoggerAlertChannel <span class="cov0" title="0">{
        return &amp;LoggerAlertChannel{
                logger:  logger,
                enabled: true,
        }
}</span>

// Send sends an alert to the logger
func (lac *LoggerAlertChannel) Send(ctx context.Context, alert *Alert) error <span class="cov0" title="0">{
        if !lac.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Log based on alert level
        <span class="cov0" title="0">switch alert.Level </span>{
        case AlertLevelInfo:<span class="cov0" title="0">
                lac.logger.InfoContext(ctx, fmt.Sprintf("ALERT: %s", alert.Title),
                        "alert_id", alert.ID,
                        "alert_type", alert.Type,
                        "alert_level", alert.Level,
                        "message", alert.Message,
                        "details", alert.Details,
                )</span>
        case AlertLevelWarning:<span class="cov0" title="0">
                lac.logger.WarnContext(ctx, fmt.Sprintf("ALERT: %s", alert.Title),
                        "alert_id", alert.ID,
                        "alert_type", alert.Type,
                        "alert_level", alert.Level,
                        "message", alert.Message,
                        "details", alert.Details,
                )</span>
        case AlertLevelError, AlertLevelCritical:<span class="cov0" title="0">
                lac.logger.ErrorContext(ctx, fmt.Sprintf("ALERT: %s", alert.Title),
                        "alert_id", alert.ID,
                        "alert_type", alert.Type,
                        "alert_level", alert.Level,
                        "message", alert.Message,
                        "details", alert.Details,
                        "actions", alert.Actions,
                        "runbook", alert.Runbook,
                )</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Name returns the channel name
func (lac *LoggerAlertChannel) Name() string <span class="cov0" title="0">{
        return "logger"
}</span>

// IsEnabled returns true if the channel is enabled
func (lac *LoggerAlertChannel) IsEnabled() bool <span class="cov0" title="0">{
        return lac.enabled
}</span>

// SetEnabled sets the channel enabled state
func (lac *LoggerAlertChannel) SetEnabled(enabled bool) <span class="cov0" title="0">{
        lac.enabled = enabled
}</span>

// EmailAlertChannel sends alerts via email
type EmailAlertChannel struct {
        host     string
        port     int
        username string
        password string
        from     string
        to       []string
        enabled  bool
        logger   *logger.Logger
        dialer   *gomail.Dialer
}

// EmailConfig represents email configuration
type EmailConfig struct {
        Host     string   `json:"host"`
        Port     int      `json:"port"`
        Username string   `json:"username"`
        Password string   `json:"password"`
        From     string   `json:"from"`
        To       []string `json:"to"`
}

// NewEmailAlertChannel creates a new email alert channel
func NewEmailAlertChannel(config *EmailConfig, logger *logger.Logger) *EmailAlertChannel <span class="cov0" title="0">{
        dialer := gomail.NewDialer(config.Host, config.Port, config.Username, config.Password)

        return &amp;EmailAlertChannel{
                host:     config.Host,
                port:     config.Port,
                username: config.Username,
                password: config.Password,
                from:     config.From,
                to:       config.To,
                enabled:  true,
                logger:   logger,
                dialer:   dialer,
        }
}</span>

// Send sends an alert via email
func (eac *EmailAlertChannel) Send(ctx context.Context, alert *Alert) error <span class="cov0" title="0">{
        if !eac.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create email message
        <span class="cov0" title="0">message := gomail.NewMessage()
        message.SetHeader("From", eac.from)
        message.SetHeader("To", eac.to...)
        message.SetHeader("Subject", fmt.Sprintf("[%s] %s", strings.ToUpper(string(alert.Level)), alert.Title))

        // Create email body
        body := eac.createEmailBody(alert)
        message.SetBody("text/html", body)

        // Send email
        if err := eac.dialer.DialAndSend(message); err != nil </span><span class="cov0" title="0">{
                eac.logger.ErrorContext(ctx, "Failed to send email alert",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>

        <span class="cov0" title="0">eac.logger.InfoContext(ctx, "Email alert sent successfully",
                "alert_id", alert.ID,
                "recipients", eac.to,
        )

        return nil</span>
}

// createEmailBody creates the email body for an alert
func (eac *EmailAlertChannel) createEmailBody(alert *Alert) string <span class="cov0" title="0">{
        var body strings.Builder

        body.WriteString("&lt;html&gt;&lt;body&gt;")
        body.WriteString(fmt.Sprintf("&lt;h2&gt;Alert: %s&lt;/h2&gt;", alert.Title))
        body.WriteString(fmt.Sprintf("&lt;p&gt;&lt;strong&gt;Level:&lt;/strong&gt; %s&lt;/p&gt;", alert.Level))
        body.WriteString(fmt.Sprintf("&lt;p&gt;&lt;strong&gt;Type:&lt;/strong&gt; %s&lt;/p&gt;", alert.Type))
        body.WriteString(fmt.Sprintf("&lt;p&gt;&lt;strong&gt;Time:&lt;/strong&gt; %s&lt;/p&gt;", alert.Timestamp.Format(time.RFC3339)))
        body.WriteString(fmt.Sprintf("&lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt; %s&lt;/p&gt;", alert.Message))

        if len(alert.Details) &gt; 0 </span><span class="cov0" title="0">{
                body.WriteString("&lt;h3&gt;Details:&lt;/h3&gt;")
                body.WriteString("&lt;ul&gt;")
                for key, value := range alert.Details </span><span class="cov0" title="0">{
                        body.WriteString(fmt.Sprintf("&lt;li&gt;&lt;strong&gt;%s:&lt;/strong&gt; %v&lt;/li&gt;", key, value))
                }</span>
                <span class="cov0" title="0">body.WriteString("&lt;/ul&gt;")</span>
        }

        <span class="cov0" title="0">if len(alert.Actions) &gt; 0 </span><span class="cov0" title="0">{
                body.WriteString("&lt;h3&gt;Suggested Actions:&lt;/h3&gt;")
                body.WriteString("&lt;ul&gt;")
                for _, action := range alert.Actions </span><span class="cov0" title="0">{
                        body.WriteString(fmt.Sprintf("&lt;li&gt;%s&lt;/li&gt;", action))
                }</span>
                <span class="cov0" title="0">body.WriteString("&lt;/ul&gt;")</span>
        }

        <span class="cov0" title="0">if alert.Runbook != "" </span><span class="cov0" title="0">{
                body.WriteString(fmt.Sprintf("&lt;p&gt;&lt;strong&gt;Runbook:&lt;/strong&gt; &lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/p&gt;", alert.Runbook, alert.Runbook))
        }</span>

        <span class="cov0" title="0">body.WriteString("&lt;/body&gt;&lt;/html&gt;")

        return body.String()</span>
}

// Name returns the channel name
func (eac *EmailAlertChannel) Name() string <span class="cov0" title="0">{
        return "email"
}</span>

// IsEnabled returns true if the channel is enabled
func (eac *EmailAlertChannel) IsEnabled() bool <span class="cov0" title="0">{
        return eac.enabled
}</span>

// SetEnabled sets the channel enabled state
func (eac *EmailAlertChannel) SetEnabled(enabled bool) <span class="cov0" title="0">{
        eac.enabled = enabled
}</span>

// WebhookAlertChannel sends alerts to a webhook
type WebhookAlertChannel struct {
        url     string
        method  string
        headers map[string]string
        client  *http.Client
        enabled bool
        logger  *logger.Logger
}

// WebhookConfig represents webhook configuration
type WebhookConfig struct {
        URL     string            `json:"url"`
        Method  string            `json:"method"`
        Headers map[string]string `json:"headers"`
        Timeout time.Duration     `json:"timeout"`
}

// NewWebhookAlertChannel creates a new webhook alert channel
func NewWebhookAlertChannel(config *WebhookConfig, logger *logger.Logger) *WebhookAlertChannel <span class="cov0" title="0">{
        if config.Method == "" </span><span class="cov0" title="0">{
                config.Method = "POST"
        }</span>

        <span class="cov0" title="0">if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout: config.Timeout,
        }

        return &amp;WebhookAlertChannel{
                url:     config.URL,
                method:  config.Method,
                headers: config.Headers,
                client:  client,
                enabled: true,
                logger:  logger,
        }</span>
}

// Send sends an alert to a webhook
func (wac *WebhookAlertChannel) Send(ctx context.Context, alert *Alert) error <span class="cov0" title="0">{
        if !wac.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create webhook payload
        <span class="cov0" title="0">payload := map[string]interface{}{
                "alert":     alert,
                "timestamp": time.Now(),
                "source":    "hotel-reviews-error-handler",
        }

        // Marshal payload to JSON
        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                wac.logger.ErrorContext(ctx, "Failed to marshal webhook payload",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, wac.method, wac.url, strings.NewReader(string(jsonPayload)))
        if err != nil </span><span class="cov0" title="0">{
                wac.logger.ErrorContext(ctx, "Failed to create webhook request",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        for key, value := range wac.headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Send request
        <span class="cov0" title="0">resp, err := wac.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                wac.logger.ErrorContext(ctx, "Failed to send webhook request",
                        "alert_id", alert.ID,
                        "url", wac.url,
                        "error", err,
                )
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                wac.logger.ErrorContext(ctx, "Webhook request failed",
                        "alert_id", alert.ID,
                        "url", wac.url,
                        "status_code", resp.StatusCode,
                )
                return fmt.Errorf("webhook request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">wac.logger.InfoContext(ctx, "Webhook alert sent successfully",
                "alert_id", alert.ID,
                "url", wac.url,
                "status_code", resp.StatusCode,
        )

        return nil</span>
}

// Name returns the channel name
func (wac *WebhookAlertChannel) Name() string <span class="cov0" title="0">{
        return "webhook"
}</span>

// IsEnabled returns true if the channel is enabled
func (wac *WebhookAlertChannel) IsEnabled() bool <span class="cov0" title="0">{
        return wac.enabled
}</span>

// SetEnabled sets the channel enabled state
func (wac *WebhookAlertChannel) SetEnabled(enabled bool) <span class="cov0" title="0">{
        wac.enabled = enabled
}</span>

// SlackAlertChannel sends alerts to Slack
type SlackAlertChannel struct {
        webhookURL string
        channel    string
        username   string
        client     *http.Client
        enabled    bool
        logger     *logger.Logger
}

// SlackConfig represents Slack configuration
type SlackConfig struct {
        WebhookURL string        `json:"webhook_url"`
        Channel    string        `json:"channel"`
        Username   string        `json:"username"`
        Timeout    time.Duration `json:"timeout"`
}

// NewSlackAlertChannel creates a new Slack alert channel
func NewSlackAlertChannel(config *SlackConfig, logger *logger.Logger) *SlackAlertChannel <span class="cov0" title="0">{
        if config.Username == "" </span><span class="cov0" title="0">{
                config.Username = "Error Handler"
        }</span>

        <span class="cov0" title="0">if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout: config.Timeout,
        }

        return &amp;SlackAlertChannel{
                webhookURL: config.WebhookURL,
                channel:    config.Channel,
                username:   config.Username,
                client:     client,
                enabled:    true,
                logger:     logger,
        }</span>
}

// Send sends an alert to Slack
func (sac *SlackAlertChannel) Send(ctx context.Context, alert *Alert) error <span class="cov0" title="0">{
        if !sac.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create Slack message
        <span class="cov0" title="0">message := sac.createSlackMessage(alert)

        // Marshal message to JSON
        jsonMessage, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                sac.logger.ErrorContext(ctx, "Failed to marshal Slack message",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", sac.webhookURL, strings.NewReader(string(jsonMessage)))
        if err != nil </span><span class="cov0" title="0">{
                sac.logger.ErrorContext(ctx, "Failed to create Slack request",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Send request
        resp, err := sac.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                sac.logger.ErrorContext(ctx, "Failed to send Slack request",
                        "alert_id", alert.ID,
                        "error", err,
                )
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                sac.logger.ErrorContext(ctx, "Slack request failed",
                        "alert_id", alert.ID,
                        "status_code", resp.StatusCode,
                )
                return fmt.Errorf("slack request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">sac.logger.InfoContext(ctx, "Slack alert sent successfully",
                "alert_id", alert.ID,
                "channel", sac.channel,
        )

        return nil</span>
}

// createSlackMessage creates a Slack message for an alert
func (sac *SlackAlertChannel) createSlackMessage(alert *Alert) map[string]interface{} <span class="cov0" title="0">{
        // Determine color based on alert level
        color := "good"
        switch alert.Level </span>{
        case AlertLevelWarning:<span class="cov0" title="0">
                color = "warning"</span>
        case AlertLevelError:<span class="cov0" title="0">
                color = "danger"</span>
        case AlertLevelCritical:<span class="cov0" title="0">
                color = "danger"</span>
        }

        // Create attachment
        <span class="cov0" title="0">attachment := map[string]interface{}{
                "color":     color,
                "title":     alert.Title,
                "text":      alert.Message,
                "timestamp": alert.Timestamp.Unix(),
                "fields": []map[string]interface{}{
                        {
                                "title": "Level",
                                "value": string(alert.Level),
                                "short": true,
                        },
                        {
                                "title": "Type",
                                "value": string(alert.Type),
                                "short": true,
                        },
                        {
                                "title": "Alert ID",
                                "value": alert.ID,
                                "short": true,
                        },
                        {
                                "title": "Count",
                                "value": fmt.Sprintf("%d", alert.Count),
                                "short": true,
                        },
                },
        }

        // Add actions if present
        if len(alert.Actions) &gt; 0 </span><span class="cov0" title="0">{
                actionsText := strings.Join(alert.Actions, "\n‚Ä¢ ")
                attachment["fields"] = append(attachment["fields"].([]map[string]interface{}), map[string]interface{}{
                        "title": "Suggested Actions",
                        "value": "‚Ä¢ " + actionsText,
                        "short": false,
                })
        }</span>

        // Add runbook if present
        <span class="cov0" title="0">if alert.Runbook != "" </span><span class="cov0" title="0">{
                attachment["actions"] = []map[string]interface{}{
                        {
                                "type": "button",
                                "text": "View Runbook",
                                "url":  alert.Runbook,
                        },
                }
        }</span>

        // Create message
        <span class="cov0" title="0">message := map[string]interface{}{
                "username":    sac.username,
                "attachments": []map[string]interface{}{attachment},
        }

        if sac.channel != "" </span><span class="cov0" title="0">{
                message["channel"] = sac.channel
        }</span>

        <span class="cov0" title="0">return message</span>
}

// Name returns the channel name
func (sac *SlackAlertChannel) Name() string <span class="cov0" title="0">{
        return "slack"
}</span>

// IsEnabled returns true if the channel is enabled
func (sac *SlackAlertChannel) IsEnabled() bool <span class="cov0" title="0">{
        return sac.enabled
}</span>

// SetEnabled sets the channel enabled state
func (sac *SlackAlertChannel) SetEnabled(enabled bool) <span class="cov0" title="0">{
        sac.enabled = enabled
}</span>

// ConsoleAlertChannel sends alerts to the console
type ConsoleAlertChannel struct {
        enabled bool
        logger  *logger.Logger
}

// NewConsoleAlertChannel creates a new console alert channel
func NewConsoleAlertChannel(logger *logger.Logger) *ConsoleAlertChannel <span class="cov0" title="0">{
        return &amp;ConsoleAlertChannel{
                enabled: true,
                logger:  logger,
        }
}</span>

// Send sends an alert to the console
func (cac *ConsoleAlertChannel) Send(ctx context.Context, alert *Alert) error <span class="cov0" title="0">{
        if !cac.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create console output
        <span class="cov0" title="0">output := cac.createConsoleOutput(alert)

        // Print to console
        fmt.Print(output)

        return nil</span>
}

// createConsoleOutput creates console output for an alert
func (cac *ConsoleAlertChannel) createConsoleOutput(alert *Alert) string <span class="cov0" title="0">{
        var output strings.Builder

        // Add header
        output.WriteString(repeat("=", 80) + "\n")
        output.WriteString(fmt.Sprintf("ALERT: %s\n", alert.Title))
        output.WriteString(repeat("=", 80) + "\n")

        // Add details
        output.WriteString(fmt.Sprintf("Level: %s\n", alert.Level))
        output.WriteString(fmt.Sprintf("Type: %s\n", alert.Type))
        output.WriteString(fmt.Sprintf("Time: %s\n", alert.Timestamp.Format(time.RFC3339)))
        output.WriteString(fmt.Sprintf("Message: %s\n", alert.Message))

        if len(alert.Details) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("\nDetails:\n")
                for key, value := range alert.Details </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("  %s: %v\n", key, value))
                }</span>
        }

        <span class="cov0" title="0">if len(alert.Actions) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("\nSuggested Actions:\n")
                for _, action := range alert.Actions </span><span class="cov0" title="0">{
                        output.WriteString(fmt.Sprintf("  - %s\n", action))
                }</span>
        }

        <span class="cov0" title="0">if alert.Runbook != "" </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("\nRunbook: %s\n", alert.Runbook))
        }</span>

        <span class="cov0" title="0">output.WriteString(repeat("=", 80) + "\n\n")

        return output.String()</span>
}

// Name returns the channel name
func (cac *ConsoleAlertChannel) Name() string <span class="cov0" title="0">{
        return "console"
}</span>

// IsEnabled returns true if the channel is enabled
func (cac *ConsoleAlertChannel) IsEnabled() bool <span class="cov0" title="0">{
        return cac.enabled
}</span>

// SetEnabled sets the channel enabled state
func (cac *ConsoleAlertChannel) SetEnabled(enabled bool) <span class="cov0" title="0">{
        cac.enabled = enabled
}</span>

// Helper function to repeat string
func repeat(s string, count int) string <span class="cov0" title="0">{
        return strings.Repeat(s, count)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/segmentio/kafka-go"
)

// AsyncProcessor handles asynchronous message processing
type AsyncProcessor struct {
        writer      *kafka.Writer
        reader      *kafka.Reader
        logger      interface{}
        workerCount int
        handlers    map[string]MessageHandler
        mu          sync.RWMutex
        wg          sync.WaitGroup
        ctx         context.Context
        cancel      context.CancelFunc
}

// MessageHandler processes messages of a specific type
type MessageHandler func(ctx context.Context, message []byte) error

// NewAsyncProcessor creates a new async processor
func NewAsyncProcessor(writer *kafka.Writer, reader *kafka.Reader, logger interface{}, workerCount int) *AsyncProcessor <span class="cov9" title="18">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;AsyncProcessor{
                writer:      writer,
                reader:      reader,
                logger:      logger,
                workerCount: workerCount,
                handlers:    make(map[string]MessageHandler),
                ctx:         ctx,
                cancel:      cancel,
        }
}</span>

// RegisterHandler registers a handler for a message type
func (p *AsyncProcessor) RegisterHandler(messageType string, handler MessageHandler) <span class="cov10" title="22">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.handlers[messageType] = handler
}</span>

// Start starts the async processor workers
func (p *AsyncProcessor) Start(ctx context.Context) <span class="cov0" title="0">{
        for i := 0; i &lt; p.workerCount; i++ </span><span class="cov0" title="0">{
                p.wg.Add(1)
                go p.worker(i)
        }</span>
}

// Stop stops the async processor
func (p *AsyncProcessor) Stop(ctx context.Context) error <span class="cov5" title="5">{
        p.cancel()

        // Wait for workers to finish with timeout
        done := make(chan struct{})
        go func() </span><span class="cov5" title="5">{
                p.wg.Wait()
                close(done)
        }</span>()

        <span class="cov5" title="5">select </span>{
        case &lt;-done:<span class="cov5" title="5">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// PublishMessage publishes a message to Kafka
func (p *AsyncProcessor) PublishMessage(ctx context.Context, messageType string, data interface{}) error <span class="cov0" title="0">{
        payload, err := json.Marshal(map[string]interface{}{
                "type":      messageType,
                "data":      data,
                "timestamp": time.Now().Unix(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov0" title="0">message := kafka.Message{
                Key:   []byte(messageType),
                Value: payload,
        }

        err = p.writer.WriteMessages(ctx, message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish message: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// worker processes messages from Kafka
func (p *AsyncProcessor) worker(id int) <span class="cov0" title="0">{
        defer p.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-p.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        message, err := p.reader.ReadMessage(p.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == context.Canceled </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                // Log error and continue
                                <span class="cov0" title="0">continue</span>
                        }

                        // Process message
                        <span class="cov0" title="0">p.processMessage(message)</span>
                }
        }
}

// processMessage processes a single message
func (p *AsyncProcessor) processMessage(message kafka.Message) <span class="cov0" title="0">{
        var payload map[string]interface{}
        if err := json.Unmarshal(message.Value, &amp;payload); err != nil </span><span class="cov0" title="0">{
                // Log error
                return
        }</span>

        <span class="cov0" title="0">messageType, ok := payload["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Log error
                return
        }</span>

        <span class="cov0" title="0">p.mu.RLock()
        handler, exists := p.handlers[messageType]
        p.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                // Log unknown message type
                return
        }</span>

        // Execute handler
        <span class="cov0" title="0">if err := handler(p.ctx, message.Value); err != nil </span>{<span class="cov0" title="0">
                // Log error
                // In production, you might want to retry or send to DLQ
        }</span>
}

// EnqueueReviewProcessing enqueues a review for processing
func (p *AsyncProcessor) EnqueueReviewProcessing(ctx context.Context, reviewID string) error <span class="cov0" title="0">{
        return p.PublishMessage(ctx, "review.process", map[string]interface{}{
                "review_id": reviewID,
                "action":    "process",
        })
}</span>

// EnqueueEmailNotification enqueues an email notification
func (p *AsyncProcessor) EnqueueEmailNotification(ctx context.Context, to, subject, body string) error <span class="cov0" title="0">{
        return p.PublishMessage(ctx, "notification.email", map[string]interface{}{
                "to":      to,
                "subject": subject,
                "body":    body,
        })
}</span>

// EnqueueImageProcessing enqueues image processing
func (p *AsyncProcessor) EnqueueImageProcessing(ctx context.Context, imageURL string) error <span class="cov0" title="0">{
        return p.PublishMessage(ctx, "image.process", map[string]interface{}{
                "image_url":  imageURL,
                "operations": []string{"resize", "optimize"},
        })
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package infrastructure

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
)

const (
        // JWT constants
        AccessTokenExpiry  = 15 * time.Minute
        RefreshTokenExpiry = 7 * 24 * time.Hour
        AccessTokenType    = "access"
        RefreshTokenType   = "refresh"

        // Password constraints
        MinPasswordLength = 8
        MaxPasswordLength = 128

        // Rate limiting constants
        MaxLoginAttempts    = 5
        LoginAttemptWindow  = 15 * time.Minute
        AccountLockDuration = 30 * time.Minute

        // API Key constants
        ApiKeyLength = 32
        ApiKeyPrefix = "hr_"
)

// JWTService implements JWT-based authentication
type JWTService struct {
        secretKey      string
        issuer         string
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewJWTService creates a new JWT service with circuit breaker and retry support
func NewJWTService(cfg *config.Config, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *JWTService <span class="cov0" title="0">{
        return &amp;JWTService{
                secretKey:      cfg.Auth.JWTSecret,
                issuer:         cfg.Auth.JWTIssuer,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// GenerateAccessToken generates a new access token with circuit breaker protection
func (j *JWTService) GenerateAccessToken(ctx context.Context, user *domain.User) (string, error) <span class="cov0" title="0">{
        return j.executeWithResilience(ctx, "GenerateAccessToken", func() (string, error) </span><span class="cov0" title="0">{
                return j.generateToken(user, AccessTokenType, AccessTokenExpiry)
        }</span>)
}

// GenerateRefreshToken generates a new refresh token with circuit breaker protection
func (j *JWTService) GenerateRefreshToken(ctx context.Context, user *domain.User) (string, error) <span class="cov0" title="0">{
        return j.executeWithResilience(ctx, "GenerateRefreshToken", func() (string, error) </span><span class="cov0" title="0">{
                return j.generateToken(user, RefreshTokenType, RefreshTokenExpiry)
        }</span>)
}

// ValidateAccessToken validates an access token with circuit breaker protection
func (j *JWTService) ValidateAccessToken(ctx context.Context, tokenString string) (*domain.JWTClaims, error) <span class="cov0" title="0">{
        return j.executeWithResilienceForClaims(ctx, "ValidateAccessToken", func() (*domain.JWTClaims, error) </span><span class="cov0" title="0">{
                return j.validateToken(tokenString, AccessTokenType)
        }</span>)
}

// ValidateRefreshToken validates a refresh token with circuit breaker protection
func (j *JWTService) ValidateRefreshToken(ctx context.Context, tokenString string) (*domain.JWTClaims, error) <span class="cov0" title="0">{
        return j.executeWithResilienceForClaims(ctx, "ValidateRefreshToken", func() (*domain.JWTClaims, error) </span><span class="cov0" title="0">{
                return j.validateToken(tokenString, RefreshTokenType)
        }</span>)
}

// ExtractUserFromToken extracts user information from token
func (j *JWTService) ExtractUserFromToken(ctx context.Context, tokenString string) (*domain.User, error) <span class="cov0" title="0">{
        claims, err := j.ValidateAccessToken(ctx, tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user := &amp;domain.User{
                ID:       claims.UserID,
                Username: claims.Username,
                Email:    claims.Email,
        }

        return user, nil</span>
}

// generateToken generates a JWT token
func (j *JWTService) generateToken(user *domain.User, tokenType string, expiry time.Duration) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := &amp;domain.JWTClaims{
                UserID:    user.ID,
                Username:  user.Username,
                Email:     user.Email,
                Roles:     j.extractRoleNames(user.Roles),
                TokenType: tokenType,
                ExpiresAt: now.Add(expiry).Unix(),
                IssuedAt:  now.Unix(),
                Issuer:    j.issuer,
                Subject:   user.ID.String(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id":    claims.UserID,
                "username":   claims.Username,
                "email":      claims.Email,
                "roles":      claims.Roles,
                "token_type": claims.TokenType,
                "exp":        claims.ExpiresAt,
                "iat":        claims.IssuedAt,
                "iss":        claims.Issuer,
                "sub":        claims.Subject,
        })

        tokenString, err := token.SignedString([]byte(j.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "failed to sign token")
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// validateToken validates a JWT token
func (j *JWTService) validateToken(tokenString, expectedType string) (*domain.JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(j.secretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to parse token")
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid claims format")
        }</span>

        <span class="cov0" title="0">tokenType, ok := claims["token_type"].(string)
        if !ok || tokenType != expectedType </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token type")
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims["user_id"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "invalid user ID in token")
        }</span>

        <span class="cov0" title="0">jwtClaims := &amp;domain.JWTClaims{
                UserID:    userID,
                Username:  claims["username"].(string),
                Email:     claims["email"].(string),
                Roles:     j.extractRolesFromClaims(claims["roles"]),
                TokenType: tokenType,
                ExpiresAt: int64(claims["exp"].(float64)),
                IssuedAt:  int64(claims["iat"].(float64)),
                Issuer:    claims["iss"].(string),
                Subject:   claims["sub"].(string),
        }

        return jwtClaims, nil</span>
}

// extractRoleNames extracts role names from role entities
func (j *JWTService) extractRoleNames(roles []domain.Role) []string <span class="cov0" title="0">{
        roleNames := make([]string, len(roles))
        for i, role := range roles </span><span class="cov0" title="0">{
                roleNames[i] = role.Name
        }</span>
        <span class="cov0" title="0">return roleNames</span>
}

// extractRolesFromClaims extracts roles from JWT claims
func (j *JWTService) extractRolesFromClaims(rolesInterface interface{}) []string <span class="cov0" title="0">{
        if rolesInterface == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">switch roles := rolesInterface.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                roleNames := make([]string, len(roles))
                for i, role := range roles </span><span class="cov0" title="0">{
                        roleNames[i] = role.(string)
                }</span>
                <span class="cov0" title="0">return roleNames</span>
        case []string:<span class="cov0" title="0">
                return roles</span>
        default:<span class="cov0" title="0">
                return []string{}</span>
        }
}

// executeWithResilience executes a function with circuit breaker and retry support
func (j *JWTService) executeWithResilience(ctx context.Context, operation string, fn func() (string, error)) (string, error) <span class="cov0" title="0">{
        if j.circuitBreaker != nil </span><span class="cov0" title="0">{
                result, err := j.circuitBreaker.Execute(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        if j.retryManager != nil </span><span class="cov0" title="0">{
                                return j.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                                        return fn()
                                }</span>)
                        }
                        <span class="cov0" title="0">return fn()</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return result.(string), nil</span>
        }

        <span class="cov0" title="0">if j.retryManager != nil </span><span class="cov0" title="0">{
                result, err := j.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                        return fn()
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return result.(string), nil</span>
        }

        <span class="cov0" title="0">return fn()</span>
}

// executeWithResilienceForClaims executes a function returning claims with circuit breaker and retry support
func (j *JWTService) executeWithResilienceForClaims(ctx context.Context, operation string, fn func() (*domain.JWTClaims, error)) (*domain.JWTClaims, error) <span class="cov0" title="0">{
        if j.circuitBreaker != nil </span><span class="cov0" title="0">{
                result, err := j.circuitBreaker.Execute(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        if j.retryManager != nil </span><span class="cov0" title="0">{
                                return j.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                                        return fn()
                                }</span>)
                        }
                        <span class="cov0" title="0">return fn()</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result.(*domain.JWTClaims), nil</span>
        }

        <span class="cov0" title="0">if j.retryManager != nil </span><span class="cov0" title="0">{
                result, err := j.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                        return fn()
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result.(*domain.JWTClaims), nil</span>
        }

        <span class="cov0" title="0">return fn()</span>
}

// PasswordService implements password hashing and validation
type PasswordService struct {
        logger *slog.Logger
}

// NewPasswordService creates a new password service
func NewPasswordService(logger *slog.Logger) *PasswordService <span class="cov0" title="0">{
        return &amp;PasswordService{
                logger: logger,
        }
}</span>

// HashPassword hashes a password using bcrypt
func (p *PasswordService) HashPassword(password string) (string, error) <span class="cov0" title="0">{
        if err := p.ValidatePasswordStrength(password); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "failed to hash password")
        }</span>

        <span class="cov0" title="0">return string(hash), nil</span>
}

// ComparePassword compares a password with its hash
func (p *PasswordService) ComparePassword(hashedPassword, password string) error <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "password comparison failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GenerateRandomPassword generates a random password
func (p *PasswordService) GenerateRandomPassword(length int) (string, error) <span class="cov0" title="0">{
        if length &lt; MinPasswordLength </span><span class="cov0" title="0">{
                length = MinPasswordLength
        }</span>
        <span class="cov0" title="0">if length &gt; MaxPasswordLength </span><span class="cov0" title="0">{
                length = MaxPasswordLength
        }</span>

        <span class="cov0" title="0">const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                randomIndex := make([]byte, 1)
                _, err := rand.Read(randomIndex)
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "failed to generate random password")
                }</span>
                <span class="cov0" title="0">b[i] = charset[randomIndex[0]%byte(len(charset))]</span>
        }

        <span class="cov0" title="0">return string(b), nil</span>
}

// ValidatePasswordStrength validates password strength
func (p *PasswordService) ValidatePasswordStrength(password string) error <span class="cov0" title="0">{
        if len(password) &lt; MinPasswordLength </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be at least %d characters long", MinPasswordLength)
        }</span>

        <span class="cov0" title="0">if len(password) &gt; MaxPasswordLength </span><span class="cov0" title="0">{
                return fmt.Errorf("password must not exceed %d characters", MaxPasswordLength)
        }</span>

        <span class="cov0" title="0">var hasLower, hasUpper, hasDigit, hasSpecial bool
        for _, char := range password </span><span class="cov0" title="0">{
                switch </span>{
                case char &gt;= 'a' &amp;&amp; char &lt;= 'z':<span class="cov0" title="0">
                        hasLower = true</span>
                case char &gt;= 'A' &amp;&amp; char &lt;= 'Z':<span class="cov0" title="0">
                        hasUpper = true</span>
                case char &gt;= '0' &amp;&amp; char &lt;= '9':<span class="cov0" title="0">
                        hasDigit = true</span>
                case strings.ContainsRune("!@#$%^&amp;*()_+-=[]{}|;:,.&lt;&gt;?", char):<span class="cov0" title="0">
                        hasSpecial = true</span>
                }
        }

        <span class="cov0" title="0">if !hasLower </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one lowercase letter")
        }</span>
        <span class="cov0" title="0">if !hasUpper </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one uppercase letter")
        }</span>
        <span class="cov0" title="0">if !hasDigit </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one digit")
        }</span>
        <span class="cov0" title="0">if !hasSpecial </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one special character")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AuthRepository implements authentication repository with circuit breaker support
type AuthRepository struct {
        db             *gorm.DB
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewAuthRepository creates a new authentication repository
func NewAuthRepository(db *gorm.DB, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *AuthRepository <span class="cov0" title="0">{
        return &amp;AuthRepository{
                db:             db,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// CreateUser creates a new user
func (r *AuthRepository) CreateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(user).Error
        }</span>)
}

// GetUserByID retrieves a user by ID
func (r *AuthRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.executeWithDB(ctx, "GetUserByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Roles").Preload("Roles.Permissions").First(&amp;user, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByEmail retrieves a user by email
func (r *AuthRepository) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.executeWithDB(ctx, "GetUserByEmail", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Roles").Preload("Roles.Permissions").First(&amp;user, "email = ?", email).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByUsername retrieves a user by username
func (r *AuthRepository) GetUserByUsername(ctx context.Context, username string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.executeWithDB(ctx, "GetUserByUsername", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Roles").Preload("Roles.Permissions").First(&amp;user, "username = ?", username).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateUser updates a user
func (r *AuthRepository) UpdateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "UpdateUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Save(user).Error
        }</span>)
}

// DeleteUser deletes a user
func (r *AuthRepository) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeleteUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Delete(&amp;domain.User{}, "id = ?", id).Error
        }</span>)
}

// ListUsers lists users with pagination
func (r *AuthRepository) ListUsers(ctx context.Context, limit, offset int) ([]domain.User, error) <span class="cov0" title="0">{
        var users []domain.User
        err := r.executeWithDB(ctx, "ListUsers", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Roles").Limit(limit).Offset(offset).Find(&amp;users).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// UpdateUserLastLogin updates user's last login timestamp
func (r *AuthRepository) UpdateUserLastLogin(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        now := time.Now()
        return r.executeWithDB(ctx, "UpdateUserLastLogin", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Model(&amp;domain.User{}).Where("id = ?", userID).Update("last_login_at", now).Error
        }</span>)
}

// IncrementFailedAttempts increments failed login attempts
func (r *AuthRepository) IncrementFailedAttempts(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "IncrementFailedAttempts", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Model(&amp;domain.User{}).Where("id = ?", userID).Update("failed_attempts", gorm.Expr("failed_attempts + 1")).Error
        }</span>)
}

// ResetFailedAttempts resets failed login attempts
func (r *AuthRepository) ResetFailedAttempts(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "ResetFailedAttempts", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Model(&amp;domain.User{}).Where("id = ?", userID).Updates(map[string]interface{}{
                        "failed_attempts": 0,
                        "locked_until":    nil,
                }).Error
        }</span>)
}

// LockUser locks a user account until specified time
func (r *AuthRepository) LockUser(ctx context.Context, userID uuid.UUID, until time.Time) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "LockUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Model(&amp;domain.User{}).Where("id = ?", userID).Update("locked_until", until).Error
        }</span>)
}

// CreateSession creates a new session
func (r *AuthRepository) CreateSession(ctx context.Context, session *domain.Session) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateSession", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(session).Error
        }</span>)
}

// GetSessionByAccessToken retrieves session by access token
func (r *AuthRepository) GetSessionByAccessToken(ctx context.Context, accessToken string) (*domain.Session, error) <span class="cov0" title="0">{
        var session domain.Session
        err := r.executeWithDB(ctx, "GetSessionByAccessToken", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;session, "access_token = ? AND is_active = ?", accessToken, true).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;session, nil</span>
}

// GetSessionByRefreshToken retrieves session by refresh token
func (r *AuthRepository) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*domain.Session, error) <span class="cov0" title="0">{
        var session domain.Session
        err := r.executeWithDB(ctx, "GetSessionByRefreshToken", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;session, "refresh_token = ? AND is_active = ?", refreshToken, true).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;session, nil</span>
}

// UpdateSession updates a session
func (r *AuthRepository) UpdateSession(ctx context.Context, session *domain.Session) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "UpdateSession", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Save(session).Error
        }</span>)
}

// DeleteSession deletes a session
func (r *AuthRepository) DeleteSession(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeleteSession", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Delete(&amp;domain.Session{}, "id = ?", id).Error
        }</span>)
}

// DeleteUserSessions deletes all sessions for a user
func (r *AuthRepository) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeleteUserSessions", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Where("user_id = ?", userID).Delete(&amp;domain.Session{}).Error
        }</span>)
}

// CleanupExpiredSessions removes expired sessions
func (r *AuthRepository) CleanupExpiredSessions(ctx context.Context) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CleanupExpiredSessions", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Where("expires_at &lt; ?", time.Now()).Delete(&amp;domain.Session{}).Error
        }</span>)
}

// CreateApiKey creates a new API key
func (r *AuthRepository) CreateApiKey(ctx context.Context, apiKey *domain.ApiKey) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateApiKey", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(apiKey).Error
        }</span>)
}

// GetApiKeyByKey retrieves API key by key value
func (r *AuthRepository) GetApiKeyByKey(ctx context.Context, key string) (*domain.ApiKey, error) <span class="cov0" title="0">{
        var apiKey domain.ApiKey
        err := r.executeWithDB(ctx, "GetApiKeyByKey", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;apiKey, "key = ? AND is_active = ?", key, true).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;apiKey, nil</span>
}

// UpdateApiKeyUsage updates API key usage
func (r *AuthRepository) UpdateApiKeyUsage(ctx context.Context, apiKeyID uuid.UUID) error <span class="cov0" title="0">{
        now := time.Now()
        return r.executeWithDB(ctx, "UpdateApiKeyUsage", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Model(&amp;domain.ApiKey{}).Where("id = ?", apiKeyID).Updates(map[string]interface{}{
                        "usage_count":  gorm.Expr("usage_count + 1"),
                        "last_used_at": now,
                }).Error
        }</span>)
}

// CreateLoginAttempt creates a login attempt record
func (r *AuthRepository) CreateLoginAttempt(ctx context.Context, attempt *domain.LoginAttempt) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateLoginAttempt", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(attempt).Error
        }</span>)
}

// GetLoginAttempts retrieves login attempts
func (r *AuthRepository) GetLoginAttempts(ctx context.Context, email string, ipAddress string, since time.Time) ([]domain.LoginAttempt, error) <span class="cov0" title="0">{
        var attempts []domain.LoginAttempt
        err := r.executeWithDB(ctx, "GetLoginAttempts", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Where("email = ? AND ip_address = ? AND created_at &gt; ?", email, ipAddress, since).Find(&amp;attempts).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return attempts, nil</span>
}

// CreateAuditLog creates an audit log entry
func (r *AuthRepository) CreateAuditLog(ctx context.Context, auditLog *domain.AuditLog) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateAuditLog", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(auditLog).Error
        }</span>)
}

// GetUserPermissions retrieves all permissions for a user
func (r *AuthRepository) GetUserPermissions(ctx context.Context, userID uuid.UUID) ([]domain.Permission, error) <span class="cov0" title="0">{
        var permissions []domain.Permission
        err := r.executeWithDB(ctx, "GetUserPermissions", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).
                        Table("permissions").
                        Joins("JOIN role_permissions ON permissions.id = role_permissions.permission_id").
                        Joins("JOIN user_roles ON role_permissions.role_id = user_roles.role_id").
                        Where("user_roles.user_id = ? AND permissions.is_active = ?", userID, true).
                        Find(&amp;permissions).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return permissions, nil</span>
}

// Additional repository methods

// CreateRole creates a new role
func (r *AuthRepository) CreateRole(ctx context.Context, role *domain.Role) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreateRole", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(role).Error
        }</span>)
}

// GetRoleByID retrieves a role by ID
func (r *AuthRepository) GetRoleByID(ctx context.Context, id uuid.UUID) (*domain.Role, error) <span class="cov0" title="0">{
        var role domain.Role
        err := r.executeWithDB(ctx, "GetRoleByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Permissions").First(&amp;role, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;role, nil</span>
}

// GetRoleByName retrieves a role by name
func (r *AuthRepository) GetRoleByName(ctx context.Context, name string) (*domain.Role, error) <span class="cov0" title="0">{
        var role domain.Role
        err := r.executeWithDB(ctx, "GetRoleByName", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Permissions").First(&amp;role, "name = ?", name).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;role, nil</span>
}

// UpdateRole updates a role
func (r *AuthRepository) UpdateRole(ctx context.Context, role *domain.Role) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "UpdateRole", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Save(role).Error
        }</span>)
}

// DeleteRole deletes a role
func (r *AuthRepository) DeleteRole(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeleteRole", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Delete(&amp;domain.Role{}, "id = ?", id).Error
        }</span>)
}

// ListRoles lists roles with pagination
func (r *AuthRepository) ListRoles(ctx context.Context, limit, offset int) ([]domain.Role, error) <span class="cov0" title="0">{
        var roles []domain.Role
        err := r.executeWithDB(ctx, "ListRoles", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("Permissions").Limit(limit).Offset(offset).Find(&amp;roles).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return roles, nil</span>
}

// CreatePermission creates a new permission
func (r *AuthRepository) CreatePermission(ctx context.Context, permission *domain.Permission) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CreatePermission", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Create(permission).Error
        }</span>)
}

// GetPermissionByID retrieves a permission by ID
func (r *AuthRepository) GetPermissionByID(ctx context.Context, id uuid.UUID) (*domain.Permission, error) <span class="cov0" title="0">{
        var permission domain.Permission
        err := r.executeWithDB(ctx, "GetPermissionByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).First(&amp;permission, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;permission, nil</span>
}

// GetPermissionByName retrieves a permission by name
func (r *AuthRepository) GetPermissionByName(ctx context.Context, name string) (*domain.Permission, error) <span class="cov0" title="0">{
        var permission domain.Permission
        err := r.executeWithDB(ctx, "GetPermissionByName", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).First(&amp;permission, "name = ?", name).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;permission, nil</span>
}

// UpdatePermission updates a permission
func (r *AuthRepository) UpdatePermission(ctx context.Context, permission *domain.Permission) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "UpdatePermission", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Save(permission).Error
        }</span>)
}

// DeletePermission deletes a permission
func (r *AuthRepository) DeletePermission(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeletePermission", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Delete(&amp;domain.Permission{}, "id = ?", id).Error
        }</span>)
}

// ListPermissions lists permissions with pagination
func (r *AuthRepository) ListPermissions(ctx context.Context, limit, offset int) ([]domain.Permission, error) <span class="cov0" title="0">{
        var permissions []domain.Permission
        err := r.executeWithDB(ctx, "ListPermissions", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Limit(limit).Offset(offset).Find(&amp;permissions).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return permissions, nil</span>
}

// AssignRoleToUser assigns a role to a user
func (r *AuthRepository) AssignRoleToUser(ctx context.Context, userID, roleID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "AssignRoleToUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Exec("INSERT INTO user_roles (user_id, role_id) VALUES (?, ?) ON CONFLICT DO NOTHING", userID, roleID).Error
        }</span>)
}

// RemoveRoleFromUser removes a role from a user
func (r *AuthRepository) RemoveRoleFromUser(ctx context.Context, userID, roleID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "RemoveRoleFromUser", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Exec("DELETE FROM user_roles WHERE user_id = ? AND role_id = ?", userID, roleID).Error
        }</span>)
}

// GetUserRoles retrieves all roles for a user
func (r *AuthRepository) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]domain.Role, error) <span class="cov0" title="0">{
        var roles []domain.Role
        err := r.executeWithDB(ctx, "GetUserRoles", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).
                        Table("roles").
                        Joins("JOIN user_roles ON roles.id = user_roles.role_id").
                        Where("user_roles.user_id = ? AND roles.is_active = ?", userID, true).
                        Find(&amp;roles).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return roles, nil</span>
}

// GetRoleUsers retrieves all users for a role
func (r *AuthRepository) GetRoleUsers(ctx context.Context, roleID uuid.UUID) ([]domain.User, error) <span class="cov0" title="0">{
        var users []domain.User
        err := r.executeWithDB(ctx, "GetRoleUsers", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).
                        Table("users").
                        Joins("JOIN user_roles ON users.id = user_roles.user_id").
                        Where("user_roles.role_id = ? AND users.is_active = ?", roleID, true).
                        Find(&amp;users).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// AssignPermissionToRole assigns a permission to a role
func (r *AuthRepository) AssignPermissionToRole(ctx context.Context, roleID, permissionID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "AssignPermissionToRole", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Exec("INSERT INTO role_permissions (role_id, permission_id) VALUES (?, ?) ON CONFLICT DO NOTHING", roleID, permissionID).Error
        }</span>)
}

// RemovePermissionFromRole removes a permission from a role
func (r *AuthRepository) RemovePermissionFromRole(ctx context.Context, roleID, permissionID uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "RemovePermissionFromRole", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Exec("DELETE FROM role_permissions WHERE role_id = ? AND permission_id = ?", roleID, permissionID).Error
        }</span>)
}

// GetRolePermissions retrieves all permissions for a role
func (r *AuthRepository) GetRolePermissions(ctx context.Context, roleID uuid.UUID) ([]domain.Permission, error) <span class="cov0" title="0">{
        var permissions []domain.Permission
        err := r.executeWithDB(ctx, "GetRolePermissions", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).
                        Table("permissions").
                        Joins("JOIN role_permissions ON permissions.id = role_permissions.permission_id").
                        Where("role_permissions.role_id = ? AND permissions.is_active = ?", roleID, true).
                        Find(&amp;permissions).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return permissions, nil</span>
}

// GetSessionByID retrieves a session by ID
func (r *AuthRepository) GetSessionByID(ctx context.Context, id uuid.UUID) (*domain.Session, error) <span class="cov0" title="0">{
        var session domain.Session
        err := r.executeWithDB(ctx, "GetSessionByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;session, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;session, nil</span>
}

// GetApiKeyByID retrieves an API key by ID
func (r *AuthRepository) GetApiKeyByID(ctx context.Context, id uuid.UUID) (*domain.ApiKey, error) <span class="cov0" title="0">{
        var apiKey domain.ApiKey
        err := r.executeWithDB(ctx, "GetApiKeyByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;apiKey, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;apiKey, nil</span>
}

// UpdateApiKey updates an API key
func (r *AuthRepository) UpdateApiKey(ctx context.Context, apiKey *domain.ApiKey) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "UpdateApiKey", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Save(apiKey).Error
        }</span>)
}

// DeleteApiKey deletes an API key
func (r *AuthRepository) DeleteApiKey(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "DeleteApiKey", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Delete(&amp;domain.ApiKey{}, "id = ?", id).Error
        }</span>)
}

// ListApiKeys lists API keys for a user
func (r *AuthRepository) ListApiKeys(ctx context.Context, userID uuid.UUID, limit, offset int) ([]domain.ApiKey, error) <span class="cov0" title="0">{
        var apiKeys []domain.ApiKey
        err := r.executeWithDB(ctx, "ListApiKeys", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Where("user_id = ?", userID).Limit(limit).Offset(offset).Find(&amp;apiKeys).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return apiKeys, nil</span>
}

// GetAuditLogByID retrieves an audit log by ID
func (r *AuthRepository) GetAuditLogByID(ctx context.Context, id uuid.UUID) (*domain.AuditLog, error) <span class="cov0" title="0">{
        var auditLog domain.AuditLog
        err := r.executeWithDB(ctx, "GetAuditLogByID", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Preload("User").First(&amp;auditLog, "id = ?", id).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;auditLog, nil</span>
}

// ListAuditLogs lists audit logs with optional user filter
func (r *AuthRepository) ListAuditLogs(ctx context.Context, userID *uuid.UUID, limit, offset int) ([]domain.AuditLog, error) <span class="cov0" title="0">{
        var auditLogs []domain.AuditLog
        err := r.executeWithDB(ctx, "ListAuditLogs", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                query := db.WithContext(ctx).Preload("User")
                if userID != nil </span><span class="cov0" title="0">{
                        query = query.Where("user_id = ?", *userID)
                }</span>
                <span class="cov0" title="0">return query.Limit(limit).Offset(offset).Find(&amp;auditLogs).Error</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return auditLogs, nil</span>
}

// CleanupOldLoginAttempts removes old login attempts
func (r *AuthRepository) CleanupOldLoginAttempts(ctx context.Context, before time.Time) error <span class="cov0" title="0">{
        return r.executeWithDB(ctx, "CleanupOldLoginAttempts", func(db *gorm.DB) error </span><span class="cov0" title="0">{
                return db.WithContext(ctx).Where("created_at &lt; ?", before).Delete(&amp;domain.LoginAttempt{}).Error
        }</span>)
}

// executeWithDB executes a database operation with circuit breaker and retry support
func (r *AuthRepository) executeWithDB(ctx context.Context, operation string, fn func(*gorm.DB) error) error <span class="cov0" title="0">{
        if r.circuitBreaker != nil </span><span class="cov0" title="0">{
                _, err := r.circuitBreaker.Execute(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        if r.retryManager != nil </span><span class="cov0" title="0">{
                                _, err := r.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                                        return nil, fn(r.db)
                                }</span>)
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov0" title="0">return nil, fn(r.db)</span>
                })
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if r.retryManager != nil </span><span class="cov0" title="0">{
                _, err := r.retryManager.Execute(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                        return nil, fn(r.db)
                }</span>)
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return fn(r.db)</span>
}

// RBACService implements role-based access control
type RBACService struct {
        authRepo       domain.AuthRepository
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewRBACService creates a new RBAC service
func NewRBACService(authRepo domain.AuthRepository, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *RBACService <span class="cov0" title="0">{
        return &amp;RBACService{
                authRepo:       authRepo,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// CheckPermission checks if a user has a specific permission
func (r *RBACService) CheckPermission(ctx context.Context, userID uuid.UUID, resource, action string) (bool, error) <span class="cov1" title="1">{
        permissions, err := r.authRepo.GetUserPermissions(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov1" title="1">for _, permission := range permissions </span><span class="cov1" title="1">{
                if permission.Resource == resource &amp;&amp; permission.Action == action </span><span class="cov1" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// ApiKeyService implements API key authentication
type ApiKeyService struct {
        authRepo       domain.AuthRepository
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewApiKeyService creates a new API key service
func NewApiKeyService(authRepo domain.AuthRepository, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *ApiKeyService <span class="cov0" title="0">{
        return &amp;ApiKeyService{
                authRepo:       authRepo,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// GenerateApiKey generates a new API key
func (a *ApiKeyService) GenerateApiKey(ctx context.Context, userID uuid.UUID, name string, scopes []string, expiresAt *time.Time) (*domain.ApiKey, error) <span class="cov0" title="0">{
        // Generate random key
        keyBytes := make([]byte, ApiKeyLength)
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to generate API key")
        }</span>

        <span class="cov0" title="0">key := ApiKeyPrefix + base64.URLEncoding.EncodeToString(keyBytes)

        // Hash the key for storage
        keyHash, err := bcrypt.GenerateFromPassword([]byte(key), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to hash API key")
        }</span>

        <span class="cov0" title="0">apiKey := &amp;domain.ApiKey{
                ID:        uuid.New(),
                UserID:    userID,
                Name:      name,
                Key:       key, // This will be returned once, then removed
                KeyHash:   string(keyHash),
                IsActive:  true,
                ExpiresAt: expiresAt,
                Scopes:    scopes,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := a.authRepo.CreateApiKey(ctx, apiKey); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return apiKey, nil</span>
}

// ValidateApiKey validates an API key
func (a *ApiKeyService) ValidateApiKey(ctx context.Context, key string) (*domain.ApiKey, error) <span class="cov0" title="0">{
        if !strings.HasPrefix(key, ApiKeyPrefix) </span><span class="cov0" title="0">{
                return nil, errors.New("invalid API key format")
        }</span>

        // Get all API keys and check against hashes (in production, consider indexing strategies)
        <span class="cov0" title="0">apiKey, err := a.authRepo.GetApiKeyByKey(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if key is expired
        <span class="cov0" title="0">if apiKey.ExpiresAt != nil &amp;&amp; apiKey.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("API key has expired")
        }</span>

        // Validate the key hash
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(apiKey.KeyHash), []byte(key)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid API key")
        }</span>

        // Update usage
        <span class="cov0" title="0">if err := a.authRepo.UpdateApiKeyUsage(ctx, apiKey.ID); err != nil </span><span class="cov0" title="0">{
                a.logger.Error("failed to update API key usage", "error", err, "api_key_id", apiKey.ID)
        }</span>

        <span class="cov0" title="0">return apiKey, nil</span>
}

// RateLimitService implements rate limiting for authentication
type RateLimitService struct {
        authRepo       domain.AuthRepository
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewRateLimitService creates a new rate limiting service
func NewRateLimitService(authRepo domain.AuthRepository, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *RateLimitService <span class="cov0" title="0">{
        return &amp;RateLimitService{
                authRepo:       authRepo,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// IsRateLimited checks if a user/IP is rate limited
func (r *RateLimitService) IsRateLimited(ctx context.Context, email, ipAddress string) (bool, error) <span class="cov0" title="0">{
        since := time.Now().Add(-LoginAttemptWindow)
        attempts, err := r.authRepo.GetLoginAttempts(ctx, email, ipAddress, since)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">failedAttempts := 0
        for _, attempt := range attempts </span><span class="cov0" title="0">{
                if !attempt.Success </span><span class="cov0" title="0">{
                        failedAttempts++
                }</span>
        }

        <span class="cov0" title="0">return failedAttempts &gt;= MaxLoginAttempts, nil</span>
}

// RecordLoginAttempt records a login attempt
func (r *RateLimitService) RecordLoginAttempt(ctx context.Context, email, ipAddress, userAgent string, success bool, failureReason string) error <span class="cov0" title="0">{
        attempt := &amp;domain.LoginAttempt{
                ID:            uuid.New(),
                Email:         email,
                IpAddress:     ipAddress,
                UserAgent:     userAgent,
                Success:       success,
                FailureReason: failureReason,
                CreatedAt:     time.Now(),
        }

        return r.authRepo.CreateLoginAttempt(ctx, attempt)
}</span>

// AuditService implements audit logging
type AuditService struct {
        authRepo       domain.AuthRepository
        logger         *slog.Logger
        circuitBreaker *CircuitBreaker
        retryManager   *RetryManager
}

// NewAuditService creates a new audit service
func NewAuditService(authRepo domain.AuthRepository, logger *slog.Logger, cb *CircuitBreaker, retry *RetryManager) *AuditService <span class="cov0" title="0">{
        return &amp;AuditService{
                authRepo:       authRepo,
                logger:         logger,
                circuitBreaker: cb,
                retryManager:   retry,
        }
}</span>

// AuditAction records an audit log entry
func (a *AuditService) AuditAction(ctx context.Context, userID *uuid.UUID, action, resource string, resourceID *uuid.UUID, oldValues, newValues map[string]interface{}, ipAddress, userAgent string) error <span class="cov0" title="0">{
        auditLog := &amp;domain.AuditLog{
                ID:         uuid.New(),
                UserID:     userID,
                Action:     action,
                Resource:   resource,
                ResourceID: resourceID,
                OldValues:  oldValues,
                NewValues:  newValues,
                IpAddress:  ipAddress,
                UserAgent:  userAgent,
                Result:     "success",
                CreatedAt:  time.Now(),
        }

        return a.authRepo.CreateAuditLog(ctx, auditLog)
}</span>

// AuthenticationService orchestrates all authentication components
type AuthenticationService struct {
        authRepo         domain.AuthRepository
        jwtService       domain.JWTService
        passwordService  domain.PasswordService
        rbacService      *RBACService
        apiKeyService    *ApiKeyService
        rateLimitService *RateLimitService
        auditService     *AuditService
        logger           *slog.Logger
        circuitBreaker   *CircuitBreaker
        retryManager     *RetryManager
}

// NewAuthenticationService creates a comprehensive authentication service
func NewAuthenticationService(
        authRepo domain.AuthRepository,
        jwtService domain.JWTService,
        passwordService domain.PasswordService,
        rbacService *RBACService,
        apiKeyService *ApiKeyService,
        rateLimitService *RateLimitService,
        auditService *AuditService,
        logger *slog.Logger,
        cb *CircuitBreaker,
        retry *RetryManager,
) *AuthenticationService <span class="cov0" title="0">{
        return &amp;AuthenticationService{
                authRepo:         authRepo,
                jwtService:       jwtService,
                passwordService:  passwordService,
                rbacService:      rbacService,
                apiKeyService:    apiKeyService,
                rateLimitService: rateLimitService,
                auditService:     auditService,
                logger:           logger,
                circuitBreaker:   cb,
                retryManager:     retry,
        }
}</span>

// Login authenticates a user and returns a login response
func (a *AuthenticationService) Login(ctx context.Context, email, password, ipAddress, userAgent string) (*domain.LoginResponse, error) <span class="cov0" title="0">{
        // Check if rate limit service is available
        if a.rateLimitService == nil </span><span class="cov0" title="0">{
                return nil, errors.New("rate limit service not available")
        }</span>
        
        // Check rate limiting
        <span class="cov0" title="0">isRateLimited, err := a.rateLimitService.IsRateLimited(ctx, email, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if isRateLimited </span><span class="cov0" title="0">{
                return nil, errors.New("too many failed login attempts, please try again later")
        }</span>

        // Get user by email
        <span class="cov0" title="0">user, err := a.authRepo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                // Record failed attempt
                _ = a.rateLimitService.RecordLoginAttempt(ctx, email, ipAddress, userAgent, false, "user_not_found")
                return nil, errors.New("invalid credentials")
        }</span>

        // Check if user is locked
        <span class="cov0" title="0">if user.LockedUntil != nil &amp;&amp; user.LockedUntil.After(time.Now()) </span><span class="cov0" title="0">{
                _ = a.rateLimitService.RecordLoginAttempt(ctx, email, ipAddress, userAgent, false, "account_locked")
                return nil, errors.New("account is locked")
        }</span>

        // Verify password
        <span class="cov0" title="0">if err := a.passwordService.ComparePassword(user.PasswordHash, password); err != nil </span><span class="cov0" title="0">{
                // Increment failed attempts
                _ = a.authRepo.IncrementFailedAttempts(ctx, user.ID)

                // Lock account if too many failed attempts
                if user.FailedAttempts+1 &gt;= MaxLoginAttempts </span><span class="cov0" title="0">{
                        lockUntil := time.Now().Add(AccountLockDuration)
                        _ = a.authRepo.LockUser(ctx, user.ID, lockUntil)
                }</span>

                <span class="cov0" title="0">_ = a.rateLimitService.RecordLoginAttempt(ctx, email, ipAddress, userAgent, false, "invalid_password")
                return nil, errors.New("invalid credentials")</span>
        }

        // Reset failed attempts on successful login
        <span class="cov0" title="0">_ = a.authRepo.ResetFailedAttempts(ctx, user.ID)

        // Update last login
        _ = a.authRepo.UpdateUserLastLogin(ctx, user.ID)

        // Generate tokens
        accessToken, err := a.jwtService.GenerateAccessToken(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">refreshToken, err := a.jwtService.GenerateRefreshToken(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create session
        <span class="cov0" title="0">session := &amp;domain.Session{
                ID:               uuid.New(),
                UserID:           user.ID,
                AccessToken:      accessToken,
                RefreshToken:     refreshToken,
                ExpiresAt:        time.Now().Add(AccessTokenExpiry),
                RefreshExpiresAt: time.Now().Add(RefreshTokenExpiry),
                IsActive:         true,
                UserAgent:        userAgent,
                IpAddress:        ipAddress,
                LastUsedAt:       time.Now(),
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        if err := a.authRepo.CreateSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Record successful login attempt
        <span class="cov0" title="0">_ = a.rateLimitService.RecordLoginAttempt(ctx, email, ipAddress, userAgent, true, "")

        // Audit successful login
        _ = a.auditService.AuditAction(ctx, &amp;user.ID, "login", "user", &amp;user.ID, nil, nil, ipAddress, userAgent)

        return &amp;domain.LoginResponse{
                User:         user,
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(AccessTokenExpiry.Seconds()),
        }, nil</span>
}

// RefreshToken refreshes an access token
func (a *AuthenticationService) RefreshToken(ctx context.Context, refreshToken string) (*domain.LoginResponse, error) <span class="cov0" title="0">{
        // Validate refresh token
        claims, err := a.jwtService.ValidateRefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get session
        <span class="cov0" title="0">session, err := a.authRepo.GetSessionByRefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // Check if session is expired
        <span class="cov0" title="0">if session.RefreshExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("refresh token expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := a.authRepo.GetUserByID(ctx, claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate new tokens
        <span class="cov0" title="0">newAccessToken, err := a.jwtService.GenerateAccessToken(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">newRefreshToken, err := a.jwtService.GenerateRefreshToken(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update session
        <span class="cov0" title="0">session.AccessToken = newAccessToken
        session.RefreshToken = newRefreshToken
        session.ExpiresAt = time.Now().Add(AccessTokenExpiry)
        session.RefreshExpiresAt = time.Now().Add(RefreshTokenExpiry)
        session.LastUsedAt = time.Now()
        session.UpdatedAt = time.Now()

        if err := a.authRepo.UpdateSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;domain.LoginResponse{
                User:         user,
                AccessToken:  newAccessToken,
                RefreshToken: newRefreshToken,
                ExpiresIn:    int64(AccessTokenExpiry.Seconds()),
        }, nil</span>
}

// Logout logs out a user
func (a *AuthenticationService) Logout(ctx context.Context, accessToken string) error <span class="cov0" title="0">{
        session, err := a.authRepo.GetSessionByAccessToken(ctx, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return a.authRepo.DeleteSession(ctx, session.ID)</span>
}

// ValidateToken validates a JWT token
func (a *AuthenticationService) ValidateToken(ctx context.Context, token string) (*domain.User, error) <span class="cov0" title="0">{
        claims, err := a.jwtService.ValidateAccessToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get user to ensure it still exists and is active
        <span class="cov0" title="0">user, err := a.authRepo.GetUserByID(ctx, claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !user.IsActive </span><span class="cov0" title="0">{
                return nil, errors.New("user account is inactive")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// CheckPermission checks if a user has a specific permission
func (a *AuthenticationService) CheckPermission(ctx context.Context, userID uuid.UUID, resource, action string) (bool, error) <span class="cov10" title="3">{
        if a.rbacService == nil </span><span class="cov6" title="2">{
                return false, fmt.Errorf("RBAC service not initialized")
        }</span>
        <span class="cov1" title="1">return a.rbacService.CheckPermission(ctx, userID, resource, action)</span>
}

// CreateApiKey creates a new API key
func (a *AuthenticationService) CreateApiKey(ctx context.Context, userID uuid.UUID, name string, scopes []string, expiresAt *time.Time) (*domain.ApiKey, error) <span class="cov1" title="1">{
        if a.apiKeyService == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("API key service not initialized")
        }</span>
        <span class="cov0" title="0">return a.apiKeyService.GenerateApiKey(ctx, userID, name, scopes, expiresAt)</span>
}

// ValidateApiKey validates an API key
func (a *AuthenticationService) ValidateApiKey(ctx context.Context, key string) (*domain.ApiKey, error) <span class="cov1" title="1">{
        if a.apiKeyService == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("API key service not initialized")
        }</span>
        <span class="cov0" title="0">return a.apiKeyService.ValidateApiKey(ctx, key)</span>
}

// IsRateLimited checks if a user/IP is rate limited
func (a *AuthenticationService) IsRateLimited(ctx context.Context, email, ipAddress string) (bool, error) <span class="cov0" title="0">{
        return a.rateLimitService.IsRateLimited(ctx, email, ipAddress)
}</span>

// RecordLoginAttempt records a login attempt
func (a *AuthenticationService) RecordLoginAttempt(ctx context.Context, email, ipAddress, userAgent string, success bool, failureReason string) error <span class="cov0" title="0">{
        return a.rateLimitService.RecordLoginAttempt(ctx, email, ipAddress, userAgent, success, failureReason)
}</span>

// AuditAction records an audit log entry
func (a *AuthenticationService) AuditAction(ctx context.Context, userID *uuid.UUID, action, resource string, resourceID *uuid.UUID, oldValues, newValues map[string]interface{}, ipAddress, userAgent string) error <span class="cov0" title="0">{
        return a.auditService.AuditAction(ctx, userID, action, resource, resourceID, oldValues, newValues, ipAddress, userAgent)
}</span>

// Additional AuthenticationService methods to implement the AuthService interface

// Register registers a new user
func (a *AuthenticationService) Register(ctx context.Context, user *domain.User, password string) error <span class="cov0" title="0">{
        // Check if service dependencies are available
        if a.passwordService == nil </span><span class="cov0" title="0">{
                return errors.New("password service not available")
        }</span>
        
        // Hash the password
        <span class="cov0" title="0">hashedPassword, err := a.passwordService.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to hash password")
        }</span>

        <span class="cov0" title="0">user.PasswordHash = hashedPassword

        // Create user
        if err := a.authRepo.CreateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create user")
        }</span>

        // Assign default role (if exists)
        <span class="cov0" title="0">defaultRole, err := a.authRepo.GetRoleByName(ctx, "user")
        if err == nil </span><span class="cov0" title="0">{
                _ = a.authRepo.AssignRoleToUser(ctx, user.ID, defaultRole.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateUser creates a new user
func (a *AuthenticationService) CreateUser(ctx context.Context, user *domain.User, password string) error <span class="cov0" title="0">{
        return a.Register(ctx, user, password)
}</span>

// GetUser retrieves a user by ID
func (a *AuthenticationService) GetUser(ctx context.Context, id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        return a.authRepo.GetUserByID(ctx, id)
}</span>

// GetUserByEmail retrieves a user by email
func (a *AuthenticationService) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        return a.authRepo.GetUserByEmail(ctx, email)
}</span>

// UpdateUser updates a user
func (a *AuthenticationService) UpdateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return a.authRepo.UpdateUser(ctx, user)
}</span>

// DeleteUser deletes a user
func (a *AuthenticationService) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.DeleteUser(ctx, id)
}</span>

// ListUsers lists users with pagination
func (a *AuthenticationService) ListUsers(ctx context.Context, limit, offset int) ([]domain.User, error) <span class="cov0" title="0">{
        return a.authRepo.ListUsers(ctx, limit, offset)
}</span>

// ChangePassword changes a user's password
func (a *AuthenticationService) ChangePassword(ctx context.Context, userID uuid.UUID, oldPassword, newPassword string) error <span class="cov0" title="0">{
        // Get user
        user, err := a.authRepo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "user not found")
        }</span>

        // Verify old password
        <span class="cov0" title="0">if err := a.passwordService.ComparePassword(user.PasswordHash, oldPassword); err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid old password")
        }</span>

        // Hash new password
        <span class="cov0" title="0">hashedPassword, err := a.passwordService.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to hash new password")
        }</span>

        // Update password
        <span class="cov0" title="0">user.PasswordHash = hashedPassword
        user.UpdatedAt = time.Now()

        return a.authRepo.UpdateUser(ctx, user)</span>
}

// ResetPassword resets a user's password
func (a *AuthenticationService) ResetPassword(ctx context.Context, email string) error <span class="cov0" title="0">{
        // This is a placeholder implementation
        // In a real implementation, you would:
        // 1. Generate a reset token
        // 2. Store it in the database
        // 3. Send an email with the reset link

        user, err := a.authRepo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "user not found")
        }</span>

        // Generate new password (placeholder)
        <span class="cov0" title="0">newPassword, err := a.passwordService.GenerateRandomPassword(12)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to generate password")
        }</span>

        // Hash password
        <span class="cov0" title="0">hashedPassword, err := a.passwordService.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to hash password")
        }</span>

        // Update password
        <span class="cov0" title="0">user.PasswordHash = hashedPassword
        user.UpdatedAt = time.Now()

        return a.authRepo.UpdateUser(ctx, user)</span>
}

// VerifyEmail verifies a user's email
func (a *AuthenticationService) VerifyEmail(ctx context.Context, token string) error <span class="cov0" title="0">{
        // This is a placeholder implementation
        // In a real implementation, you would:
        // 1. Validate the verification token
        // 2. Mark the user as verified
        return errors.New("not implemented")
}</span>

// Role management methods

// CreateRole creates a new role
func (a *AuthenticationService) CreateRole(ctx context.Context, role *domain.Role) error <span class="cov0" title="0">{
        return a.authRepo.CreateRole(ctx, role)
}</span>

// GetRole retrieves a role by ID
func (a *AuthenticationService) GetRole(ctx context.Context, id uuid.UUID) (*domain.Role, error) <span class="cov0" title="0">{
        return a.authRepo.GetRoleByID(ctx, id)
}</span>

// UpdateRole updates a role
func (a *AuthenticationService) UpdateRole(ctx context.Context, role *domain.Role) error <span class="cov0" title="0">{
        return a.authRepo.UpdateRole(ctx, role)
}</span>

// DeleteRole deletes a role
func (a *AuthenticationService) DeleteRole(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.DeleteRole(ctx, id)
}</span>

// ListRoles lists roles with pagination
func (a *AuthenticationService) ListRoles(ctx context.Context, limit, offset int) ([]domain.Role, error) <span class="cov0" title="0">{
        return a.authRepo.ListRoles(ctx, limit, offset)
}</span>

// Permission management methods

// CreatePermission creates a new permission
func (a *AuthenticationService) CreatePermission(ctx context.Context, permission *domain.Permission) error <span class="cov0" title="0">{
        return a.authRepo.CreatePermission(ctx, permission)
}</span>

// GetPermission retrieves a permission by ID
func (a *AuthenticationService) GetPermission(ctx context.Context, id uuid.UUID) (*domain.Permission, error) <span class="cov0" title="0">{
        return a.authRepo.GetPermissionByID(ctx, id)
}</span>

// UpdatePermission updates a permission
func (a *AuthenticationService) UpdatePermission(ctx context.Context, permission *domain.Permission) error <span class="cov0" title="0">{
        return a.authRepo.UpdatePermission(ctx, permission)
}</span>

// DeletePermission deletes a permission
func (a *AuthenticationService) DeletePermission(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.DeletePermission(ctx, id)
}</span>

// ListPermissions lists permissions with pagination
func (a *AuthenticationService) ListPermissions(ctx context.Context, limit, offset int) ([]domain.Permission, error) <span class="cov0" title="0">{
        return a.authRepo.ListPermissions(ctx, limit, offset)
}</span>

// RBAC methods

// AssignRole assigns a role to a user
func (a *AuthenticationService) AssignRole(ctx context.Context, userID, roleID uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.AssignRoleToUser(ctx, userID, roleID)
}</span>

// RemoveRole removes a role from a user
func (a *AuthenticationService) RemoveRole(ctx context.Context, userID, roleID uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.RemoveRoleFromUser(ctx, userID, roleID)
}</span>

// AssignPermission assigns a permission to a role
func (a *AuthenticationService) AssignPermission(ctx context.Context, roleID, permissionID uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.AssignPermissionToRole(ctx, roleID, permissionID)
}</span>

// RemovePermission removes a permission from a role
func (a *AuthenticationService) RemovePermission(ctx context.Context, roleID, permissionID uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.RemovePermissionFromRole(ctx, roleID, permissionID)
}</span>

// GetUserPermissions retrieves all permissions for a user
func (a *AuthenticationService) GetUserPermissions(ctx context.Context, userID uuid.UUID) ([]domain.Permission, error) <span class="cov0" title="0">{
        return a.authRepo.GetUserPermissions(ctx, userID)
}</span>

// DeleteApiKey deletes an API key
func (a *AuthenticationService) DeleteApiKey(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return a.authRepo.DeleteApiKey(ctx, id)
}</span>

// ListApiKeys lists API keys for a user
func (a *AuthenticationService) ListApiKeys(ctx context.Context, userID uuid.UUID, limit, offset int) ([]domain.ApiKey, error) <span class="cov0" title="0">{
        return a.authRepo.ListApiKeys(ctx, userID, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// CacheService provides caching functionality
type CacheService struct {
        client *redis.Client
        logger interface{}
}

// NewCacheService creates a new cache service
func NewCacheService(client *redis.Client, logger interface{}) *CacheService <span class="cov0" title="0">{
        return &amp;CacheService{
                client: client,
                logger: logger,
        }
}</span>

// Get retrieves a value from cache
func (c *CacheService) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        val, err := c.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get from cache: %w", err)
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Set stores a value in cache with expiration
func (c *CacheService) Set(ctx context.Context, key string, value string, expiration time.Duration) error <span class="cov0" title="0">{
        err := c.client.Set(ctx, key, value, expiration).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set cache: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete removes a value from cache
func (c *CacheService) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := c.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete from cache: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in cache
func (c *CacheService) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        exists, err := c.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check existence: %w", err)
        }</span>
        <span class="cov0" title="0">return exists &gt; 0, nil</span>
}

// SetJSON stores a JSON object in cache
func (c *CacheService) SetJSON(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return c.Set(ctx, key, string(data), expiration)</span>
}

// GetJSON retrieves and unmarshals a JSON object from cache
func (c *CacheService) GetJSON(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        val, err := c.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal([]byte(val), dest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Expire sets expiration for a key
func (c *CacheService) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov0" title="0">{
        err := c.client.Expire(ctx, key, expiration).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set expiration: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TTL returns the remaining time to live for a key
func (c *CacheService) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov0" title="0">{
        ttl, err := c.client.TTL(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get TTL: %w", err)
        }</span>
        <span class="cov0" title="0">return ttl, nil</span>
}

// Clear removes all keys matching a pattern
func (c *CacheService) Clear(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        iter := c.client.Scan(ctx, 0, pattern, 0).Iterator()
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                if err := c.client.Del(ctx, iter.Val()).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete key %s: %w", iter.Val(), err)
                }</span>
        }
        <span class="cov0" title="0">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan keys: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ping checks if cache is accessible
func (c *CacheService) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return c.client.Ping(ctx).Err()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// CircuitState represents the state of a circuit breaker
type CircuitState int32

const (
        // StateClosed - Circuit is closed, requests are allowed
        StateClosed CircuitState = iota
        // StateOpen - Circuit is open, requests are rejected
        StateOpen
        // StateHalfOpen - Circuit is half-open, limited requests are allowed
        StateHalfOpen
)

// String returns the string representation of the circuit state
func (s CircuitState) String() string <span class="cov4" title="14">{
        switch s </span>{
        case StateClosed:<span class="cov4" title="9">
                return "CLOSED"</span>
        case StateOpen:<span class="cov2" title="3">
                return "OPEN"</span>
        case StateHalfOpen:<span class="cov1" title="1">
                return "HALF_OPEN"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// CircuitBreakerError represents errors from the circuit breaker
type CircuitBreakerError struct {
        State   CircuitState
        Message string
}

func (e *CircuitBreakerError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("circuit breaker %s: %s", e.State, e.Message)
}</span>

// IsCircuitBreakerError checks if an error is a circuit breaker error
func IsCircuitBreakerError(err error) bool <span class="cov9" title="279">{
        _, ok := err.(*CircuitBreakerError)
        return ok
}</span>

// CircuitBreakerConfig holds configuration for circuit breaker
type CircuitBreakerConfig struct {
        // Name of the circuit breaker
        Name string `json:"name"`

        // Failure threshold configuration
        FailureThreshold    uint32 `json:"failure_threshold"`     // Number of failures before opening
        SuccessThreshold    uint32 `json:"success_threshold"`     // Number of successes before closing
        ConsecutiveFailures uint32 `json:"consecutive_failures"`  // Consecutive failures before opening
        MinimumRequestCount uint32 `json:"minimum_request_count"` // Minimum requests before evaluating

        // Timeout configuration
        RequestTimeout  time.Duration `json:"request_timeout"`   // Individual request timeout
        OpenTimeout     time.Duration `json:"open_timeout"`      // Time to wait before half-open
        HalfOpenTimeout time.Duration `json:"half_open_timeout"` // Time to wait in half-open state

        // Window configuration
        WindowSize    time.Duration `json:"window_size"`    // Size of the sliding window
        WindowBuckets int           `json:"window_buckets"` // Number of buckets in the window

        // Retry configuration
        MaxRetries         int           `json:"max_retries"`          // Maximum retry attempts
        RetryDelay         time.Duration `json:"retry_delay"`          // Delay between retries
        RetryBackoffFactor float64       `json:"retry_backoff_factor"` // Exponential backoff factor

        // Behavior configuration
        FailFast       bool `json:"fail_fast"`       // Fail immediately when open
        EnableFallback bool `json:"enable_fallback"` // Enable fallback mechanisms
        EnableMetrics  bool `json:"enable_metrics"`  // Enable metrics collection
        EnableLogging  bool `json:"enable_logging"`  // Enable detailed logging

        // Health check configuration
        HealthCheckInterval time.Duration `json:"health_check_interval"` // Health check interval
        HealthCheckTimeout  time.Duration `json:"health_check_timeout"`  // Health check timeout
        EnableHealthCheck   bool          `json:"enable_health_check"`   // Enable health checks
}

// DefaultCircuitBreakerConfig returns default circuit breaker configuration
func DefaultCircuitBreakerConfig() *CircuitBreakerConfig <span class="cov3" title="5">{
        return &amp;CircuitBreakerConfig{
                Name:                "default",
                FailureThreshold:    5,
                SuccessThreshold:    3,
                ConsecutiveFailures: 3,
                MinimumRequestCount: 10,
                RequestTimeout:      30 * time.Second,
                OpenTimeout:         60 * time.Second,
                HalfOpenTimeout:     30 * time.Second,
                WindowSize:          60 * time.Second,
                WindowBuckets:       10,
                MaxRetries:          3,
                RetryDelay:          1 * time.Second,
                RetryBackoffFactor:  2.0,
                FailFast:            true,
                EnableFallback:      true,
                EnableMetrics:       true,
                EnableLogging:       true,
                HealthCheckInterval: 30 * time.Second,
                HealthCheckTimeout:  5 * time.Second,
                EnableHealthCheck:   true,
        }
}</span>

// CircuitBreakerMetrics holds metrics for circuit breaker operations
type CircuitBreakerMetrics struct {
        // Request statistics
        TotalRequests   uint64 `json:"total_requests"`
        TotalSuccesses  uint64 `json:"total_successes"`
        TotalFailures   uint64 `json:"total_failures"`
        TotalTimeouts   uint64 `json:"total_timeouts"`
        TotalRejections uint64 `json:"total_rejections"`

        // State statistics
        StateTransitions uint64 `json:"state_transitions"`
        TimesOpened      uint64 `json:"times_opened"`
        TimesClosed      uint64 `json:"times_closed"`
        TimesHalfOpened  uint64 `json:"times_half_opened"`

        // Timing statistics
        AverageResponseTime time.Duration `json:"average_response_time"`
        MaxResponseTime     time.Duration `json:"max_response_time"`
        MinResponseTime     time.Duration `json:"min_response_time"`

        // Current state
        CurrentState    CircuitState `json:"current_state"`
        LastStateChange time.Time    `json:"last_state_change"`
        LastFailure     time.Time    `json:"last_failure"`
        LastSuccess     time.Time    `json:"last_success"`

        // Rates
        SuccessRate float64 `json:"success_rate"`
        FailureRate float64 `json:"failure_rate"`

        // Fallback statistics
        FallbackExecutions uint64 `json:"fallback_executions"`
        FallbackSuccesses  uint64 `json:"fallback_successes"`
        FallbackFailures   uint64 `json:"fallback_failures"`
}

// SlidingWindow represents a sliding window for tracking requests
type SlidingWindow struct {
        buckets    []WindowBucket
        size       time.Duration
        bucketSize time.Duration
        currentIdx int
        mu         sync.RWMutex
}

// WindowBucket represents a time bucket in the sliding window
type WindowBucket struct {
        timestamp time.Time
        requests  uint64
        successes uint64
        failures  uint64
        timeouts  uint64
}

// NewSlidingWindow creates a new sliding window
func NewSlidingWindow(size time.Duration, bucketCount int) *SlidingWindow <span class="cov7" title="72">{
        bucketSize := size / time.Duration(bucketCount)
        buckets := make([]WindowBucket, bucketCount)

        now := time.Now()
        for i := range buckets </span><span class="cov10" title="564">{
                buckets[i] = WindowBucket{
                        timestamp: now.Add(-size + time.Duration(i)*bucketSize),
                }
        }</span>

        <span class="cov7" title="72">return &amp;SlidingWindow{
                buckets:    buckets,
                size:       size,
                bucketSize: bucketSize,
                currentIdx: 0,
        }</span>
}

// Record records a request result in the sliding window
func (w *SlidingWindow) Record(success bool, timeout bool) <span class="cov8" title="151">{
        w.mu.Lock()
        defer w.mu.Unlock()

        now := time.Now()

        // Update current bucket or create new one if needed
        if now.Sub(w.buckets[w.currentIdx].timestamp) &gt;= w.bucketSize </span><span class="cov5" title="25">{
                w.currentIdx = (w.currentIdx + 1) % len(w.buckets)
                w.buckets[w.currentIdx] = WindowBucket{
                        timestamp: now,
                }
        }</span>

        <span class="cov8" title="151">bucket := &amp;w.buckets[w.currentIdx]
        bucket.requests++

        if timeout </span><span class="cov1" title="2">{
                bucket.timeouts++
        }</span> else<span class="cov8" title="149"> if success </span><span class="cov7" title="134">{
                bucket.successes++
        }</span> else<span class="cov4" title="15"> {
                bucket.failures++
        }</span>
}

// GetStats returns current statistics from the sliding window
func (w *SlidingWindow) GetStats() (requests, successes, failures, timeouts uint64) <span class="cov4" title="15">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        now := time.Now()
        cutoff := now.Add(-w.size)

        for _, bucket := range w.buckets </span><span class="cov7" title="120">{
                if bucket.timestamp.After(cutoff) </span><span class="cov7" title="106">{
                        requests += bucket.requests
                        successes += bucket.successes
                        failures += bucket.failures
                        timeouts += bucket.timeouts
                }</span>
        }

        <span class="cov4" title="15">return</span>
}

// FallbackFunc represents a fallback function
type FallbackFunc func(ctx context.Context, err error) (interface{}, error)

// HealthCheckFunc represents a health check function
type HealthCheckFunc func(ctx context.Context) error

// CircuitBreaker implements the circuit breaker pattern
type CircuitBreaker struct {
        config      *CircuitBreakerConfig
        state       int32 // atomic: CircuitState
        window      *SlidingWindow
        metrics     *CircuitBreakerMetrics
        fallback    FallbackFunc
        healthCheck HealthCheckFunc
        logger      *logger.Logger

        // State management
        lastStateChange      time.Time
        consecutiveFailures  uint32
        consecutiveSuccesses uint32
        halfOpenRequests     uint32

        // Synchronization
        mu      sync.RWMutex
        stateMu sync.Mutex

        // Background processes
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(config *CircuitBreakerConfig, logger *logger.Logger) *CircuitBreaker <span class="cov6" title="62">{
        if config == nil </span><span class="cov1" title="1">{
                config = DefaultCircuitBreakerConfig()
        }</span>

        <span class="cov6" title="62">ctx, cancel := context.WithCancel(context.Background())

        cb := &amp;CircuitBreaker{
                config: config,
                state:  int32(StateClosed),
                window: NewSlidingWindow(config.WindowSize, config.WindowBuckets),
                metrics: &amp;CircuitBreakerMetrics{
                        CurrentState:    StateClosed,
                        LastStateChange: time.Now(),
                        MinResponseTime: time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
                },
                logger:          logger,
                lastStateChange: time.Now(),
                ctx:             ctx,
                cancel:          cancel,
        }

        // Start background processes
        if config.EnableHealthCheck </span><span class="cov5" title="33">{
                cb.wg.Add(1)
                go cb.healthCheckLoop()
        }</span>

        <span class="cov6" title="62">if config.EnableMetrics </span><span class="cov6" title="46">{
                cb.wg.Add(1)
                go cb.metricsLoop()
        }</span>

        <span class="cov6" title="62">return cb</span>
}

// Close closes the circuit breaker and stops background processes
func (cb *CircuitBreaker) Close() <span class="cov6" title="57">{
        cb.cancel()
        cb.wg.Wait()
}</span>

// Execute executes a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(ctx context.Context, fn func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov7" title="118">{
        return cb.ExecuteWithFallback(ctx, fn, cb.fallback)
}</span>

// ExecuteWithFallback executes a function with circuit breaker protection and fallback
func (cb *CircuitBreaker) ExecuteWithFallback(ctx context.Context, fn func(ctx context.Context) (interface{}, error), fallback FallbackFunc) (interface{}, error) <span class="cov8" title="147">{
        startTime := time.Now()

        // Check if we can execute the request
        if err := cb.canExecute(); err != nil </span><span class="cov1" title="1">{
                cb.recordRejection()

                // Try fallback if available
                if fallback != nil &amp;&amp; cb.config.EnableFallback </span><span class="cov0" title="0">{
                        return cb.executeFallback(ctx, fallback, err)
                }</span>

                <span class="cov1" title="1">return nil, err</span>
        }

        // Create timeout context
        <span class="cov8" title="146">timeoutCtx := ctx
        if cb.config.RequestTimeout &gt; 0 </span><span class="cov8" title="146">{
                var cancel context.CancelFunc
                timeoutCtx, cancel = context.WithTimeout(ctx, cb.config.RequestTimeout)
                defer cancel()
        }</span>

        // Execute the function
        <span class="cov8" title="146">result, err := cb.executeWithRetry(timeoutCtx, fn)

        // Record the result
        duration := time.Since(startTime)
        cb.recordResult(err, duration)

        // If execution failed and fallback is available, try fallback
        if err != nil &amp;&amp; fallback != nil &amp;&amp; cb.config.EnableFallback </span><span class="cov4" title="9">{
                return cb.executeFallback(ctx, fallback, err)
        }</span>

        <span class="cov7" title="137">return result, err</span>
}

// canExecute checks if a request can be executed based on circuit breaker state
func (cb *CircuitBreaker) canExecute() error <span class="cov8" title="147">{
        state := CircuitState(atomic.LoadInt32(&amp;cb.state))

        switch state </span>{
        case StateClosed:<span class="cov8" title="140">
                return nil</span>
        case StateOpen:<span class="cov1" title="2">
                // Check if we should transition to half-open
                if cb.shouldTransitionToHalfOpen() </span><span class="cov1" title="1">{
                        cb.transitionToHalfOpen()
                        return nil
                }</span>
                <span class="cov1" title="1">return &amp;CircuitBreakerError{
                        State:   StateOpen,
                        Message: "circuit breaker is open",
                }</span>
        case StateHalfOpen:<span class="cov3" title="5">
                // Allow limited requests in half-open state
                if atomic.LoadUint32(&amp;cb.halfOpenRequests) &lt; cb.config.SuccessThreshold </span><span class="cov3" title="5">{
                        atomic.AddUint32(&amp;cb.halfOpenRequests, 1)
                        return nil
                }</span>
                <span class="cov0" title="0">return &amp;CircuitBreakerError{
                        State:   StateHalfOpen,
                        Message: "circuit breaker is half-open and at capacity",
                }</span>
        default:<span class="cov0" title="0">
                return &amp;CircuitBreakerError{
                        State:   state,
                        Message: "unknown circuit breaker state",
                }</span>
        }
}

// executeWithRetry executes a function with retry logic
func (cb *CircuitBreaker) executeWithRetry(ctx context.Context, fn func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov8" title="146">{
        var lastErr error
        retryDelay := cb.config.RetryDelay

        for attempt := 0; attempt &lt;= cb.config.MaxRetries; attempt++ </span><span class="cov8" title="165">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="165"></span>
                }

                // Execute the function
                <span class="cov8" title="165">result, err := fn(ctx)

                // If successful, return immediately
                if err == nil </span><span class="cov7" title="132">{
                        return result, nil
                }</span>

                <span class="cov5" title="33">lastErr = err

                // Don't retry on the last attempt
                if attempt == cb.config.MaxRetries </span><span class="cov4" title="14">{
                        break</span>
                }

                // Check if error is retryable
                <span class="cov5" title="19">if !cb.isRetryableError(err) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Wait before retry
                <span class="cov5" title="19">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(retryDelay):<span class="cov5" title="19"></span>
                }

                // Exponential backoff
                <span class="cov5" title="19">retryDelay = time.Duration(float64(retryDelay) * cb.config.RetryBackoffFactor)</span>
        }

        <span class="cov4" title="14">return nil, lastErr</span>
}

// executeFallback executes the fallback function
func (cb *CircuitBreaker) executeFallback(ctx context.Context, fallback FallbackFunc, originalErr error) (interface{}, error) <span class="cov4" title="9">{
        atomic.AddUint64(&amp;cb.metrics.FallbackExecutions, 1)

        result, err := fallback(ctx, originalErr)

        if err != nil </span><span class="cov3" title="7">{
                atomic.AddUint64(&amp;cb.metrics.FallbackFailures, 1)
        }</span> else<span class="cov1" title="2"> {
                atomic.AddUint64(&amp;cb.metrics.FallbackSuccesses, 1)
        }</span>

        <span class="cov4" title="9">return result, err</span>
}

// recordResult records the result of an operation
func (cb *CircuitBreaker) recordResult(err error, duration time.Duration) <span class="cov8" title="146">{
        isTimeout := cb.isTimeoutError(err)
        isSuccess := err == nil

        // Record in sliding window
        cb.window.Record(isSuccess, isTimeout)

        // Update metrics
        cb.updateMetrics(isSuccess, isTimeout, duration)

        // Update state based on result
        if isSuccess </span><span class="cov7" title="132">{
                cb.recordSuccess()
        }</span> else<span class="cov4" title="14"> {
                cb.recordFailure()
        }</span>
}

// recordSuccess records a successful operation
func (cb *CircuitBreaker) recordSuccess() <span class="cov7" title="134">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        atomic.AddUint64(&amp;cb.metrics.TotalSuccesses, 1)
        cb.metrics.LastSuccess = time.Now()

        // Reset consecutive failures
        atomic.StoreUint32(&amp;cb.consecutiveFailures, 0)

        // Increment consecutive successes
        successCount := atomic.AddUint32(&amp;cb.consecutiveSuccesses, 1)

        // Check if we should close the circuit
        state := CircuitState(atomic.LoadInt32(&amp;cb.state))
        if state == StateHalfOpen &amp;&amp; successCount &gt;= cb.config.SuccessThreshold </span><span class="cov2" title="3">{
                cb.transitionToClosed()
        }</span>
}

// recordFailure records a failed operation
func (cb *CircuitBreaker) recordFailure() <span class="cov4" title="16">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        atomic.AddUint64(&amp;cb.metrics.TotalFailures, 1)
        cb.metrics.LastFailure = time.Now()

        // Reset consecutive successes
        atomic.StoreUint32(&amp;cb.consecutiveSuccesses, 0)

        // Increment consecutive failures
        failureCount := atomic.AddUint32(&amp;cb.consecutiveFailures, 1)

        // Check if we should open the circuit
        state := CircuitState(atomic.LoadInt32(&amp;cb.state))
        if (state == StateClosed || state == StateHalfOpen) &amp;&amp; cb.shouldOpen(failureCount) </span><span class="cov3" title="8">{
                cb.transitionToOpen()
        }</span>
}

// recordRejection records a rejected request
func (cb *CircuitBreaker) recordRejection() <span class="cov2" title="4">{
        atomic.AddUint64(&amp;cb.metrics.TotalRejections, 1)
}</span>

// shouldOpen determines if the circuit should open
func (cb *CircuitBreaker) shouldOpen(consecutiveFailures uint32) bool <span class="cov4" title="16">{
        // Check consecutive failures
        if consecutiveFailures &gt;= cb.config.ConsecutiveFailures </span><span class="cov2" title="3">{
                return true
        }</span>

        // Check failure rate in sliding window
        <span class="cov4" title="13">requests, _, failures, timeouts := cb.window.GetStats()

        // Need minimum requests to evaluate
        if requests &lt; uint64(cb.config.MinimumRequestCount) </span><span class="cov3" title="7">{
                return false
        }</span>

        // Calculate failure rate
        <span class="cov3" title="6">totalFailures := failures + timeouts
        failureRate := float64(totalFailures) / float64(requests) * 100

        // Check if failure rate exceeds threshold
        return totalFailures &gt;= uint64(cb.config.FailureThreshold) || failureRate &gt; 50.0</span>
}

// shouldTransitionToHalfOpen determines if the circuit should transition to half-open
func (cb *CircuitBreaker) shouldTransitionToHalfOpen() bool <span class="cov1" title="2">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        return time.Since(cb.lastStateChange) &gt;= cb.config.OpenTimeout
}</span>

// State transition methods

// transitionToOpen transitions the circuit to open state
func (cb *CircuitBreaker) transitionToOpen() <span class="cov4" title="16">{
        cb.stateMu.Lock()
        defer cb.stateMu.Unlock()

        if CircuitState(atomic.LoadInt32(&amp;cb.state)) == StateOpen </span><span class="cov0" title="0">{
                return // Already open
        }</span>

        <span class="cov4" title="16">atomic.StoreInt32(&amp;cb.state, int32(StateOpen))
        cb.lastStateChange = time.Now()

        // Update metrics
        cb.metrics.CurrentState = StateOpen
        cb.metrics.LastStateChange = cb.lastStateChange
        atomic.AddUint64(&amp;cb.metrics.StateTransitions, 1)
        atomic.AddUint64(&amp;cb.metrics.TimesOpened, 1)

        if cb.config.EnableLogging </span><span class="cov3" title="6">{
                cb.logger.Warn("Circuit breaker opened",
                        "name", cb.config.Name,
                        "consecutive_failures", atomic.LoadUint32(&amp;cb.consecutiveFailures),
                )
        }</span>
}

// transitionToHalfOpen transitions the circuit to half-open state
func (cb *CircuitBreaker) transitionToHalfOpen() <span class="cov2" title="4">{
        cb.stateMu.Lock()
        defer cb.stateMu.Unlock()

        if CircuitState(atomic.LoadInt32(&amp;cb.state)) == StateHalfOpen </span><span class="cov0" title="0">{
                return // Already half-open
        }</span>

        <span class="cov2" title="4">atomic.StoreInt32(&amp;cb.state, int32(StateHalfOpen))
        atomic.StoreUint32(&amp;cb.halfOpenRequests, 0)
        cb.lastStateChange = time.Now()

        // Update metrics
        cb.metrics.CurrentState = StateHalfOpen
        cb.metrics.LastStateChange = cb.lastStateChange
        atomic.AddUint64(&amp;cb.metrics.StateTransitions, 1)
        atomic.AddUint64(&amp;cb.metrics.TimesHalfOpened, 1)

        if cb.config.EnableLogging </span><span class="cov0" title="0">{
                cb.logger.Info("Circuit breaker transitioned to half-open",
                        "name", cb.config.Name,
                )
        }</span>
}

// transitionToClosed transitions the circuit to closed state
func (cb *CircuitBreaker) transitionToClosed() <span class="cov2" title="4">{
        cb.stateMu.Lock()
        defer cb.stateMu.Unlock()

        if CircuitState(atomic.LoadInt32(&amp;cb.state)) == StateClosed </span><span class="cov0" title="0">{
                return // Already closed
        }</span>

        <span class="cov2" title="4">atomic.StoreInt32(&amp;cb.state, int32(StateClosed))
        atomic.StoreUint32(&amp;cb.consecutiveFailures, 0)
        atomic.StoreUint32(&amp;cb.consecutiveSuccesses, 0)
        atomic.StoreUint32(&amp;cb.halfOpenRequests, 0)
        cb.lastStateChange = time.Now()

        // Update metrics
        cb.metrics.CurrentState = StateClosed
        cb.metrics.LastStateChange = cb.lastStateChange
        atomic.AddUint64(&amp;cb.metrics.StateTransitions, 1)
        atomic.AddUint64(&amp;cb.metrics.TimesClosed, 1)

        if cb.config.EnableLogging </span><span class="cov0" title="0">{
                cb.logger.Info("Circuit breaker closed",
                        "name", cb.config.Name,
                )
        }</span>
}

// updateMetrics updates circuit breaker metrics
func (cb *CircuitBreaker) updateMetrics(success, timeout bool, duration time.Duration) <span class="cov8" title="146">{
        atomic.AddUint64(&amp;cb.metrics.TotalRequests, 1)

        if timeout </span><span class="cov1" title="1">{
                atomic.AddUint64(&amp;cb.metrics.TotalTimeouts, 1)
        }</span>

        // Update timing metrics
        <span class="cov8" title="146">cb.mu.Lock()
        defer cb.mu.Unlock()

        if duration &lt; cb.metrics.MinResponseTime </span><span class="cov6" title="36">{
                cb.metrics.MinResponseTime = duration
        }</span>

        <span class="cov8" title="146">if duration &gt; cb.metrics.MaxResponseTime </span><span class="cov5" title="26">{
                cb.metrics.MaxResponseTime = duration
        }</span>

        // Update average response time (simple moving average)
        <span class="cov8" title="146">if cb.metrics.AverageResponseTime == 0 </span><span class="cov5" title="18">{
                cb.metrics.AverageResponseTime = duration
        }</span> else<span class="cov7" title="128"> {
                cb.metrics.AverageResponseTime = (cb.metrics.AverageResponseTime + duration) / 2
        }</span>

        // Update success/failure rates
        <span class="cov8" title="146">totalRequests := atomic.LoadUint64(&amp;cb.metrics.TotalRequests)
        if totalRequests &gt; 0 </span><span class="cov8" title="146">{
                cb.metrics.SuccessRate = float64(atomic.LoadUint64(&amp;cb.metrics.TotalSuccesses)) / float64(totalRequests) * 100
                cb.metrics.FailureRate = float64(atomic.LoadUint64(&amp;cb.metrics.TotalFailures)) / float64(totalRequests) * 100
        }</span>
}

// isRetryableError determines if an error is retryable
func (cb *CircuitBreaker) isRetryableError(err error) bool <span class="cov5" title="23">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Don't retry circuit breaker errors
        <span class="cov5" title="23">if IsCircuitBreakerError(err) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Don't retry context cancellation errors
        <span class="cov5" title="22">if err == context.Canceled || err == context.DeadlineExceeded </span><span class="cov1" title="2">{
                return false
        }</span>

        // By default, retry other errors
        <span class="cov5" title="20">return true</span>
}

// isTimeoutError determines if an error is a timeout error
func (cb *CircuitBreaker) isTimeoutError(err error) bool <span class="cov8" title="149">{
        if err == nil </span><span class="cov7" title="133">{
                return false
        }</span>

        <span class="cov4" title="16">return err == context.DeadlineExceeded</span>
}

// Background processes

// healthCheckLoop runs periodic health checks
func (cb *CircuitBreaker) healthCheckLoop() <span class="cov5" title="33">{
        defer cb.wg.Done()

        if cb.healthCheck == nil </span><span class="cov5" title="32">{
                return
        }</span>

        <span class="cov1" title="1">ticker := time.NewTicker(cb.config.HealthCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov2" title="3">{
                select </span>{
                case &lt;-cb.ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov1" title="2">
                        cb.performHealthCheck()</span>
                }
        }
}

// performHealthCheck performs a health check
func (cb *CircuitBreaker) performHealthCheck() <span class="cov1" title="2">{
        if cb.healthCheck == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="2">ctx, cancel := context.WithTimeout(context.Background(), cb.config.HealthCheckTimeout)
        defer cancel()

        err := cb.healthCheck(ctx)
        state := CircuitState(atomic.LoadInt32(&amp;cb.state))

        if err != nil </span><span class="cov0" title="0">{
                if cb.config.EnableLogging </span><span class="cov0" title="0">{
                        cb.logger.Error("Health check failed",
                                "name", cb.config.Name,
                                "state", state,
                                "error", err,
                        )
                }</span>

                // If health check fails in closed state, consider opening
                <span class="cov0" title="0">if state == StateClosed </span><span class="cov0" title="0">{
                        cb.recordFailure()
                }</span>
        } else<span class="cov1" title="2"> {
                if cb.config.EnableLogging </span><span class="cov0" title="0">{
                        cb.logger.Debug("Health check passed",
                                "name", cb.config.Name,
                                "state", state,
                        )
                }</span>

                // If health check passes in open state, consider half-opening
                <span class="cov1" title="2">if state == StateOpen &amp;&amp; cb.shouldTransitionToHalfOpen() </span><span class="cov0" title="0">{
                        cb.transitionToHalfOpen()
                }</span>
        }
}

// metricsLoop runs periodic metrics collection
func (cb *CircuitBreaker) metricsLoop() <span class="cov6" title="46">{
        defer cb.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov6" title="46">{
                select </span>{
                case &lt;-cb.ctx.Done():<span class="cov6" title="41">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cb.logMetrics()</span>
                }
        }
}

// logMetrics logs current metrics
func (cb *CircuitBreaker) logMetrics() <span class="cov0" title="0">{
        if !cb.config.EnableLogging </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">metrics := cb.GetMetrics()

        cb.logger.Info("Circuit breaker metrics",
                "name", cb.config.Name,
                "state", metrics.CurrentState,
                "total_requests", metrics.TotalRequests,
                "total_successes", metrics.TotalSuccesses,
                "total_failures", metrics.TotalFailures,
                "total_timeouts", metrics.TotalTimeouts,
                "total_rejections", metrics.TotalRejections,
                "success_rate", fmt.Sprintf("%.2f%%", metrics.SuccessRate),
                "failure_rate", fmt.Sprintf("%.2f%%", metrics.FailureRate),
                "average_response_time", metrics.AverageResponseTime,
                "fallback_executions", metrics.FallbackExecutions,
        )</span>
}

// Public API methods

// GetState returns the current state of the circuit breaker
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov6" title="61">{
        return CircuitState(atomic.LoadInt32(&amp;cb.state))
}</span>

// GetMetrics returns current metrics
func (cb *CircuitBreaker) GetMetrics() *CircuitBreakerMetrics <span class="cov5" title="22">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := &amp;CircuitBreakerMetrics{
                TotalRequests:       atomic.LoadUint64(&amp;cb.metrics.TotalRequests),
                TotalSuccesses:      atomic.LoadUint64(&amp;cb.metrics.TotalSuccesses),
                TotalFailures:       atomic.LoadUint64(&amp;cb.metrics.TotalFailures),
                TotalTimeouts:       atomic.LoadUint64(&amp;cb.metrics.TotalTimeouts),
                TotalRejections:     atomic.LoadUint64(&amp;cb.metrics.TotalRejections),
                StateTransitions:    atomic.LoadUint64(&amp;cb.metrics.StateTransitions),
                TimesOpened:         atomic.LoadUint64(&amp;cb.metrics.TimesOpened),
                TimesClosed:         atomic.LoadUint64(&amp;cb.metrics.TimesClosed),
                TimesHalfOpened:     atomic.LoadUint64(&amp;cb.metrics.TimesHalfOpened),
                AverageResponseTime: cb.metrics.AverageResponseTime,
                MaxResponseTime:     cb.metrics.MaxResponseTime,
                MinResponseTime:     cb.metrics.MinResponseTime,
                CurrentState:        cb.metrics.CurrentState,
                LastStateChange:     cb.metrics.LastStateChange,
                LastFailure:         cb.metrics.LastFailure,
                LastSuccess:         cb.metrics.LastSuccess,
                SuccessRate:         cb.metrics.SuccessRate,
                FailureRate:         cb.metrics.FailureRate,
                FallbackExecutions:  atomic.LoadUint64(&amp;cb.metrics.FallbackExecutions),
                FallbackSuccesses:   atomic.LoadUint64(&amp;cb.metrics.FallbackSuccesses),
                FallbackFailures:    atomic.LoadUint64(&amp;cb.metrics.FallbackFailures),
        }

        return metrics
}</span>

// SetFallback sets the fallback function
func (cb *CircuitBreaker) SetFallback(fallback FallbackFunc) <span class="cov1" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.fallback = fallback
}</span>

// SetHealthCheck sets the health check function
func (cb *CircuitBreaker) SetHealthCheck(healthCheck HealthCheckFunc) <span class="cov2" title="4">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.healthCheck = healthCheck
}</span>

// ForceOpen forces the circuit breaker to open state
func (cb *CircuitBreaker) ForceOpen() <span class="cov3" title="8">{
        cb.transitionToOpen()
}</span>

// ForceClose forces the circuit breaker to closed state
func (cb *CircuitBreaker) ForceClose() <span class="cov1" title="1">{
        cb.transitionToClosed()
}</span>

// ForceHalfOpen forces the circuit breaker to half-open state
func (cb *CircuitBreaker) ForceHalfOpen() <span class="cov2" title="3">{
        cb.transitionToHalfOpen()
}</span>

// Reset resets the circuit breaker to its initial state
func (cb *CircuitBreaker) Reset() <span class="cov3" title="7">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        atomic.StoreInt32(&amp;cb.state, int32(StateClosed))
        atomic.StoreUint32(&amp;cb.consecutiveFailures, 0)
        atomic.StoreUint32(&amp;cb.consecutiveSuccesses, 0)
        atomic.StoreUint32(&amp;cb.halfOpenRequests, 0)
        cb.lastStateChange = time.Now()

        // Reset metrics
        cb.metrics = &amp;CircuitBreakerMetrics{
                CurrentState:    StateClosed,
                LastStateChange: time.Now(),
                MinResponseTime: time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
        }

        // Reset sliding window
        cb.window = NewSlidingWindow(cb.config.WindowSize, cb.config.WindowBuckets)

        if cb.config.EnableLogging </span><span class="cov3" title="6">{
                cb.logger.Info("Circuit breaker reset", "name", cb.config.Name)
        }</span>
}

// IsOpen returns true if the circuit breaker is open
func (cb *CircuitBreaker) IsOpen() bool <span class="cov5" title="30">{
        return cb.GetState() == StateOpen
}</span>

// IsClosed returns true if the circuit breaker is closed
func (cb *CircuitBreaker) IsClosed() bool <span class="cov1" title="2">{
        return cb.GetState() == StateClosed
}</span>

// IsHalfOpen returns true if the circuit breaker is half-open
func (cb *CircuitBreaker) IsHalfOpen() bool <span class="cov1" title="2">{
        return cb.GetState() == StateHalfOpen
}</span>

// GetName returns the name of the circuit breaker
func (cb *CircuitBreaker) GetName() string <span class="cov2" title="4">{
        return cb.config.Name
}</span>

// GetConfig returns the circuit breaker configuration
func (cb *CircuitBreaker) GetConfig() *CircuitBreakerConfig <span class="cov1" title="1">{
        return cb.config
}</span>

// Service-specific circuit breaker implementations

// S3CircuitBreaker creates a circuit breaker for S3 operations
func NewS3CircuitBreaker(logger *logger.Logger) *CircuitBreaker <span class="cov4" title="14">{
        config := &amp;CircuitBreakerConfig{
                Name:                "s3",
                FailureThreshold:    5,
                SuccessThreshold:    3,
                ConsecutiveFailures: 3,
                MinimumRequestCount: 10,
                RequestTimeout:      30 * time.Second,
                OpenTimeout:         60 * time.Second,
                HalfOpenTimeout:     30 * time.Second,
                WindowSize:          60 * time.Second,
                WindowBuckets:       10,
                MaxRetries:          3,
                RetryDelay:          1 * time.Second,
                RetryBackoffFactor:  2.0,
                FailFast:            true,
                EnableFallback:      true,
                EnableMetrics:       true,
                EnableLogging:       true,
                HealthCheckInterval: 30 * time.Second,
                HealthCheckTimeout:  5 * time.Second,
                EnableHealthCheck:   false, // S3 doesn't have a simple health check
        }

        return NewCircuitBreaker(config, logger)
}</span>

// DatabaseCircuitBreaker creates a circuit breaker for database operations
func NewDatabaseCircuitBreaker(logger *logger.Logger) *CircuitBreaker <span class="cov4" title="15">{
        config := &amp;CircuitBreakerConfig{
                Name:                "database",
                FailureThreshold:    3,
                SuccessThreshold:    2,
                ConsecutiveFailures: 2,
                MinimumRequestCount: 5,
                RequestTimeout:      10 * time.Second,
                OpenTimeout:         30 * time.Second,
                HalfOpenTimeout:     15 * time.Second,
                WindowSize:          30 * time.Second,
                WindowBuckets:       6,
                MaxRetries:          2,
                RetryDelay:          500 * time.Millisecond,
                RetryBackoffFactor:  2.0,
                FailFast:            true,
                EnableFallback:      true,
                EnableMetrics:       true,
                EnableLogging:       true,
                HealthCheckInterval: 15 * time.Second,
                HealthCheckTimeout:  3 * time.Second,
                EnableHealthCheck:   true,
        }

        return NewCircuitBreaker(config, logger)
}</span>

// CacheCircuitBreaker creates a circuit breaker for cache operations
func NewCacheCircuitBreaker(logger *logger.Logger) *CircuitBreaker <span class="cov4" title="13">{
        config := &amp;CircuitBreakerConfig{
                Name:                "cache",
                FailureThreshold:    10,
                SuccessThreshold:    5,
                ConsecutiveFailures: 5,
                MinimumRequestCount: 20,
                RequestTimeout:      5 * time.Second,
                OpenTimeout:         15 * time.Second,
                HalfOpenTimeout:     10 * time.Second,
                WindowSize:          30 * time.Second,
                WindowBuckets:       6,
                MaxRetries:          1,
                RetryDelay:          100 * time.Millisecond,
                RetryBackoffFactor:  1.5,
                FailFast:            false, // Cache failures are less critical
                EnableFallback:      true,
                EnableMetrics:       true,
                EnableLogging:       true,
                HealthCheckInterval: 10 * time.Second,
                HealthCheckTimeout:  2 * time.Second,
                EnableHealthCheck:   true,
        }

        return NewCircuitBreaker(config, logger)
}</span>

// CircuitBreakerManager manages multiple circuit breakers
type CircuitBreakerManager struct {
        breakers map[string]*CircuitBreaker
        mu       sync.RWMutex
        logger   *logger.Logger
}

// NewCircuitBreakerManager creates a new circuit breaker manager
func NewCircuitBreakerManager(logger *logger.Logger) *CircuitBreakerManager <span class="cov4" title="12">{
        return &amp;CircuitBreakerManager{
                breakers: make(map[string]*CircuitBreaker),
                logger:   logger,
        }
}</span>

// AddCircuitBreaker adds a circuit breaker to the manager
func (m *CircuitBreakerManager) AddCircuitBreaker(name string, breaker *CircuitBreaker) <span class="cov6" title="36">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.breakers[name] = breaker
}</span>

// GetCircuitBreaker returns a circuit breaker by name
func (m *CircuitBreakerManager) GetCircuitBreaker(name string) (*CircuitBreaker, bool) <span class="cov4" title="11">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        breaker, exists := m.breakers[name]
        return breaker, exists
}</span>

// GetAllCircuitBreakers returns all circuit breakers
func (m *CircuitBreakerManager) GetAllCircuitBreakers() map[string]*CircuitBreaker <span class="cov3" title="6">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]*CircuitBreaker)
        for name, breaker := range m.breakers </span><span class="cov5" title="18">{
                result[name] = breaker
        }</span>

        <span class="cov3" title="6">return result</span>
}

// Close closes all circuit breakers
func (m *CircuitBreakerManager) Close() <span class="cov4" title="12">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, breaker := range m.breakers </span><span class="cov6" title="36">{
                breaker.Close()
        }</span>
}

// GetMetrics returns metrics for all circuit breakers
func (m *CircuitBreakerManager) GetMetrics() map[string]*CircuitBreakerMetrics <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        metrics := make(map[string]*CircuitBreakerMetrics)
        for name, breaker := range m.breakers </span><span class="cov2" title="3">{
                metrics[name] = breaker.GetMetrics()
        }</span>

        <span class="cov1" title="1">return metrics</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
        "github.com/redis/go-redis/v9"
        "gorm.io/gorm"
)

// CircuitBreakerIntegration provides integration with circuit breakers for various services
type CircuitBreakerIntegration struct {
        manager      *CircuitBreakerManager
        dbBreaker    *CircuitBreaker
        cacheBreaker *CircuitBreaker
        s3Breaker    *CircuitBreaker
        logger       *logger.Logger
}

// NewCircuitBreakerIntegration creates a new circuit breaker integration
func NewCircuitBreakerIntegration(logger *logger.Logger) *CircuitBreakerIntegration <span class="cov10" title="11">{
        manager := NewCircuitBreakerManager(logger)

        // Create service-specific circuit breakers
        dbBreaker := NewDatabaseCircuitBreaker(logger)
        cacheBreaker := NewCacheCircuitBreaker(logger)
        s3Breaker := NewS3CircuitBreaker(logger)

        // Add circuit breakers to manager
        manager.AddCircuitBreaker("database", dbBreaker)
        manager.AddCircuitBreaker("cache", cacheBreaker)
        manager.AddCircuitBreaker("s3", s3Breaker)

        return &amp;CircuitBreakerIntegration{
                manager:      manager,
                dbBreaker:    dbBreaker,
                cacheBreaker: cacheBreaker,
                s3Breaker:    s3Breaker,
                logger:       logger,
        }
}</span>

// SetupHealthChecks sets up health check functions for all circuit breakers
func (i *CircuitBreakerIntegration) SetupHealthChecks(db *gorm.DB, redisClient *redis.Client) <span class="cov3" title="2">{
        // Database health check
        if db != nil </span><span class="cov1" title="1">{
                i.dbBreaker.SetHealthCheck(func(ctx context.Context) error </span><span class="cov0" title="0">{
                        sqlDB, err := db.DB()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
                        defer cancel()

                        return sqlDB.PingContext(ctx)</span>
                })
        }

        // Cache health check
        <span class="cov3" title="2">if redisClient != nil </span><span class="cov1" title="1">{
                i.cacheBreaker.SetHealthCheck(func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return redisClient.Ping(ctx).Err()
                }</span>)
        }

        // S3 health check is not set up as it doesn't have a simple ping operation
}

// DatabaseWrapper wraps database operations with circuit breaker protection
type DatabaseWrapper struct {
        db      *gorm.DB
        breaker *CircuitBreaker
        logger  *logger.Logger
}

// NewDatabaseWrapper creates a new database wrapper with circuit breaker
func (i *CircuitBreakerIntegration) NewDatabaseWrapper(db *gorm.DB) *DatabaseWrapper <span class="cov5" title="3">{
        return &amp;DatabaseWrapper{
                db:      db,
                breaker: i.dbBreaker,
                logger:  i.logger,
        }
}</span>

// ExecuteQuery executes a database query with circuit breaker protection
func (w *DatabaseWrapper) ExecuteQuery(ctx context.Context, queryFunc func(*gorm.DB) error) error <span class="cov9" title="9">{
        _, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov10" title="11">{
                // Add context to the database session
                dbWithCtx := w.db.WithContext(ctx)

                // Execute the query
                return nil, queryFunc(dbWithCtx)
        }</span>, w.createDatabaseFallback())

        <span class="cov9" title="9">return err</span>
}

// ExecuteTransaction executes a database transaction with circuit breaker protection
func (w *DatabaseWrapper) ExecuteTransaction(ctx context.Context, txFunc func(*gorm.DB) error) error <span class="cov3" title="2">{
        _, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov6" title="4">{
                // Start transaction with context
                tx := w.db.WithContext(ctx).Begin()
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return nil, tx.Error
                }</span>

                // Execute transaction function
                <span class="cov6" title="4">if err := txFunc(tx); err != nil </span><span class="cov5" title="3">{
                        tx.Rollback()
                        return nil, err
                }</span>

                // Commit transaction
                <span class="cov1" title="1">return nil, tx.Commit().Error</span>
        }, w.createDatabaseFallback())

        <span class="cov3" title="2">return err</span>
}

// FindWithFallback executes a find query with circuit breaker protection
func (w *DatabaseWrapper) FindWithFallback(ctx context.Context, dest interface{}, where ...interface{}) error <span class="cov5" title="3">{
        return w.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov5" title="3">{
                return db.Find(dest, where...).Error
        }</span>)
}

// CreateWithFallback executes a create operation with circuit breaker protection
func (w *DatabaseWrapper) CreateWithFallback(ctx context.Context, value interface{}) error <span class="cov1" title="1">{
        return w.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov1" title="1">{
                return db.Create(value).Error
        }</span>)
}

// UpdateWithFallback executes an update operation with circuit breaker protection
func (w *DatabaseWrapper) UpdateWithFallback(ctx context.Context, value interface{}) error <span class="cov1" title="1">{
        return w.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov1" title="1">{
                return db.Save(value).Error
        }</span>)
}

// DeleteWithFallback executes a delete operation with circuit breaker protection
func (w *DatabaseWrapper) DeleteWithFallback(ctx context.Context, value interface{}, where ...interface{}) error <span class="cov1" title="1">{
        return w.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov1" title="1">{
                return db.Delete(value, where...).Error
        }</span>)
}

// createDatabaseFallback creates a fallback function for database operations
func (w *DatabaseWrapper) createDatabaseFallback() FallbackFunc <span class="cov10" title="11">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov3" title="2">{
                w.logger.Warn("Database operation failed, using fallback",
                        "error", err,
                        "circuit_state", w.breaker.GetState(),
                )

                // In a real application, this might return cached data or default values
                // For now, we'll return a specific error indicating fallback was used
                return nil, &amp;DatabaseCircuitBreakerError{
                        OriginalError: err,
                        Message:       "Database circuit breaker is open, operation failed",
                }
        }</span>
}

// CacheWrapper wraps cache operations with circuit breaker protection
type CacheWrapper struct {
        client  *redis.Client
        breaker *CircuitBreaker
        logger  *logger.Logger
}

// NewCacheWrapper creates a new cache wrapper with circuit breaker
func (i *CircuitBreakerIntegration) NewCacheWrapper(client *redis.Client) *CacheWrapper <span class="cov1" title="1">{
        return &amp;CacheWrapper{
                client:  client,
                breaker: i.cacheBreaker,
                logger:  i.logger,
        }
}</span>

// Get executes a cache get operation with circuit breaker protection
func (w *CacheWrapper) Get(ctx context.Context, key string) (string, error) <span class="cov3" title="2">{
        result, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov5" title="3">{
                return w.client.Get(ctx, key).Result()
        }</span>, w.createCacheFallback())

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="2">if result == nil </span><span class="cov1" title="1">{
                return "", redis.Nil
        }</span>

        <span class="cov1" title="1">return result.(string), nil</span>
}

// Set executes a cache set operation with circuit breaker protection
func (w *CacheWrapper) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov1" title="1">{
        _, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov1" title="1">{
                return nil, w.client.Set(ctx, key, value, expiration).Err()
        }</span>, w.createCacheFallback())

        <span class="cov1" title="1">return err</span>
}

// Del executes a cache delete operation with circuit breaker protection
func (w *CacheWrapper) Del(ctx context.Context, keys ...string) error <span class="cov1" title="1">{
        _, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov1" title="1">{
                return nil, w.client.Del(ctx, keys...).Err()
        }</span>, w.createCacheFallback())

        <span class="cov1" title="1">return err</span>
}

// HGet executes a hash get operation with circuit breaker protection
func (w *CacheWrapper) HGet(ctx context.Context, key, field string) (string, error) <span class="cov1" title="1">{
        result, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov1" title="1">{
                return w.client.HGet(ctx, key, field).Result()
        }</span>, w.createCacheFallback())

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">if result == nil </span><span class="cov0" title="0">{
                return "", redis.Nil
        }</span>

        <span class="cov1" title="1">return result.(string), nil</span>
}

// HSet executes a hash set operation with circuit breaker protection
func (w *CacheWrapper) HSet(ctx context.Context, key string, values ...interface{}) error <span class="cov1" title="1">{
        _, err := w.breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov1" title="1">{
                return nil, w.client.HSet(ctx, key, values...).Err()
        }</span>, w.createCacheFallback())

        <span class="cov1" title="1">return err</span>
}

// createCacheFallback creates a fallback function for cache operations
func (w *CacheWrapper) createCacheFallback() FallbackFunc <span class="cov7" title="6">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov1" title="1">{
                w.logger.Info("Cache operation failed, continuing without cache",
                        "error", err,
                        "circuit_state", w.breaker.GetState(),
                )

                // For cache operations, we typically continue without cache
                // Return nil to indicate cache miss
                return nil, nil
        }</span>
}

// S3Wrapper wraps S3 operations with circuit breaker protection
type S3Wrapper struct {
        breaker *CircuitBreaker
        logger  *logger.Logger
}

// NewS3Wrapper creates a new S3 wrapper with circuit breaker
func (i *CircuitBreakerIntegration) NewS3Wrapper() *S3Wrapper <span class="cov3" title="2">{
        return &amp;S3Wrapper{
                breaker: i.s3Breaker,
                logger:  i.logger,
        }
}</span>

// ExecuteS3Operation executes an S3 operation with circuit breaker protection
func (w *S3Wrapper) ExecuteS3Operation(ctx context.Context, operation func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov9" title="10">{
        return w.breaker.ExecuteWithFallback(ctx, operation, w.createS3Fallback())
}</span>

// createS3Fallback creates a fallback function for S3 operations
func (w *S3Wrapper) createS3Fallback() FallbackFunc <span class="cov9" title="10">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov6" title="4">{
                w.logger.Warn("S3 operation failed",
                        "error", err,
                        "circuit_state", w.breaker.GetState(),
                )

                return nil, &amp;S3CircuitBreakerError{
                        OriginalError: err,
                        Message:       "S3 service is unavailable",
                }
        }</span>
}

// Custom error types for circuit breaker fallbacks

// DatabaseCircuitBreakerError represents a database circuit breaker error
type DatabaseCircuitBreakerError struct {
        OriginalError error
        Message       string
}

func (e *DatabaseCircuitBreakerError) Error() string <span class="cov6" title="4">{
        return fmt.Sprintf("database circuit breaker: %s (original: %v)", e.Message, e.OriginalError)
}</span>

// S3CircuitBreakerError represents an S3 circuit breaker error
type S3CircuitBreakerError struct {
        OriginalError error
        Message       string
}

func (e *S3CircuitBreakerError) Error() string <span class="cov5" title="3">{
        return fmt.Sprintf("s3 circuit breaker: %s (original: %v)", e.Message, e.OriginalError)
}</span>

// GetManager returns the circuit breaker manager
func (i *CircuitBreakerIntegration) GetManager() *CircuitBreakerManager <span class="cov7" title="5">{
        return i.manager
}</span>

// GetDatabaseBreaker returns the database circuit breaker
func (i *CircuitBreakerIntegration) GetDatabaseBreaker() *CircuitBreaker <span class="cov8" title="7">{
        return i.dbBreaker
}</span>

// GetCacheBreaker returns the cache circuit breaker
func (i *CircuitBreakerIntegration) GetCacheBreaker() *CircuitBreaker <span class="cov7" title="5">{
        return i.cacheBreaker
}</span>

// GetS3Breaker returns the S3 circuit breaker
func (i *CircuitBreakerIntegration) GetS3Breaker() *CircuitBreaker <span class="cov7" title="6">{
        return i.s3Breaker
}</span>

// Close closes all circuit breakers
func (i *CircuitBreakerIntegration) Close() <span class="cov10" title="11">{
        i.manager.Close()
}</span>

// GetHealthStatus returns the health status of all circuit breakers
func (i *CircuitBreakerIntegration) GetHealthStatus() map[string]interface{} <span class="cov5" title="3">{
        status := make(map[string]interface{})

        breakers := i.manager.GetAllCircuitBreakers()
        overallHealthy := true

        for name, breaker := range breakers </span><span class="cov9" title="9">{
                metrics := breaker.GetMetrics()

                isHealthy := !breaker.IsOpen()
                if !isHealthy </span><span class="cov1" title="1">{
                        overallHealthy = false
                }</span>

                <span class="cov9" title="9">status[name] = map[string]interface{}{
                        "healthy":        isHealthy,
                        "state":          metrics.CurrentState.String(),
                        "total_requests": metrics.TotalRequests,
                        "success_rate":   fmt.Sprintf("%.2f%%", metrics.SuccessRate),
                        "failure_rate":   fmt.Sprintf("%.2f%%", metrics.FailureRate),
                        "last_failure":   metrics.LastFailure,
                        "last_success":   metrics.LastSuccess,
                }</span>
        }

        <span class="cov5" title="3">status["overall_healthy"] = overallHealthy
        status["timestamp"] = time.Now().UTC()

        return status</span>
}

// ResetAllCircuitBreakers resets all circuit breakers to their initial state
func (i *CircuitBreakerIntegration) ResetAllCircuitBreakers() <span class="cov3" title="2">{
        breakers := i.manager.GetAllCircuitBreakers()

        for name, breaker := range breakers </span><span class="cov7" title="6">{
                breaker.Reset()
                i.logger.Info("Circuit breaker reset", "name", name)
        }</span>
}

// IsServiceAvailable checks if a service is available (circuit breaker is not open)
func (i *CircuitBreakerIntegration) IsServiceAvailable(serviceName string) bool <span class="cov7" title="5">{
        breaker, exists := i.manager.GetCircuitBreaker(serviceName)
        if !exists </span><span class="cov1" title="1">{
                return true // If no circuit breaker exists, assume service is available
        }</span>

        <span class="cov6" title="4">return !breaker.IsOpen()</span>
}

// IsDatabaseAvailable checks if the database is available
func (i *CircuitBreakerIntegration) IsDatabaseAvailable() bool <span class="cov5" title="3">{
        return !i.dbBreaker.IsOpen()
}</span>

// IsCacheAvailable checks if the cache is available
func (i *CircuitBreakerIntegration) IsCacheAvailable() bool <span class="cov3" title="2">{
        return !i.cacheBreaker.IsOpen()
}</span>

// IsS3Available checks if S3 is available
func (i *CircuitBreakerIntegration) IsS3Available() bool <span class="cov3" title="2">{
        return !i.s3Breaker.IsOpen()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/go-playground/validator/v10"
        "gopkg.in/yaml.v3"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// ConfigWatcher provides hot-reloading capabilities for configuration files and environment variables
type ConfigWatcher struct {
        mu        sync.RWMutex
        watcher   *fsnotify.Watcher
        validator *validator.Validate
        logger    monitoring.Logger
        ctx       context.Context
        cancel    context.CancelFunc

        // Configuration storage
        configs     map[string]interface{}
        configFiles map[string]string // config name -&gt; file path
        envVars     map[string]string // env var name -&gt; current value

        // Callbacks and notifications
        changeCallbacks map[string][]ConfigChangeCallback
        validators      map[string]ConfigValidator

        // History and rollback
        configHistory  map[string][]ConfigSnapshot
        maxHistorySize int

        // Metrics
        reloadCount    int64
        errorCount     int64
        lastReloadTime time.Time

        // Options
        options *ConfigWatcherOptions
}

// ConfigChangeCallback is called when configuration changes
type ConfigChangeCallback func(configName string, oldConfig, newConfig interface{}) error

// ConfigValidator validates configuration before applying changes
type ConfigValidator func(config interface{}) error

// ConfigSnapshot stores a configuration state for rollback
type ConfigSnapshot struct {
        Config    interface{} `json:"config"`
        Timestamp time.Time   `json:"timestamp"`
        Source    string      `json:"source"` // "file" or "env"
        Hash      string      `json:"hash"`
}

// ConfigWatcherOptions configures the behavior of ConfigWatcher
type ConfigWatcherOptions struct {
        // File watching
        WatchIntervalSec  int  `json:"watch_interval_sec" validate:"min=1"`
        FileChecksum      bool `json:"file_checksum"`
        IgnoreHiddenFiles bool `json:"ignore_hidden_files"`

        // Environment variable monitoring
        EnvCheckIntervalSec int    `json:"env_check_interval_sec" validate:"min=1"`
        EnvVarPrefix        string `json:"env_var_prefix"`

        // Validation and rollback
        ValidateOnLoad     bool `json:"validate_on_load"`
        EnableRollback     bool `json:"enable_rollback"`
        MaxHistorySize     int  `json:"max_history_size" validate:"min=1"`
        RollbackTimeoutSec int  `json:"rollback_timeout_sec" validate:"min=1"`

        // Error handling
        MaxRetries       int  `json:"max_retries" validate:"min=0"`
        RetryDelaySec    int  `json:"retry_delay_sec" validate:"min=1"`
        FailOnValidation bool `json:"fail_on_validation"`

        // Performance
        BatchUpdates    bool `json:"batch_updates"`
        BatchIntervalMs int  `json:"batch_interval_ms" validate:"min=100"`

        // Debugging
        EnableDebugLogging bool `json:"enable_debug_logging"`
        LogConfigChanges   bool `json:"log_config_changes"`
}

// DefaultConfigWatcherOptions returns sensible defaults
func DefaultConfigWatcherOptions() *ConfigWatcherOptions <span class="cov4" title="15">{
        return &amp;ConfigWatcherOptions{
                WatchIntervalSec:    1,
                FileChecksum:        true,
                IgnoreHiddenFiles:   true,
                EnvCheckIntervalSec: 30,
                EnvVarPrefix:        "APP_",
                ValidateOnLoad:      true,
                EnableRollback:      true,
                MaxHistorySize:      10,
                RollbackTimeoutSec:  30,
                MaxRetries:          3,
                RetryDelaySec:       5,
                FailOnValidation:    false,
                BatchUpdates:        true,
                BatchIntervalMs:     500,
                EnableDebugLogging:  false,
                LogConfigChanges:    true,
        }
}</span>

// NewConfigWatcher creates a new configuration watcher
func NewConfigWatcher(logger monitoring.Logger, options *ConfigWatcherOptions) (*ConfigWatcher, error) <span class="cov4" title="16">{
        if options == nil </span><span class="cov3" title="10">{
                options = DefaultConfigWatcherOptions()
        }</span>

        // Validate options
        <span class="cov4" title="16">validate := validator.New()
        if err := validate.Struct(options); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid options: %w", err)
        }</span>

        <span class="cov4" title="15">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov4" title="15">ctx, cancel := context.WithCancel(context.Background())

        cw := &amp;ConfigWatcher{
                watcher:         watcher,
                validator:       validate,
                logger:          logger,
                ctx:             ctx,
                cancel:          cancel,
                configs:         make(map[string]interface{}),
                configFiles:     make(map[string]string),
                envVars:         make(map[string]string),
                changeCallbacks: make(map[string][]ConfigChangeCallback),
                validators:      make(map[string]ConfigValidator),
                configHistory:   make(map[string][]ConfigSnapshot),
                maxHistorySize:  options.MaxHistorySize,
                options:         options,
        }

        // Start monitoring goroutines
        go cw.watchFiles()
        go cw.watchEnvironment()

        if options.BatchUpdates </span><span class="cov4" title="14">{
                go cw.batchProcessor()
        }</span>

        <span class="cov4" title="15">logger.Info("Configuration watcher started",
                "file_checksum", options.FileChecksum,
                "env_check_interval", options.EnvCheckIntervalSec,
                "rollback_enabled", options.EnableRollback)

        return cw, nil</span>
}

// RegisterConfig registers a configuration for monitoring
func (cw *ConfigWatcher) RegisterConfig(name string, config interface{}) error <span class="cov3" title="8">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if cw.options.ValidateOnLoad </span><span class="cov3" title="8">{
                if err := cw.validateConfig(name, config); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("config validation failed for %s: %w", name, err)
                }</span>
        }

        <span class="cov3" title="7">cw.configs[name] = config
        cw.addToHistory(name, config, "registration")

        cw.logger.Debug("Registered configuration", "name", name, "type", reflect.TypeOf(config))
        return nil</span>
}

// WatchFile starts watching a configuration file
func (cw *ConfigWatcher) WatchFile(configName, filePath string) error <span class="cov3" title="6">{
        // Resolve absolute path
        absPath, err := filepath.Abs(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve path %s: %w", filePath, err)
        }</span>

        // Check if file exists
        <span class="cov3" title="6">if _, err := os.Stat(absPath); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("file does not exist: %s", absPath)
        }</span>

        // Add to watcher
        <span class="cov3" title="5">if err := cw.watcher.Add(absPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to watch file %s: %w", absPath, err)
        }</span>

        // Also watch the directory for file recreations
        <span class="cov3" title="5">dir := filepath.Dir(absPath)
        if err := cw.watcher.Add(dir); err != nil </span><span class="cov0" title="0">{
                cw.logger.Warn("Failed to watch directory", "dir", dir, "error", err)
        }</span>

        // Update the configFiles map (needs lock)
        <span class="cov3" title="5">cw.mu.Lock()
        cw.configFiles[configName] = absPath
        cw.mu.Unlock()

        // Load initial configuration (this will acquire its own lock in updateConfig)
        if err := cw.loadFileConfig(configName, absPath); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to load initial config: %w", err)
        }</span>

        <span class="cov2" title="4">cw.logger.Info("Started watching configuration file",
                "config", configName,
                "file", absPath)

        return nil</span>
}

// WatchEnvVar starts monitoring an environment variable
func (cw *ConfigWatcher) WatchEnvVar(configName, envVarName string) error <span class="cov2" title="3">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        currentValue := os.Getenv(envVarName)
        cw.envVars[envVarName] = currentValue

        // Store mapping for updates
        key := fmt.Sprintf("env:%s", envVarName)
        if currentValue != "" </span><span class="cov1" title="2">{
                cw.configs[key] = currentValue
                cw.addToHistory(key, currentValue, "env")
        }</span>

        <span class="cov2" title="3">cw.logger.Info("Started watching environment variable",
                "config", configName,
                "env_var", envVarName,
                "has_value", currentValue != "")

        return nil</span>
}

// RegisterChangeCallback registers a callback for configuration changes
func (cw *ConfigWatcher) RegisterChangeCallback(configName string, callback ConfigChangeCallback) <span class="cov3" title="6">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        cw.changeCallbacks[configName] = append(cw.changeCallbacks[configName], callback)
        cw.logger.Debug("Registered change callback", "config", configName)
}</span>

// RegisterValidator registers a validator for a configuration
func (cw *ConfigWatcher) RegisterValidator(configName string, validator ConfigValidator) <span class="cov1" title="2">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        cw.validators[configName] = validator
        cw.logger.Debug("Registered validator", "config", configName)
}</span>

// GetConfig retrieves the current configuration
func (cw *ConfigWatcher) GetConfig(name string) (interface{}, bool) <span class="cov9" title="1011">{
        cw.mu.RLock()
        defer cw.mu.RUnlock()

        config, exists := cw.configs[name]
        return config, exists
}</span>

// GetConfigHistory returns the configuration history
func (cw *ConfigWatcher) GetConfigHistory(name string) []ConfigSnapshot <span class="cov2" title="3">{
        cw.mu.RLock()
        defer cw.mu.RUnlock()

        history := cw.configHistory[name]
        result := make([]ConfigSnapshot, len(history))
        copy(result, history)
        return result
}</span>

// RollbackConfig rolls back to a previous configuration
func (cw *ConfigWatcher) RollbackConfig(name string, targetHash string) error <span class="cov1" title="2">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if !cw.options.EnableRollback </span><span class="cov1" title="1">{
                return fmt.Errorf("rollback is disabled")
        }</span>

        <span class="cov1" title="1">history := cw.configHistory[name]
        if len(history) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no history available for config %s", name)
        }</span>

        <span class="cov1" title="1">var targetSnapshot *ConfigSnapshot
        for i := len(history) - 1; i &gt;= 0; i-- </span><span class="cov2" title="3">{
                if history[i].Hash == targetHash </span><span class="cov1" title="1">{
                        targetSnapshot = &amp;history[i]
                        break</span>
                }
        }

        <span class="cov1" title="1">if targetSnapshot == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration snapshot with hash %s not found", targetHash)
        }</span>

        // Validate the target configuration
        <span class="cov1" title="1">if err := cw.validateConfig(name, targetSnapshot.Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("target configuration is invalid: %w", err)
        }</span>

        <span class="cov1" title="1">cw.configs[name] = targetSnapshot.Config

        // Add rollback to history immediately
        cw.addToHistory(name, targetSnapshot.Config, fmt.Sprintf("rollback:%s", targetHash))

        cw.logger.Info("Configuration rolled back",
                "config", name,
                "target_hash", targetHash,
                "timestamp", targetSnapshot.Timestamp)

        // Note: We skip notifying callbacks during rollback to avoid deadlocks
        // and race conditions. Callbacks should be designed to handle configuration
        // changes gracefully without requiring notification during rollback.

        return nil</span>
}

// watchFiles monitors file system events
func (cw *ConfigWatcher) watchFiles() <span class="cov4" title="15">{
        defer cw.watcher.Close()

        for </span><span class="cov5" title="25">{
                select </span>{
                case &lt;-cw.ctx.Done():<span class="cov4" title="14">
                        return</span>

                case event, ok := &lt;-cw.watcher.Events:<span class="cov4" title="11">
                        if !ok </span><span class="cov1" title="1">{
                                return
                        }</span>

                        <span class="cov3" title="10">if cw.options.EnableDebugLogging </span><span class="cov0" title="0">{
                                cw.logger.Debug("File event received",
                                        "file", event.Name,
                                        "op", event.Op.String())
                        }</span>

                        // Skip hidden files if configured
                        <span class="cov3" title="10">if cw.options.IgnoreHiddenFiles &amp;&amp; filepath.Base(event.Name)[0] == '.' </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="10">cw.handleFileEvent(event)</span>

                case err, ok := &lt;-cw.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">cw.errorCount++
                        cw.logger.Error("File watcher error", "error", err)</span>
                }
        }
}

// handleFileEvent processes a file system event
func (cw *ConfigWatcher) handleFileEvent(event fsnotify.Event) <span class="cov3" title="10">{
        cw.mu.RLock()
        configName := ""
        for name, path := range cw.configFiles </span><span class="cov4" title="16">{
                if path == event.Name </span><span class="cov3" title="7">{
                        configName = name
                        break</span>
                }
        }
        <span class="cov3" title="10">cw.mu.RUnlock()

        if configName == "" </span><span class="cov2" title="3">{
                return // Not a watched config file
        }</span>

        // Handle different event types
        <span class="cov3" title="7">switch </span>{
        case event.Op&amp;fsnotify.Write == fsnotify.Write:<span class="cov1" title="1">
                cw.reloadFileConfig(configName, event.Name)</span>

        case event.Op&amp;fsnotify.Create == fsnotify.Create:<span class="cov1" title="1">
                cw.reloadFileConfig(configName, event.Name)</span>

        case event.Op&amp;fsnotify.Remove == fsnotify.Remove:<span class="cov2" title="4">
                cw.logger.Warn("Configuration file removed",
                        "config", configName,
                        "file", event.Name)</span>

        case event.Op&amp;fsnotify.Rename == fsnotify.Rename:<span class="cov0" title="0">
                cw.logger.Warn("Configuration file renamed",
                        "config", configName,
                        "file", event.Name)</span>
        }
}

// reloadFileConfig reloads configuration from file
func (cw *ConfigWatcher) reloadFileConfig(configName, filePath string) <span class="cov1" title="2">{
        if cw.options.EnableDebugLogging </span><span class="cov0" title="0">{
                cw.logger.Debug("Reloading file configuration",
                        "config", configName,
                        "file", filePath)
        }</span>

        <span class="cov1" title="2">var retries int
        for retries &lt; cw.options.MaxRetries </span><span class="cov1" title="2">{
                if err := cw.loadFileConfig(configName, filePath); err != nil </span><span class="cov0" title="0">{
                        retries++
                        cw.errorCount++
                        cw.logger.Error("Failed to reload configuration",
                                "config", configName,
                                "file", filePath,
                                "error", err,
                                "retry", retries)

                        if retries &lt; cw.options.MaxRetries </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(cw.options.RetryDelaySec) * time.Second)
                                continue</span>
                        }

                        <span class="cov0" title="0">cw.logger.Error("Max retries exceeded for configuration reload",
                                "config", configName,
                                "file", filePath)
                        return</span>
                }
                <span class="cov1" title="2">break</span>
        }

        <span class="cov1" title="2">cw.reloadCount++
        cw.lastReloadTime = time.Now()</span>
}

// loadFileConfig loads configuration from a file
func (cw *ConfigWatcher) loadFileConfig(configName, filePath string) error <span class="cov3" title="7">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Determine file format and parse
        <span class="cov3" title="7">var newConfig interface{}
        ext := filepath.Ext(filePath)

        switch ext </span>{
        case ".json":<span class="cov3" title="5">
                if err := json.Unmarshal(data, &amp;newConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse JSON: %w", err)
                }</span>

        case ".yaml", ".yml":<span class="cov1" title="1">
                if err := yaml.Unmarshal(data, &amp;newConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse YAML: %w", err)
                }</span>

        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported file format: %s", ext)</span>
        }

        <span class="cov3" title="6">return cw.updateConfig(configName, newConfig, "file")</span>
}

// watchEnvironment monitors environment variable changes
func (cw *ConfigWatcher) watchEnvironment() <span class="cov4" title="15">{
        ticker := time.NewTicker(time.Duration(cw.options.EnvCheckIntervalSec) * time.Second)
        defer ticker.Stop()

        for </span><span class="cov4" title="16">{
                select </span>{
                case &lt;-cw.ctx.Done():<span class="cov4" title="15">
                        return</span>

                case &lt;-ticker.C:<span class="cov1" title="1">
                        cw.checkEnvironmentChanges()</span>
                }
        }
}

// checkEnvironmentChanges checks for environment variable changes
func (cw *ConfigWatcher) checkEnvironmentChanges() <span class="cov1" title="1">{
        cw.mu.RLock()
        envVarsCopy := make(map[string]string)
        for k, v := range cw.envVars </span><span class="cov1" title="1">{
                envVarsCopy[k] = v
        }</span>
        <span class="cov1" title="1">cw.mu.RUnlock()

        for envVar, oldValue := range envVarsCopy </span><span class="cov1" title="1">{
                currentValue := os.Getenv(envVar)

                if currentValue != oldValue </span><span class="cov1" title="1">{
                        if cw.options.EnableDebugLogging </span><span class="cov0" title="0">{
                                cw.logger.Debug("Environment variable changed",
                                        "var", envVar,
                                        "old", oldValue,
                                        "new", currentValue)
                        }</span>

                        <span class="cov1" title="1">configName := fmt.Sprintf("env:%s", envVar)
                        // Update the env var tracking first to avoid deadlock
                        cw.mu.Lock()
                        cw.envVars[envVar] = currentValue
                        cw.mu.Unlock()

                        // Then update the config (this will acquire its own lock)
                        if err := cw.updateConfig(configName, currentValue, "env"); err != nil </span><span class="cov0" title="0">{
                                cw.logger.Error("Failed to update environment variable config",
                                        "var", envVar,
                                        "error", err)
                                // Revert the env var change on error
                                cw.mu.Lock()
                                cw.envVars[envVar] = oldValue
                                cw.mu.Unlock()
                        }</span>
                }
        }
}

// updateConfig updates a configuration and notifies callbacks
func (cw *ConfigWatcher) updateConfig(configName string, newConfig interface{}, source string) error <span class="cov9" title="1012">{
        cw.mu.Lock()

        oldConfig := cw.configs[configName]

        // Skip if configuration hasn't changed
        if reflect.DeepEqual(oldConfig, newConfig) </span><span class="cov0" title="0">{
                cw.mu.Unlock()
                return nil
        }</span>

        // Validate new configuration
        <span class="cov9" title="1012">if err := cw.validateConfig(configName, newConfig); err != nil </span><span class="cov1" title="1">{
                cw.mu.Unlock()
                if cw.options.FailOnValidation </span><span class="cov0" title="0">{
                        return fmt.Errorf("configuration validation failed: %w", err)
                }</span>
                <span class="cov1" title="1">cw.logger.Warn("Configuration validation failed, proceeding anyway",
                        "config", configName,
                        "error", err)
                // Continue with the update even if validation failed (but not failing on validation)
                cw.mu.Lock()</span>
        }

        // Update configuration
        <span class="cov9" title="1012">cw.configs[configName] = newConfig
        cw.addToHistory(configName, newConfig, source)

        // Notify callbacks (without holding the lock)
        cw.mu.Unlock()
        callbackErr := cw.notifyCallbacks(configName, oldConfig, newConfig)
        cw.mu.Lock()

        if callbackErr != nil </span><span class="cov1" title="1">{
                // Rollback on callback failure
                cw.configs[configName] = oldConfig
                cw.mu.Unlock()
                return fmt.Errorf("callback failed, configuration rolled back: %w", callbackErr)
        }</span>

        <span class="cov9" title="1011">if cw.options.LogConfigChanges </span><span class="cov9" title="1011">{
                cw.logger.Info("Configuration updated",
                        "config", configName,
                        "source", source)
        }</span>

        <span class="cov9" title="1011">cw.mu.Unlock()

        return nil</span>
}

// validateConfig validates a configuration
func (cw *ConfigWatcher) validateConfig(configName string, config interface{}) error <span class="cov9" title="1021">{
        // Handle nil config
        if config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config is nil")
        }</span>

        // Only run struct validation if the config is actually a struct
        // Skip struct validation for maps (they will be validated by custom validators)
        <span class="cov9" title="1021">configType := reflect.TypeOf(config)
        if configType != nil &amp;&amp; configType.Kind() == reflect.Struct </span><span class="cov2" title="3">{
                if err := cw.validator.Struct(config); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        // Custom validator (this is the main validation for map-based configs)
        <span class="cov9" title="1020">if validator, exists := cw.validators[configName]; exists </span><span class="cov1" title="2">{
                if err := validator(config); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov9" title="1019">return nil</span>
}

// notifyCallbacks notifies all registered callbacks
func (cw *ConfigWatcher) notifyCallbacks(configName string, oldConfig, newConfig interface{}) error <span class="cov9" title="1012">{
        cw.mu.RLock()
        callbacks := cw.changeCallbacks[configName]
        cw.mu.RUnlock()

        for _, callback := range callbacks </span><span class="cov3" title="6">{
                if err := callback(configName, oldConfig, newConfig); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov9" title="1011">return nil</span>
}

// addToHistory adds a configuration to history
func (cw *ConfigWatcher) addToHistory(configName string, config interface{}, source string) <span class="cov10" title="1022">{
        snapshot := ConfigSnapshot{
                Config:    config,
                Timestamp: time.Now(),
                Source:    source,
                Hash:      cw.generateConfigHash(config),
        }

        history := cw.configHistory[configName]
        history = append(history, snapshot)

        // Limit history size
        if len(history) &gt; cw.maxHistorySize </span><span class="cov9" title="991">{
                history = history[len(history)-cw.maxHistorySize:]
        }</span>

        <span class="cov10" title="1022">cw.configHistory[configName] = history</span>
}

// generateConfigHash generates a hash for configuration deduplication
func (cw *ConfigWatcher) generateConfigHash(config interface{}) string <span class="cov10" title="1022">{
        data, _ := json.Marshal(config)
        hexStr := fmt.Sprintf("%x", data)
        // Use the full hex string to ensure uniqueness, but limit to reasonable length
        if len(hexStr) &gt; 64 </span><span class="cov3" title="8">{
                return hexStr[:64] // Use first 64 chars for very long configs
        }</span>
        <span class="cov9" title="1014">return hexStr</span> // Use full hex string for better uniqueness
}

// batchProcessor handles batched configuration updates
func (cw *ConfigWatcher) batchProcessor() <span class="cov4" title="14">{
        ticker := time.NewTicker(time.Duration(cw.options.BatchIntervalMs) * time.Millisecond)
        defer ticker.Stop()

        pendingUpdates := make(map[string]interface{})

        for </span><span class="cov4" title="16">{
                select </span>{
                case &lt;-cw.ctx.Done():<span class="cov4" title="14">
                        return</span>

                case &lt;-ticker.C:<span class="cov1" title="2">
                        if len(pendingUpdates) &gt; 0 </span><span class="cov0" title="0">{
                                cw.processBatchUpdates(pendingUpdates)
                                pendingUpdates = make(map[string]interface{})
                        }</span>
                }
        }
}

// processBatchUpdates processes batched configuration updates
func (cw *ConfigWatcher) processBatchUpdates(updates map[string]interface{}) <span class="cov0" title="0">{
        for configName, config := range updates </span><span class="cov0" title="0">{
                if err := cw.updateConfig(configName, config, "batch"); err != nil </span><span class="cov0" title="0">{
                        cw.logger.Error("Failed to process batched update",
                                "config", configName,
                                "error", err)
                }</span>
        }
}

// GetMetrics returns watcher metrics
func (cw *ConfigWatcher) GetMetrics() map[string]interface{} <span class="cov1" title="1">{
        cw.mu.RLock()
        defer cw.mu.RUnlock()

        return map[string]interface{}{
                "reload_count":       cw.reloadCount,
                "error_count":        cw.errorCount,
                "last_reload_time":   cw.lastReloadTime,
                "watched_files":      len(cw.configFiles),
                "watched_env_vars":   len(cw.envVars),
                "registered_configs": len(cw.configs),
                "total_callbacks":    cw.getTotalCallbacks(),
                "history_entries":    cw.getTotalHistoryEntries(),
        }
}</span>

// getTotalCallbacks returns total number of registered callbacks
func (cw *ConfigWatcher) getTotalCallbacks() int <span class="cov1" title="1">{
        total := 0
        for _, callbacks := range cw.changeCallbacks </span><span class="cov1" title="1">{
                total += len(callbacks)
        }</span>
        <span class="cov1" title="1">return total</span>
}

// getTotalHistoryEntries returns total number of history entries
func (cw *ConfigWatcher) getTotalHistoryEntries() int <span class="cov1" title="1">{
        total := 0
        for _, history := range cw.configHistory </span><span class="cov1" title="2">{
                total += len(history)
        }</span>
        <span class="cov1" title="1">return total</span>
}

// Stop gracefully stops the configuration watcher
func (cw *ConfigWatcher) Stop() error <span class="cov4" title="15">{
        cw.logger.Info("Stopping configuration watcher")

        cw.cancel()

        if cw.watcher != nil </span><span class="cov4" title="15">{
                return cw.watcher.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Health check for configuration watcher
func (cw *ConfigWatcher) HealthCheck() error <span class="cov1" title="2">{
        cw.mu.RLock()
        defer cw.mu.RUnlock()

        // Check if watcher is still running
        select </span>{
        case &lt;-cw.ctx.Done():<span class="cov1" title="1">
                return fmt.Errorf("configuration watcher is stopped")</span>
        default:<span class="cov1" title="1"></span>
        }

        // Check for excessive errors
        <span class="cov1" title="1">if cw.errorCount &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration watcher has too many errors: %d", cw.errorCount)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package infrastructure

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

// Database represents the database connection wrapper
type Database struct {
        DB     *gorm.DB
        config *config.DatabaseConfig
        logger *logger.Logger
}

// NewDatabase creates a new database connection
func NewDatabase(cfg *config.DatabaseConfig, log *logger.Logger) (*Database, error) <span class="cov0" title="0">{
        db := &amp;Database{
                config: cfg,
                logger: log,
        }

        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// connect establishes the database connection with retry logic
func (d *Database) connect() error <span class="cov0" title="0">{
        dsn := d.buildDSN()

        var gormDB *gorm.DB
        var err error

        maxRetries := 5
        retryDelay := 2 * time.Second

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                gormDB, err = d.attemptConnection(dsn)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">d.logger.Warn("Database connection failed, retrying...",
                        "attempt", i+1,
                        "max_retries", maxRetries,
                        "error", err,
                )

                if i &lt; maxRetries-1 </span><span class="cov0" title="0">{
                        time.Sleep(retryDelay)
                        retryDelay *= 2 // Exponential backoff
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect after %d attempts: %w", maxRetries, err)
        }</span>

        <span class="cov0" title="0">d.DB = gormDB

        // Configure connection pool
        if err := d.configureConnectionPool(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure connection pool: %w", err)
        }</span>

        <span class="cov0" title="0">d.logger.Info("Database connection established successfully",
                "host", d.config.Host,
                "port", d.config.Port,
                "database", d.config.Name,
        )

        return nil</span>
}

// attemptConnection attempts to establish a database connection
func (d *Database) attemptConnection(dsn string) (*gorm.DB, error) <span class="cov0" title="0">{
        // Configure GORM logger
        gormLogLevel := d.getGormLogLevel()
        gormConfig := &amp;gorm.Config{
                Logger: gormLogger.New(
                        log.New(os.Stdout, "\r\n", log.LstdFlags),
                        gormLogger.Config{
                                SlowThreshold:             200 * time.Millisecond,
                                LogLevel:                  gormLogLevel,
                                IgnoreRecordNotFoundError: true,
                                Colorful:                  false,
                        },
                ),
                NowFunc: func() time.Time </span><span class="cov0" title="0">{
                        return time.Now().UTC()
                }</span>,
                PrepareStmt:                              true,
                DisableForeignKeyConstraintWhenMigrating: false,
        }

        <span class="cov0" title="0">return gorm.Open(postgres.Open(dsn), gormConfig)</span>
}

// buildDSN builds the database connection string
func (d *Database) buildDSN() string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "host=%s user=%s password=%s dbname=%s port=%d sslmode=%s TimeZone=%s",
                d.config.Host,
                d.config.User,
                d.config.Password,
                d.config.Name,
                d.config.Port,
                d.config.SSLMode,
                d.config.TimeZone,
        )
}</span>

// configureConnectionPool configures the database connection pool
func (d *Database) configureConnectionPool() error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(d.config.MaxOpenConns)
        sqlDB.SetMaxIdleConns(d.config.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(d.config.ConnMaxLifetime)
        sqlDB.SetConnMaxIdleTime(d.config.ConnMaxIdleTime)

        d.logger.Info("Database connection pool configured",
                "max_open_conns", d.config.MaxOpenConns,
                "max_idle_conns", d.config.MaxIdleConns,
                "conn_max_lifetime", d.config.ConnMaxLifetime,
                "conn_max_idle_time", d.config.ConnMaxIdleTime,
        )

        return nil</span>
}

// getGormLogLevel converts string log level to GORM log level
func (d *Database) getGormLogLevel() gormLogger.LogLevel <span class="cov5" title="5">{
        switch d.config.LogLevel </span>{
        case "debug":<span class="cov1" title="1">
                return gormLogger.Info</span>
        case "info":<span class="cov1" title="1">
                return gormLogger.Warn</span>
        case "warn":<span class="cov1" title="1">
                return gormLogger.Warn</span>
        case "error":<span class="cov1" title="1">
                return gormLogger.Error</span>
        default:<span class="cov1" title="1">
                return gormLogger.Warn</span>
        }
}

// Migrate runs database migrations
func (d *Database) Migrate() error <span class="cov2" title="2">{
        d.logger.Info("Starting database migration...")

        entities := []interface{}{
                &amp;domain.Provider{},
                &amp;domain.Hotel{},
                &amp;domain.ReviewerInfo{},
                &amp;domain.Review{},
                &amp;domain.ReviewSummary{},
                &amp;domain.ReviewProcessingStatus{},
        }

        for _, entity := range entities </span><span class="cov2" title="2">{
                if err := d.DB.AutoMigrate(entity); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("failed to migrate %T: %w", entity, err)
                }</span>
        }

        // Create indexes
        <span class="cov0" title="0">if err := d.createIndexes(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes: %w", err)
        }</span>

        <span class="cov0" title="0">d.logger.Info("Database migration completed successfully")
        return nil</span>
}

// createIndexes creates additional database indexes for performance
func (d *Database) createIndexes() error <span class="cov0" title="0">{
        indexes := []struct {
                table string
                index string
        }{
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_hotel_id_rating ON reviews(hotel_id, rating)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_provider_id_review_date ON reviews(provider_id, review_date)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_review_date ON reviews(review_date)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_rating ON reviews(rating)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_external_id ON reviews(external_id)"},
                {"reviews", "CREATE INDEX IF NOT EXISTS idx_reviews_processing_hash ON reviews(processing_hash)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_name ON hotels(name)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_city_country ON hotels(city, country)"},
                {"hotels", "CREATE INDEX IF NOT EXISTS idx_hotels_star_rating ON hotels(star_rating)"},
                {"providers", "CREATE INDEX IF NOT EXISTS idx_providers_name ON providers(name)"},
                {"providers", "CREATE INDEX IF NOT EXISTS idx_providers_is_active ON providers(is_active)"},
                {"reviewer_infos", "CREATE INDEX IF NOT EXISTS idx_reviewer_infos_email ON reviewer_infos(email)"},
                {"reviewer_infos", "CREATE INDEX IF NOT EXISTS idx_reviewer_infos_is_verified ON reviewer_infos(is_verified)"},
                {"review_summaries", "CREATE INDEX IF NOT EXISTS idx_review_summaries_hotel_id ON review_summaries(hotel_id)"},
                {"review_processing_statuses", "CREATE INDEX IF NOT EXISTS idx_review_processing_statuses_provider_id_status ON review_processing_statuses(provider_id, status)"},
                {"review_processing_statuses", "CREATE INDEX IF NOT EXISTS idx_review_processing_statuses_created_at ON review_processing_statuses(created_at)"},
        }

        for _, idx := range indexes </span><span class="cov0" title="0">{
                if err := d.DB.Exec(idx.index).Error; err != nil </span><span class="cov0" title="0">{
                        d.logger.Warn("Failed to create index", "table", idx.table, "error", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HealthCheck performs a database health check
func (d *Database) HealthCheck(ctx context.Context) error <span class="cov7" title="9">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov7" title="9">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("database ping failed: %w", err)
        }</span>

        // Test a simple query
        <span class="cov5" title="5">var result int
        if err := d.DB.WithContext(ctx).Raw("SELECT 1").Scan(&amp;result).Error; err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("test query failed: %w", err)
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// GetStats returns database connection statistics
func (d *Database) GetStats() (*sql.DBStats, error) <span class="cov7" title="12">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov7" title="12">stats := sqlDB.Stats()
        return &amp;stats, nil</span>
}

// LogStats logs database connection statistics
func (d *Database) LogStats(ctx context.Context) <span class="cov7" title="11">{
        stats, err := d.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                d.logger.ErrorContext(ctx, "Failed to get database stats", "error", err)
                return
        }</span>

        <span class="cov7" title="11">d.logger.InfoContext(ctx, "Database connection statistics",
                "open_connections", stats.OpenConnections,
                "in_use", stats.InUse,
                "idle", stats.Idle,
                "wait_count", stats.WaitCount,
                "wait_duration", stats.WaitDuration,
                "max_idle_closed", stats.MaxIdleClosed,
                "max_idle_time_closed", stats.MaxIdleTimeClosed,
                "max_lifetime_closed", stats.MaxLifetimeClosed,
        )</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov1" title="1">{
        if d.DB == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov1" title="1">if err := sqlDB.Close(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to close database connection: %w", err)
        }</span>

        <span class="cov0" title="0">d.logger.Info("Database connection closed successfully")
        return nil</span>
}

// WithContext returns a new GORM DB instance with context
func (d *Database) WithContext(ctx context.Context) *gorm.DB <span class="cov10" title="26">{
        return d.DB.WithContext(ctx)
}</span>

// Transaction executes a function within a database transaction
func (d *Database) Transaction(ctx context.Context, fn func(*gorm.DB) error) error <span class="cov4" title="4">{
        return d.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov4" title="4">{
                return fn(tx)
        }</span>)
}

// BeginTransaction starts a new database transaction
func (d *Database) BeginTransaction(ctx context.Context) *gorm.DB <span class="cov1" title="1">{
        return d.DB.WithContext(ctx).Begin()
}</span>

// Seed seeds the database with initial data
func (d *Database) Seed(ctx context.Context) error <span class="cov4" title="3">{
        d.logger.InfoContext(ctx, "Seeding database with initial data...")

        // Create default providers
        providers := []domain.Provider{
                {
                        Name:     "Booking.com",
                        BaseURL:  "https://www.booking.com",
                        IsActive: true,
                },
                {
                        Name:     "Expedia",
                        BaseURL:  "https://www.expedia.com",
                        IsActive: true,
                },
                {
                        Name:     "Hotels.com",
                        BaseURL:  "https://www.hotels.com",
                        IsActive: true,
                },
                {
                        Name:     "Agoda",
                        BaseURL:  "https://www.agoda.com",
                        IsActive: true,
                },
                {
                        Name:     "TripAdvisor",
                        BaseURL:  "https://www.tripadvisor.com",
                        IsActive: true,
                },
        }

        for _, provider := range providers </span><span class="cov7" title="11">{
                var existingProvider domain.Provider
                if err := d.DB.WithContext(ctx).Where("name = ?", provider.Name).First(&amp;existingProvider).Error; err != nil </span><span class="cov7" title="10">{
                        if err == gorm.ErrRecordNotFound </span><span class="cov7" title="9">{
                                if err := d.DB.WithContext(ctx).Create(&amp;provider).Error; err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create provider %s: %w", provider.Name, err)
                                }</span>
                                <span class="cov7" title="9">d.logger.InfoContext(ctx, "Created provider", "name", provider.Name)</span>
                        } else<span class="cov1" title="1"> {
                                return fmt.Errorf("failed to check provider existence: %w", err)
                        }</span>
                }
        }

        <span class="cov2" title="2">d.logger.InfoContext(ctx, "Database seeding completed successfully")
        return nil</span>
}

// Reset resets the database (drops all tables and recreates them)
func (d *Database) Reset(ctx context.Context) error <span class="cov1" title="1">{
        d.logger.WarnContext(ctx, "Resetting database - all data will be lost!")

        entities := []interface{}{
                &amp;domain.ReviewProcessingStatus{},
                &amp;domain.ReviewSummary{},
                &amp;domain.Review{},
                &amp;domain.ReviewerInfo{},
                &amp;domain.Hotel{},
                &amp;domain.Provider{},
        }

        // Drop tables in reverse order to handle foreign keys
        for i := len(entities) - 1; i &gt;= 0; i-- </span><span class="cov5" title="6">{
                if err := d.DB.WithContext(ctx).Migrator().DropTable(entities[i]); err != nil </span><span class="cov5" title="5">{
                        d.logger.WarnContext(ctx, "Failed to drop table", "entity", entities[i], "error", err)
                }</span>
        }

        // Run migrations to recreate tables
        <span class="cov1" title="1">if err := d.Migrate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to run migrations after reset: %w", err)
        }</span>

        <span class="cov0" title="0">d.logger.InfoContext(ctx, "Database reset completed successfully")
        return nil</span>
}

// GetConnectionURL returns the database connection URL (without password)
func (d *Database) GetConnectionURL() string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "postgres://%s:***@%s:%d/%s?sslmode=%s&amp;TimeZone=%s",
                d.config.User,
                d.config.Host,
                d.config.Port,
                d.config.Name,
                d.config.SSLMode,
                d.config.TimeZone,
        )
}</span>

// IsHealthy checks if the database is healthy
func (d *Database) IsHealthy(ctx context.Context) bool <span class="cov2" title="2">{
        return d.HealthCheck(ctx) == nil
}</span>

// WaitForConnection waits for database connection to be available
func (d *Database) WaitForConnection(ctx context.Context, timeout time.Duration) error <span class="cov4" title="3">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov4" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return fmt.Errorf("timeout waiting for database connection: %w", ctx.Err())</span>
                case &lt;-ticker.C:<span class="cov4" title="3">
                        if err := d.HealthCheck(ctx); err == nil </span><span class="cov2" title="2">{
                                return nil
                        }</span>
                }
        }
}

// StartStatsLogger starts a goroutine that periodically logs database statistics
func (d *Database) StartStatsLogger(ctx context.Context, interval time.Duration) <span class="cov1" title="1">{
        ticker := time.NewTicker(interval)

        go func() </span><span class="cov1" title="1">{
                defer ticker.Stop()
                for </span><span class="cov7" title="11">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov7" title="10">
                                d.LogStats(ctx)</span>
                        }
                }
        }()
}

// CreateBackup creates a database backup (PostgreSQL specific)
func (d *Database) CreateBackup(ctx context.Context, backupPath string) error <span class="cov1" title="1">{
        // This is a placeholder for backup functionality
        // In production, you would implement pg_dump or similar
        d.logger.InfoContext(ctx, "Database backup requested", "path", backupPath)
        return fmt.Errorf("backup functionality not implemented")
}</span>

// RestoreBackup restores a database backup (PostgreSQL specific)
func (d *Database) RestoreBackup(ctx context.Context, backupPath string) error <span class="cov1" title="1">{
        // This is a placeholder for restore functionality
        // In production, you would implement pg_restore or similar
        d.logger.InfoContext(ctx, "Database restore requested", "path", backupPath)
        return fmt.Errorf("restore functionality not implemented")
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
)

// NewDatabasePool creates a new PostgreSQL connection pool
func NewDatabasePool(databaseURL string, logger interface{}) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        config, err := pgxpool.ParseConfig(databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database URL: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">config.MaxConns = 25
        config.MinConns = 5
        config.MaxConnLifetime = time.Hour
        config.MaxConnIdleTime = 30 * time.Minute
        config.HealthCheckPeriod = time.Minute
        config.ConnConfig.ConnectTimeout = 5 * time.Second

        // Create connection pool
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        pool, err := pgxpool.NewWithConfig(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                pool.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}

// DatabaseHealthCheck creates a health check for the database
func NewDatabaseHealthCheck(pool *pgxpool.Pool) func(context.Context) error <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                return pool.Ping(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package infrastructure

import (
        "context"
        "database/sql"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/prometheus/client_golang/prometheus"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// DBOptimizer provides database optimization utilities and monitoring
type DBOptimizer struct {
        pool   *pgxpool.Pool
        logger monitoring.Logger
        config *DBOptimizerConfig

        // Query performance tracking
        queryStats    map[string]*QueryStats
        queryStatsMux sync.RWMutex

        // Slow query tracking
        slowQueries    []SlowQuery
        slowQueriesMux sync.RWMutex

        // Migration tracking
        migrationHistory []MigrationRecord
        migrationMux     sync.RWMutex

        // Health monitoring
        lastHealthCheck time.Time
        healthStatus    *DatabaseHealth
        healthMux       sync.RWMutex

        // Metrics
        metrics *DBMetrics

        // Background monitoring
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup
}

// DBOptimizerConfig configures the database optimizer
type DBOptimizerConfig struct {
        // Query monitoring
        SlowQueryThreshold  time.Duration `json:"slow_query_threshold" validate:"min=1ms"`
        MaxSlowQueries      int           `json:"max_slow_queries" validate:"min=1"`
        QueryStatsRetention time.Duration `json:"query_stats_retention" validate:"min=1h"`

        // Health monitoring
        HealthCheckInterval time.Duration `json:"health_check_interval" validate:"min=10s"`
        ConnectionTimeout   time.Duration `json:"connection_timeout" validate:"min=1s"`

        // Performance monitoring
        MetricsInterval    time.Duration `json:"metrics_interval" validate:"min=10s"`
        EnableQueryLogging bool          `json:"enable_query_logging"`
        EnableSlowQueryLog bool          `json:"enable_slow_query_log"`

        // Connection pool optimization
        EnablePoolOptimization   bool          `json:"enable_pool_optimization"`
        PoolOptimizationInterval time.Duration `json:"pool_optimization_interval" validate:"min=1m"`

        // Migration tracking
        EnableMigrationTracking bool `json:"enable_migration_tracking"`
}

// QueryStats tracks performance statistics for database queries
type QueryStats struct {
        Query          string        `json:"query"`
        ExecutionCount int64         `json:"execution_count"`
        TotalDuration  time.Duration `json:"total_duration"`
        MinDuration    time.Duration `json:"min_duration"`
        MaxDuration    time.Duration `json:"max_duration"`
        AvgDuration    time.Duration `json:"avg_duration"`
        LastExecuted   time.Time     `json:"last_executed"`
        ErrorCount     int64         `json:"error_count"`
        RowsAffected   int64         `json:"rows_affected"`
}

// SlowQuery represents a slow query entry
type SlowQuery struct {
        Query     string        `json:"query"`
        Duration  time.Duration `json:"duration"`
        Timestamp time.Time     `json:"timestamp"`
        Error     string        `json:"error,omitempty"`
        Context   string        `json:"context,omitempty"`
}

// MigrationRecord tracks migration performance
type MigrationRecord struct {
        Version      string        `json:"version"`
        Name         string        `json:"name"`
        StartTime    time.Time     `json:"start_time"`
        EndTime      time.Time     `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        Success      bool          `json:"success"`
        Error        string        `json:"error,omitempty"`
        RowsAffected int64         `json:"rows_affected"`
}

// DatabaseHealth represents the current health status of the database
type DatabaseHealth struct {
        IsHealthy          bool          `json:"is_healthy"`
        LastCheck          time.Time     `json:"last_check"`
        ResponseTime       time.Duration `json:"response_time"`
        ActiveConnections  int32         `json:"active_connections"`
        IdleConnections    int32         `json:"idle_connections"`
        MaxConnections     int32         `json:"max_connections"`
        TotalConnections   int32         `json:"total_connections"`
        WaitingClients     int32         `json:"waiting_clients"`
        DatabaseSize       int64         `json:"database_size_bytes"`
        TransactionsPerSec float64       `json:"transactions_per_sec"`
        QueriesPerSec      float64       `json:"queries_per_sec"`
        CacheHitRatio      float64       `json:"cache_hit_ratio"`
}

// PoolOptimizationSuggestion represents a suggestion for pool optimization
type PoolOptimizationSuggestion struct {
        Parameter  string      `json:"parameter"`
        Current    interface{} `json:"current"`
        Suggested  interface{} `json:"suggested"`
        Reason     string      `json:"reason"`
        Impact     string      `json:"impact"`
        Confidence float64     `json:"confidence"`
}

// DBMetrics contains Prometheus metrics for database monitoring
type DBMetrics struct {
        QueryDuration     *prometheus.HistogramVec
        QueryCount        *prometheus.CounterVec
        SlowQueryCount    prometheus.Counter
        ConnectionsGauge  *prometheus.GaugeVec
        HealthGauge       prometheus.Gauge
        MigrationDuration *prometheus.HistogramVec
}

// DefaultDBOptimizerConfig returns the default configuration
func DefaultDBOptimizerConfig() *DBOptimizerConfig <span class="cov7" title="9">{
        return &amp;DBOptimizerConfig{
                SlowQueryThreshold:       500 * time.Millisecond,
                MaxSlowQueries:           100,
                QueryStatsRetention:      24 * time.Hour,
                HealthCheckInterval:      30 * time.Second,
                ConnectionTimeout:        5 * time.Second,
                MetricsInterval:          15 * time.Second,
                EnableQueryLogging:       true,
                EnableSlowQueryLog:       true,
                EnablePoolOptimization:   true,
                PoolOptimizationInterval: 5 * time.Minute,
                EnableMigrationTracking:  true,
        }
}</span>

// NewDBOptimizer creates a new database optimizer
func NewDBOptimizer(pool *pgxpool.Pool, logger monitoring.Logger, config *DBOptimizerConfig) (*DBOptimizer, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultDBOptimizerConfig()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        optimizer := &amp;DBOptimizer{
                pool:             pool,
                logger:           logger,
                config:           config,
                queryStats:       make(map[string]*QueryStats),
                slowQueries:      make([]SlowQuery, 0, config.MaxSlowQueries),
                migrationHistory: make([]MigrationRecord, 0),
                ctx:              ctx,
                cancel:           cancel,
                metrics:          createDBMetrics(),
        }

        // Start background monitoring
        optimizer.wg.Add(1)
        go optimizer.backgroundMonitor()

        if config.EnablePoolOptimization </span><span class="cov0" title="0">{
                optimizer.wg.Add(1)
                go optimizer.poolOptimizer()
        }</span>

        <span class="cov0" title="0">logger.Info("Database optimizer started",
                "slow_query_threshold", config.SlowQueryThreshold,
                "health_check_interval", config.HealthCheckInterval)

        return optimizer, nil</span>
}

// createDBMetrics initializes Prometheus metrics
func createDBMetrics() *DBMetrics <span class="cov5" title="4">{
        // Create metrics manually to avoid registration conflicts in tests
        queryDuration := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "db_query_duration_seconds",
                        Help:    "Database query execution duration in seconds",
                        Buckets: prometheus.ExponentialBuckets(0.001, 2, 15), // 1ms to ~32s
                },
                []string{"query_type", "table", "operation"},
        )

        queryCount := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "db_query_total",
                        Help: "Total number of database queries executed",
                },
                []string{"query_type", "table", "operation", "status"},
        )

        slowQueryCount := prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "db_slow_query_total",
                        Help: "Total number of slow database queries",
                },
        )

        connectionsGauge := prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "db_connections",
                        Help: "Number of database connections by state",
                },
                []string{"state"},
        )

        healthGauge := prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "db_health_status",
                        Help: "Database health status (1 = healthy, 0 = unhealthy)",
                },
        )

        migrationDuration := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "db_migration_duration_seconds",
                        Help:    "Database migration execution duration in seconds",
                        Buckets: prometheus.ExponentialBuckets(0.1, 2, 12), // 100ms to ~6m
                },
                []string{"version", "operation"},
        )

        return &amp;DBMetrics{
                QueryDuration:     queryDuration,
                QueryCount:        queryCount,
                SlowQueryCount:    slowQueryCount,
                ConnectionsGauge:  connectionsGauge,
                HealthGauge:       healthGauge,
                MigrationDuration: migrationDuration,
        }
}</span>

// TrackQuery records query execution statistics
func (opt *DBOptimizer) TrackQuery(query string, duration time.Duration, err error, rowsAffected int64) <span class="cov9" title="15">{
        // Normalize query for statistics (remove specific values)
        normalizedQuery := opt.normalizeQuery(query)

        opt.queryStatsMux.Lock()
        stats, exists := opt.queryStats[normalizedQuery]
        if !exists </span><span class="cov8" title="12">{
                stats = &amp;QueryStats{
                        Query:       normalizedQuery,
                        MinDuration: duration,
                        MaxDuration: duration,
                }
                opt.queryStats[normalizedQuery] = stats
        }</span>

        <span class="cov9" title="15">stats.ExecutionCount++
        stats.TotalDuration += duration
        stats.LastExecuted = time.Now()
        stats.RowsAffected += rowsAffected

        if duration &lt; stats.MinDuration </span><span class="cov0" title="0">{
                stats.MinDuration = duration
        }</span>
        <span class="cov9" title="15">if duration &gt; stats.MaxDuration </span><span class="cov3" title="2">{
                stats.MaxDuration = duration
        }</span>
        <span class="cov9" title="15">stats.AvgDuration = time.Duration(int64(stats.TotalDuration) / stats.ExecutionCount)

        if err != nil </span><span class="cov3" title="2">{
                stats.ErrorCount++
        }</span>
        <span class="cov9" title="15">opt.queryStatsMux.Unlock()

        // Track slow queries
        if duration &gt;= opt.config.SlowQueryThreshold </span><span class="cov6" title="7">{
                opt.trackSlowQuery(query, duration, err)
        }</span>

        // Update metrics
        <span class="cov9" title="15">queryType, table, operation := opt.parseQuery(query)
        opt.metrics.QueryDuration.WithLabelValues(queryType, table, operation).Observe(duration.Seconds())

        status := "success"
        if err != nil </span><span class="cov3" title="2">{
                status = "error"
        }</span>
        <span class="cov9" title="15">opt.metrics.QueryCount.WithLabelValues(queryType, table, operation, status).Inc()

        if opt.config.EnableQueryLogging </span><span class="cov9" title="15">{
                logLevel := "debug"
                if duration &gt;= opt.config.SlowQueryThreshold </span><span class="cov6" title="7">{
                        logLevel = "warn"
                }</span>

                <span class="cov9" title="15">if logLevel == "warn" </span><span class="cov6" title="7">{
                        opt.logger.Warn("Slow query detected",
                                "query", query,
                                "duration", duration,
                                "rows_affected", rowsAffected,
                                "error", err)
                }</span> else<span class="cov7" title="8"> {
                        opt.logger.Debug("Query executed",
                                "duration", duration,
                                "rows_affected", rowsAffected)
                }</span>
        }
}

// trackSlowQuery records a slow query
func (opt *DBOptimizer) trackSlowQuery(query string, duration time.Duration, err error) <span class="cov6" title="7">{
        opt.metrics.SlowQueryCount.Inc()

        if !opt.config.EnableSlowQueryLog </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="7">slowQuery := SlowQuery{
                Query:     query,
                Duration:  duration,
                Timestamp: time.Now(),
        }

        if err != nil </span><span class="cov0" title="0">{
                slowQuery.Error = err.Error()
        }</span>

        <span class="cov6" title="7">opt.slowQueriesMux.Lock()
        opt.slowQueries = append(opt.slowQueries, slowQuery)

        // Keep only the most recent slow queries
        if len(opt.slowQueries) &gt; opt.config.MaxSlowQueries </span><span class="cov3" title="2">{
                opt.slowQueries = opt.slowQueries[1:]
        }</span>
        <span class="cov6" title="7">opt.slowQueriesMux.Unlock()</span>
}

// TrackMigration records migration performance
func (opt *DBOptimizer) TrackMigration(version, name string, startTime, endTime time.Time, success bool, err error, rowsAffected int64) <span class="cov3" title="2">{
        if !opt.config.EnableMigrationTracking </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">duration := endTime.Sub(startTime)

        migration := MigrationRecord{
                Version:      version,
                Name:         name,
                StartTime:    startTime,
                EndTime:      endTime,
                Duration:     duration,
                Success:      success,
                RowsAffected: rowsAffected,
        }

        if err != nil </span><span class="cov1" title="1">{
                migration.Error = err.Error()
        }</span>

        <span class="cov3" title="2">opt.migrationMux.Lock()
        opt.migrationHistory = append(opt.migrationHistory, migration)
        opt.migrationMux.Unlock()

        // Update metrics
        operation := "up"
        if !success </span><span class="cov1" title="1">{
                operation = "failed"
        }</span>
        <span class="cov3" title="2">opt.metrics.MigrationDuration.WithLabelValues(version, operation).Observe(duration.Seconds())

        opt.logger.Info("Migration tracked",
                "version", version,
                "name", name,
                "duration", duration,
                "success", success,
                "rows_affected", rowsAffected,
                "error", err)</span>
}

// GetQueryStats returns current query statistics
func (opt *DBOptimizer) GetQueryStats() map[string]*QueryStats <span class="cov5" title="4">{
        opt.queryStatsMux.RLock()
        defer opt.queryStatsMux.RUnlock()

        // Return a copy to prevent concurrent access issues
        result := make(map[string]*QueryStats)
        for k, v := range opt.queryStats </span><span class="cov8" title="11">{
                statsCopy := *v
                result[k] = &amp;statsCopy
        }</span>

        <span class="cov5" title="4">return result</span>
}

// GetSlowQueries returns recent slow queries
func (opt *DBOptimizer) GetSlowQueries() []SlowQuery <span class="cov5" title="4">{
        opt.slowQueriesMux.RLock()
        defer opt.slowQueriesMux.RUnlock()

        // Return a copy
        result := make([]SlowQuery, len(opt.slowQueries))
        copy(result, opt.slowQueries)

        return result
}</span>

// GetMigrationHistory returns migration history
func (opt *DBOptimizer) GetMigrationHistory() []MigrationRecord <span class="cov4" title="3">{
        opt.migrationMux.RLock()
        defer opt.migrationMux.RUnlock()

        // Return a copy
        result := make([]MigrationRecord, len(opt.migrationHistory))
        copy(result, opt.migrationHistory)

        return result
}</span>

// GetDatabaseHealth returns current database health status
func (opt *DBOptimizer) GetDatabaseHealth() *DatabaseHealth <span class="cov1" title="1">{
        opt.healthMux.RLock()
        defer opt.healthMux.RUnlock()

        if opt.healthStatus == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Return a copy
        <span class="cov0" title="0">health := *opt.healthStatus
        return &amp;health</span>
}

// PerformHealthCheck executes a comprehensive database health check
func (opt *DBOptimizer) PerformHealthCheck() error <span class="cov0" title="0">{
        start := time.Now()

        ctx, cancel := context.WithTimeout(opt.ctx, opt.config.ConnectionTimeout)
        defer cancel()

        health := &amp;DatabaseHealth{
                LastCheck: start,
        }

        // Test basic connectivity
        err := opt.pool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                health.IsHealthy = false
                opt.updateHealthStatus(health)
                return fmt.Errorf("database ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">health.ResponseTime = time.Since(start)

        // Get connection pool stats
        poolStats := opt.pool.Stat()
        health.ActiveConnections = poolStats.AcquiredConns()
        health.IdleConnections = poolStats.IdleConns()
        health.MaxConnections = poolStats.MaxConns()
        health.TotalConnections = poolStats.TotalConns()

        // Get database statistics
        if err := opt.collectDatabaseStats(ctx, health); err != nil </span><span class="cov0" title="0">{
                opt.logger.Warn("Failed to collect database statistics", "error", err)
        }</span>

        <span class="cov0" title="0">health.IsHealthy = true
        opt.updateHealthStatus(health)

        // Update metrics
        opt.metrics.HealthGauge.Set(1)
        opt.metrics.ConnectionsGauge.WithLabelValues("active").Set(float64(health.ActiveConnections))
        opt.metrics.ConnectionsGauge.WithLabelValues("idle").Set(float64(health.IdleConnections))
        opt.metrics.ConnectionsGauge.WithLabelValues("max").Set(float64(health.MaxConnections))

        return nil</span>
}

// collectDatabaseStats gathers detailed database statistics
func (opt *DBOptimizer) collectDatabaseStats(ctx context.Context, health *DatabaseHealth) error <span class="cov0" title="0">{
        // Database size
        var dbSize sql.NullInt64
        err := opt.pool.QueryRow(ctx, `
                SELECT pg_database_size(current_database())
        `).Scan(&amp;dbSize)
        if err == nil &amp;&amp; dbSize.Valid </span><span class="cov0" title="0">{
                health.DatabaseSize = dbSize.Int64
        }</span>

        // Cache hit ratio
        <span class="cov0" title="0">var cacheHit, cacheRead sql.NullFloat64
        err = opt.pool.QueryRow(ctx, `
                SELECT 
                        sum(heap_blks_hit) as cache_hit,
                        sum(heap_blks_hit + heap_blks_read) as cache_read
                FROM pg_statio_user_tables
        `).Scan(&amp;cacheHit, &amp;cacheRead)
        if err == nil &amp;&amp; cacheHit.Valid &amp;&amp; cacheRead.Valid &amp;&amp; cacheRead.Float64 &gt; 0 </span><span class="cov0" title="0">{
                health.CacheHitRatio = cacheHit.Float64 / cacheRead.Float64 * 100
        }</span>

        // Transaction and query rates (approximate)
        <span class="cov0" title="0">var xactCommit, xactRollback sql.NullInt64
        err = opt.pool.QueryRow(ctx, `
                SELECT xact_commit, xact_rollback 
                FROM pg_stat_database 
                WHERE datname = current_database()
        `).Scan(&amp;xactCommit, &amp;xactRollback)
        if err == nil &amp;&amp; xactCommit.Valid </span><span class="cov0" title="0">{
                // This is cumulative, so we'd need to track over time for true rate
                health.TransactionsPerSec = float64(xactCommit.Int64 + xactRollback.Int64)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateHealthStatus updates the health status thread-safely
func (opt *DBOptimizer) updateHealthStatus(health *DatabaseHealth) <span class="cov0" title="0">{
        opt.healthMux.Lock()
        opt.healthStatus = health
        opt.lastHealthCheck = health.LastCheck
        opt.healthMux.Unlock()
}</span>

// GetPoolOptimizationSuggestions analyzes pool usage and provides optimization suggestions
func (opt *DBOptimizer) GetPoolOptimizationSuggestions() []PoolOptimizationSuggestion <span class="cov3" title="2">{
        if !opt.config.EnablePoolOptimization || opt.pool == nil </span><span class="cov3" title="2">{
                return nil
        }</span>

        <span class="cov0" title="0">poolStats := opt.pool.Stat()
        health := opt.GetDatabaseHealth()

        var suggestions []PoolOptimizationSuggestion

        // Analyze connection pool utilization
        utilizationRatio := float64(poolStats.AcquiredConns()) / float64(poolStats.MaxConns())

        if utilizationRatio &gt; 0.9 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, PoolOptimizationSuggestion{
                        Parameter:  "max_connections",
                        Current:    poolStats.MaxConns(),
                        Suggested:  int32(float64(poolStats.MaxConns()) * 1.5),
                        Reason:     "High connection pool utilization detected",
                        Impact:     "Increased throughput under high load",
                        Confidence: 0.8,
                })
        }</span>

        <span class="cov0" title="0">if utilizationRatio &lt; 0.3 &amp;&amp; poolStats.MaxConns() &gt; 10 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, PoolOptimizationSuggestion{
                        Parameter:  "max_connections",
                        Current:    poolStats.MaxConns(),
                        Suggested:  int32(float64(poolStats.MaxConns()) * 0.7),
                        Reason:     "Low connection pool utilization detected",
                        Impact:     "Reduced memory usage and overhead",
                        Confidence: 0.6,
                })
        }</span>

        // Analyze slow queries
        <span class="cov0" title="0">slowQueries := opt.GetSlowQueries()
        if len(slowQueries) &gt; 10 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, PoolOptimizationSuggestion{
                        Parameter:  "query_optimization",
                        Current:    len(slowQueries),
                        Suggested:  "Index analysis recommended",
                        Reason:     "High number of slow queries detected",
                        Impact:     "Improved query performance",
                        Confidence: 0.9,
                })
        }</span>

        // Analyze cache hit ratio
        <span class="cov0" title="0">if health != nil &amp;&amp; health.CacheHitRatio &lt; 95 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, PoolOptimizationSuggestion{
                        Parameter:  "shared_buffers",
                        Current:    fmt.Sprintf("%.2f%% cache hit ratio", health.CacheHitRatio),
                        Suggested:  "Increase shared_buffers",
                        Reason:     "Low cache hit ratio indicates insufficient memory allocation",
                        Impact:     "Reduced disk I/O and improved performance",
                        Confidence: 0.7,
                })
        }</span>

        <span class="cov0" title="0">return suggestions</span>
}

// backgroundMonitor runs periodic health checks and maintenance
func (opt *DBOptimizer) backgroundMonitor() <span class="cov0" title="0">{
        defer opt.wg.Done()

        healthTicker := time.NewTicker(opt.config.HealthCheckInterval)
        metricsTicker := time.NewTicker(opt.config.MetricsInterval)
        cleanupTicker := time.NewTicker(opt.config.QueryStatsRetention)

        defer healthTicker.Stop()
        defer metricsTicker.Stop()
        defer cleanupTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-opt.ctx.Done():<span class="cov0" title="0">
                        return</span>

                case &lt;-healthTicker.C:<span class="cov0" title="0">
                        if err := opt.PerformHealthCheck(); err != nil </span><span class="cov0" title="0">{
                                opt.logger.Error("Health check failed", "error", err)
                                opt.metrics.HealthGauge.Set(0)
                        }</span>

                case &lt;-metricsTicker.C:<span class="cov0" title="0">
                        opt.updateMetrics()</span>

                case &lt;-cleanupTicker.C:<span class="cov0" title="0">
                        opt.cleanupOldStats()</span>
                }
        }
}

// poolOptimizer runs periodic pool optimization analysis
func (opt *DBOptimizer) poolOptimizer() <span class="cov0" title="0">{
        defer opt.wg.Done()

        ticker := time.NewTicker(opt.config.PoolOptimizationInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-opt.ctx.Done():<span class="cov0" title="0">
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        suggestions := opt.GetPoolOptimizationSuggestions()
                        if len(suggestions) &gt; 0 </span><span class="cov0" title="0">{
                                opt.logger.Info("Pool optimization suggestions available",
                                        "count", len(suggestions))

                                for _, suggestion := range suggestions </span><span class="cov0" title="0">{
                                        opt.logger.Info("Pool optimization suggestion",
                                                "parameter", suggestion.Parameter,
                                                "current", suggestion.Current,
                                                "suggested", suggestion.Suggested,
                                                "reason", suggestion.Reason,
                                                "confidence", suggestion.Confidence)
                                }</span>
                        }
                }
        }
}

// updateMetrics updates Prometheus metrics
func (opt *DBOptimizer) updateMetrics() <span class="cov0" title="0">{
        // Update query statistics metrics
        stats := opt.GetQueryStats()
        _ = stats // Query stats are already tracked in TrackQuery
        // Additional metrics could be exposed here based on query stats
}</span>

// cleanupOldStats removes old query statistics
func (opt *DBOptimizer) cleanupOldStats() <span class="cov0" title="0">{
        cutoff := time.Now().Add(-opt.config.QueryStatsRetention)

        opt.queryStatsMux.Lock()
        for query, stats := range opt.queryStats </span><span class="cov0" title="0">{
                if stats.LastExecuted.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(opt.queryStats, query)
                }</span>
        }
        <span class="cov0" title="0">opt.queryStatsMux.Unlock()

        opt.logger.Debug("Cleaned up old query statistics",
                "cutoff", cutoff,
                "remaining_stats", len(opt.queryStats))</span>
}

// normalizeQuery removes specific values from queries for statistics grouping
func (opt *DBOptimizer) normalizeQuery(query string) string <span class="cov9" title="20">{
        // This is a simple implementation - could be enhanced with proper SQL parsing
        // For now, just limit the length and remove some obvious parameters
        if len(query) &gt; 200 </span><span class="cov1" title="1">{
                query = query[:200] + "..."
        }</span>

        // Remove common parameter patterns (this is basic, could be improved)
        // In a production system, you'd want more sophisticated query normalization
        <span class="cov9" title="20">return query</span>
}

// parseQuery extracts query metadata for metrics labeling
func (opt *DBOptimizer) parseQuery(query string) (queryType, table, operation string) <span class="cov10" title="21">{
        // This is a simplified parser - in production you'd want proper SQL parsing
        query = strings.ToUpper(strings.TrimSpace(query))

        if strings.HasPrefix(query, "SELECT") </span><span class="cov8" title="11">{
                queryType = "select"
                operation = "read"
        }</span> else<span class="cov7" title="10"> if strings.HasPrefix(query, "INSERT") </span><span class="cov4" title="3">{
                queryType = "insert"
                operation = "write"
        }</span> else<span class="cov6" title="7"> if strings.HasPrefix(query, "UPDATE") </span><span class="cov5" title="5">{
                queryType = "update"
                operation = "write"
        }</span> else<span class="cov3" title="2"> if strings.HasPrefix(query, "DELETE") </span><span class="cov1" title="1">{
                queryType = "delete"
                operation = "write"
        }</span> else<span class="cov1" title="1"> {
                queryType = "other"
                operation = "other"
        }</span>

        // Extract table name (very basic)
        <span class="cov10" title="21">table = "unknown"
        // This would need proper SQL parsing for accurate table extraction

        return queryType, table, operation</span>
}

// GetTopSlowQueries returns the slowest queries sorted by duration
func (opt *DBOptimizer) GetTopSlowQueries(limit int) []SlowQuery <span class="cov1" title="1">{
        queries := opt.GetSlowQueries()

        // Sort by duration descending
        sort.Slice(queries, func(i, j int) bool </span><span class="cov4" title="3">{
                return queries[i].Duration &gt; queries[j].Duration
        }</span>)

        <span class="cov1" title="1">if limit &gt; 0 &amp;&amp; len(queries) &gt; limit </span><span class="cov1" title="1">{
                queries = queries[:limit]
        }</span>

        <span class="cov1" title="1">return queries</span>
}

// GetQueryStatsSummary returns a summary of query statistics
func (opt *DBOptimizer) GetQueryStatsSummary() map[string]interface{} <span class="cov1" title="1">{
        stats := opt.GetQueryStats()
        slowQueries := opt.GetSlowQueries()
        migrations := opt.GetMigrationHistory()
        health := opt.GetDatabaseHealth()

        var totalQueries int64
        var totalDuration time.Duration
        var errorCount int64

        for _, stat := range stats </span><span class="cov4" title="3">{
                totalQueries += stat.ExecutionCount
                totalDuration += stat.TotalDuration
                errorCount += stat.ErrorCount
        }</span>

        <span class="cov1" title="1">var avgDuration time.Duration
        if totalQueries &gt; 0 </span><span class="cov1" title="1">{
                avgDuration = time.Duration(int64(totalDuration) / totalQueries)
        }</span>

        <span class="cov1" title="1">summary := map[string]interface{}{
                "total_queries":     totalQueries,
                "total_duration":    totalDuration,
                "average_duration":  avgDuration,
                "error_count":       errorCount,
                "error_rate":        float64(errorCount) / float64(totalQueries) * 100,
                "slow_queries":      len(slowQueries),
                "unique_queries":    len(stats),
                "migrations_count":  len(migrations),
                "last_health_check": opt.lastHealthCheck,
        }

        if health != nil </span><span class="cov0" title="0">{
                summary["health"] = health
        }</span>

        <span class="cov1" title="1">return summary</span>
}

// Stop gracefully shuts down the database optimizer
func (opt *DBOptimizer) Stop() error <span class="cov1" title="1">{
        opt.logger.Info("Stopping database optimizer")

        opt.cancel()
        opt.wg.Wait()

        opt.logger.Info("Database optimizer stopped")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ErrorAggregator aggregates and analyzes error patterns
type ErrorAggregator struct {
        config *ErrorHandlerConfig
        logger *logger.Logger
        mu     sync.RWMutex

        // Error pattern tracking
        errorPatterns   map[string]*ErrorPattern
        errorSignatures map[string]*ErrorSignature
        errorClusters   map[string]*ErrorCluster
        errorTrends     map[string]*ErrorTrend

        // Time-based aggregation
        hourlyStats map[string]*HourlyErrorStats
        dailyStats  map[string]*DailyErrorStats

        // Background processes
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        shutdownCh chan struct{}
}

// ErrorSignature represents a unique error signature
type ErrorSignature struct {
        ID             string                 `json:"id"`
        Type           ErrorType              `json:"type"`
        MessagePattern string                 `json:"message_pattern"`
        StackPattern   string                 `json:"stack_pattern"`
        SourcePattern  string                 `json:"source_pattern"`
        Count          int64                  `json:"count"`
        FirstSeen      time.Time              `json:"first_seen"`
        LastSeen       time.Time              `json:"last_seen"`
        AffectedUsers  []string               `json:"affected_users"`
        Sources        []string               `json:"sources"`
        Severity       ErrorSeverity          `json:"severity"`
        Category       ErrorCategory          `json:"category"`
        Metadata       map[string]interface{} `json:"metadata"`
}

// ErrorCluster represents a cluster of related errors
type ErrorCluster struct {
        ID              string            `json:"id"`
        Name            string            `json:"name"`
        Description     string            `json:"description"`
        Signatures      []*ErrorSignature `json:"signatures"`
        Count           int64             `json:"count"`
        FirstSeen       time.Time         `json:"first_seen"`
        LastSeen        time.Time         `json:"last_seen"`
        Severity        ErrorSeverity     `json:"severity"`
        Category        ErrorCategory     `json:"category"`
        AffectedSystems []string          `json:"affected_systems"`
        RootCause       string            `json:"root_cause,omitempty"`
        Resolution      string            `json:"resolution,omitempty"`
        Status          string            `json:"status"`
}

// ErrorTrend represents error trend analysis
type ErrorTrend struct {
        Type           ErrorType     `json:"type"`
        Period         time.Duration `json:"period"`
        Count          int64         `json:"count"`
        Rate           float64       `json:"rate"`
        Trend          string        `json:"trend"` // increasing, decreasing, stable
        PercentChange  float64       `json:"percent_change"`
        Predictions    []float64     `json:"predictions"`
        Confidence     float64       `json:"confidence"`
        LastCalculated time.Time     `json:"last_calculated"`
}

// HourlyErrorStats represents hourly error statistics
type HourlyErrorStats struct {
        Hour      time.Time               `json:"hour"`
        Counts    map[ErrorType]int64     `json:"counts"`
        Total     int64                   `json:"total"`
        Severity  map[ErrorSeverity]int64 `json:"severity"`
        TopErrors []string                `json:"top_errors"`
}

// DailyErrorStats represents daily error statistics
type DailyErrorStats struct {
        Date      time.Time               `json:"date"`
        Counts    map[ErrorType]int64     `json:"counts"`
        Total     int64                   `json:"total"`
        Severity  map[ErrorSeverity]int64 `json:"severity"`
        TopErrors []string                `json:"top_errors"`
        Trends    map[string]float64      `json:"trends"`
}

// NewErrorAggregator creates a new error aggregator
func NewErrorAggregator(config *ErrorHandlerConfig, logger *logger.Logger) *ErrorAggregator <span class="cov2" title="8">{
        ctx, cancel := context.WithCancel(context.Background())

        ea := &amp;ErrorAggregator{
                config:          config,
                logger:          logger,
                errorPatterns:   make(map[string]*ErrorPattern),
                errorSignatures: make(map[string]*ErrorSignature),
                errorClusters:   make(map[string]*ErrorCluster),
                errorTrends:     make(map[string]*ErrorTrend),
                hourlyStats:     make(map[string]*HourlyErrorStats),
                dailyStats:      make(map[string]*DailyErrorStats),
                ctx:             ctx,
                cancel:          cancel,
                shutdownCh:      make(chan struct{}),
        }

        // Start background processes
        ea.startBackgroundProcesses()

        return ea
}</span>

// RecordError records an error for aggregation
func (ea *ErrorAggregator) RecordError(appErr *AppError) <span class="cov6" title="1016">{
        // Generate error signature
        signature := ea.generateErrorSignature(appErr)

        // Update signature statistics
        ea.updateSignatureStats(signature, appErr)

        // Update time-based statistics
        ea.updateTimeBasedStats(appErr)

        // Update clusters
        ea.updateClusters(signature, appErr)

        // Update trends
        ea.updateTrends(appErr)
}</span>

// generateErrorSignature generates a unique signature for an error
func (ea *ErrorAggregator) generateErrorSignature(appErr *AppError) *ErrorSignature <span class="cov6" title="1016">{
        // Create signature ID based on error characteristics
        messagePattern := ea.normalizeMessage(appErr.Message)
        stackPattern := ea.normalizeStackTrace(appErr.StackTrace)
        sourcePattern := ea.normalizeSource(appErr.Source)

        signatureID := fmt.Sprintf("%s:%s:%s:%s",
                appErr.Type,
                ea.hashString(messagePattern),
                ea.hashString(stackPattern),
                ea.hashString(sourcePattern))

        ea.mu.Lock()
        defer ea.mu.Unlock()

        if signature, exists := ea.errorSignatures[signatureID]; exists </span><span class="cov6" title="1002">{
                return signature
        }</span>

        // Create new signature
        <span class="cov3" title="14">signature := &amp;ErrorSignature{
                ID:             signatureID,
                Type:           appErr.Type,
                MessagePattern: messagePattern,
                StackPattern:   stackPattern,
                SourcePattern:  sourcePattern,
                Count:          0,
                FirstSeen:      appErr.Timestamp,
                LastSeen:       appErr.Timestamp,
                AffectedUsers:  []string{},
                Sources:        []string{},
                Severity:       appErr.Severity,
                Category:       appErr.Category,
                Metadata:       make(map[string]interface{}),
        }

        ea.errorSignatures[signatureID] = signature
        return signature</span>
}

// updateSignatureStats updates signature statistics
func (ea *ErrorAggregator) updateSignatureStats(signature *ErrorSignature, appErr *AppError) <span class="cov6" title="1016">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        signature.Count++
        signature.LastSeen = appErr.Timestamp

        // Update affected users
        if appErr.UserID != "" </span><span class="cov0" title="0">{
                if !ea.containsString(signature.AffectedUsers, appErr.UserID) </span><span class="cov0" title="0">{
                        signature.AffectedUsers = append(signature.AffectedUsers, appErr.UserID)
                }</span>
        }

        // Update sources
        <span class="cov6" title="1016">if appErr.Source != "" </span><span class="cov4" title="65">{
                if !ea.containsString(signature.Sources, appErr.Source) </span><span class="cov3" title="12">{
                        signature.Sources = append(signature.Sources, appErr.Source)
                }</span>
        }

        // Update metadata
        <span class="cov6" title="1016">if appErr.Details != nil </span><span class="cov4" title="65">{
                for k, v := range appErr.Details </span><span class="cov4" title="65">{
                        signature.Metadata[k] = v
                }</span>
        }
}

// updateTimeBasedStats updates time-based error statistics
func (ea *ErrorAggregator) updateTimeBasedStats(appErr *AppError) <span class="cov6" title="1016">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        // Update hourly stats
        hour := appErr.Timestamp.Truncate(time.Hour)
        hourKey := hour.Format("2006-01-02T15")

        if stats, exists := ea.hourlyStats[hourKey]; exists </span><span class="cov6" title="1010">{
                stats.Counts[appErr.Type]++
                stats.Total++
                stats.Severity[appErr.Severity]++
        }</span> else<span class="cov2" title="6"> {
                ea.hourlyStats[hourKey] = &amp;HourlyErrorStats{
                        Hour:      hour,
                        Counts:    map[ErrorType]int64{appErr.Type: 1},
                        Total:     1,
                        Severity:  map[ErrorSeverity]int64{appErr.Severity: 1},
                        TopErrors: []string{},
                }
        }</span>

        // Update daily stats
        <span class="cov6" title="1016">day := appErr.Timestamp.Truncate(24 * time.Hour)
        dayKey := day.Format("2006-01-02")

        if stats, exists := ea.dailyStats[dayKey]; exists </span><span class="cov6" title="1010">{
                stats.Counts[appErr.Type]++
                stats.Total++
                stats.Severity[appErr.Severity]++
        }</span> else<span class="cov2" title="6"> {
                ea.dailyStats[dayKey] = &amp;DailyErrorStats{
                        Date:      day,
                        Counts:    map[ErrorType]int64{appErr.Type: 1},
                        Total:     1,
                        Severity:  map[ErrorSeverity]int64{appErr.Severity: 1},
                        TopErrors: []string{},
                        Trends:    make(map[string]float64),
                }
        }</span>
}

// updateClusters updates error clusters
func (ea *ErrorAggregator) updateClusters(signature *ErrorSignature, appErr *AppError) <span class="cov6" title="1016">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        // Find existing cluster or create new one
        clusterID := ea.findClusterForSignature(signature)

        if cluster, exists := ea.errorClusters[clusterID]; exists </span><span class="cov6" title="1004">{
                cluster.Count++
                cluster.LastSeen = appErr.Timestamp

                // Add signature if not already present
                if !ea.containsSignature(cluster.Signatures, signature) </span><span class="cov1" title="2">{
                        cluster.Signatures = append(cluster.Signatures, signature)
                }</span>
        } else<span class="cov3" title="12"> {
                // Create new cluster
                cluster := &amp;ErrorCluster{
                        ID:              clusterID,
                        Name:            ea.generateClusterName(signature),
                        Description:     ea.generateClusterDescription(signature),
                        Signatures:      []*ErrorSignature{signature},
                        Count:           1,
                        FirstSeen:       appErr.Timestamp,
                        LastSeen:        appErr.Timestamp,
                        Severity:        signature.Severity,
                        Category:        signature.Category,
                        AffectedSystems: []string{},
                        Status:          "active",
                }

                ea.errorClusters[clusterID] = cluster
        }</span>
}

// updateTrends updates error trends
func (ea *ErrorAggregator) updateTrends(appErr *AppError) <span class="cov6" title="1016">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        trendKey := string(appErr.Type)

        if trend, exists := ea.errorTrends[trendKey]; exists </span><span class="cov6" title="1004">{
                trend.Count++
                trend.LastCalculated = time.Now()

                // Recalculate trend
                ea.calculateTrend(trend)
        }</span> else<span class="cov3" title="12"> {
                // Create new trend
                trend := &amp;ErrorTrend{
                        Type:           appErr.Type,
                        Period:         time.Hour,
                        Count:          1,
                        Rate:           0,
                        Trend:          "stable",
                        PercentChange:  0,
                        Predictions:    []float64{},
                        Confidence:     0.5,
                        LastCalculated: time.Now(),
                }

                ea.errorTrends[trendKey] = trend
        }</span>
}

// Helper methods

// normalizeMessage normalizes error message for pattern matching
func (ea *ErrorAggregator) normalizeMessage(message string) string <span class="cov6" title="1016">{
        // Remove specific IDs, numbers, and timestamps
        normalized := strings.ToLower(message)

        // Replace UUIDs with placeholder
        normalized = ea.replacePattern(normalized, `[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`, "UUID")

        // Replace numbers with placeholder
        normalized = ea.replacePattern(normalized, `\d+`, "NUMBER")

        // Replace timestamps with placeholder
        normalized = ea.replacePattern(normalized, `\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}`, "TIMESTAMP")

        return normalized
}</span>

// normalizeStackTrace normalizes stack trace for pattern matching
func (ea *ErrorAggregator) normalizeStackTrace(stackTrace string) string <span class="cov6" title="1016">{
        if stackTrace == "" </span><span class="cov6" title="951">{
                return ""
        }</span>

        // Extract function names and remove line numbers
        <span class="cov4" title="65">lines := strings.Split(stackTrace, "\n")
        var functions []string

        for _, line := range lines </span><span class="cov6" title="816">{
                if strings.Contains(line, "(") </span><span class="cov5" title="293">{
                        parts := strings.Split(line, "(")
                        if len(parts) &gt; 0 </span><span class="cov5" title="293">{
                                functions = append(functions, strings.TrimSpace(parts[0]))
                        }</span>
                }
        }

        // Return first few functions as pattern
        <span class="cov4" title="65">if len(functions) &gt; 5 </span><span class="cov3" title="15">{
                functions = functions[:5]
        }</span>

        <span class="cov4" title="65">return strings.Join(functions, "-&gt;")</span>
}

// normalizeSource normalizes source location for pattern matching
func (ea *ErrorAggregator) normalizeSource(source string) string <span class="cov6" title="1016">{
        if source == "" </span><span class="cov6" title="951">{
                return ""
        }</span>

        // Extract package and function name, remove line numbers
        <span class="cov4" title="65">parts := strings.Split(source, ":")
        if len(parts) &gt; 0 </span><span class="cov4" title="65">{
                return parts[0]
        }</span>

        <span class="cov0" title="0">return source</span>
}

// hashString creates a hash of a string
func (ea *ErrorAggregator) hashString(s string) string <span class="cov7" title="3048">{
        if s == "" </span><span class="cov7" title="1902">{
                return "empty"
        }</span>

        // Simple hash function for demonstration
        <span class="cov6" title="1146">hash := 0
        for _, char := range s </span><span class="cov10" title="47507">{
                hash = hash*31 + int(char)
        }</span>

        <span class="cov6" title="1146">return fmt.Sprintf("%x", hash)</span>
}

// replacePattern replaces pattern in text (simplified regex replacement)
func (ea *ErrorAggregator) replacePattern(text, pattern, replacement string) string <span class="cov7" title="3048">{
        // This is a simplified version - in production, use proper regex
        return text
}</span>

// containsString checks if slice contains string
func (ea *ErrorAggregator) containsString(slice []string, item string) bool <span class="cov4" title="65">{
        for _, s := range slice </span><span class="cov4" title="53">{
                if s == item </span><span class="cov4" title="53">{
                        return true
                }</span>
        }
        <span class="cov3" title="12">return false</span>
}

// containsSignature checks if slice contains signature
func (ea *ErrorAggregator) containsSignature(slice []*ErrorSignature, signature *ErrorSignature) bool <span class="cov6" title="1004">{
        for _, s := range slice </span><span class="cov6" title="1005">{
                if s.ID == signature.ID </span><span class="cov6" title="1002">{
                        return true
                }</span>
        }
        <span class="cov1" title="2">return false</span>
}

// findClusterForSignature finds appropriate cluster for signature
func (ea *ErrorAggregator) findClusterForSignature(signature *ErrorSignature) string <span class="cov6" title="1016">{
        // Simple clustering based on error type and severity
        return fmt.Sprintf("%s_%s", signature.Type, signature.Severity)
}</span>

// generateClusterName generates a name for the cluster
func (ea *ErrorAggregator) generateClusterName(signature *ErrorSignature) string <span class="cov3" title="12">{
        return fmt.Sprintf("%s Errors (%s)", signature.Type, signature.Severity)
}</span>

// generateClusterDescription generates a description for the cluster
func (ea *ErrorAggregator) generateClusterDescription(signature *ErrorSignature) string <span class="cov3" title="12">{
        return fmt.Sprintf("Cluster of %s errors with %s severity", signature.Type, signature.Severity)
}</span>

// calculateTrend calculates trend for error type
func (ea *ErrorAggregator) calculateTrend(trend *ErrorTrend) <span class="cov6" title="1004">{
        // Simple trend calculation - in production, use proper time series analysis
        currentRate := float64(trend.Count)

        if trend.Rate &gt; 0 </span><span class="cov6" title="1000">{
                trend.PercentChange = ((currentRate - trend.Rate) / trend.Rate) * 100

                if trend.PercentChange &gt; 10 </span><span class="cov3" title="20">{
                        trend.Trend = "increasing"
                }</span> else<span class="cov6" title="980"> if trend.PercentChange &lt; -10 </span><span class="cov0" title="0">{
                        trend.Trend = "decreasing"
                }</span> else<span class="cov6" title="980"> {
                        trend.Trend = "stable"
                }</span>
        }

        <span class="cov6" title="1004">trend.Rate = currentRate</span>
}

// Public API methods

// GetErrorSignatures returns all error signatures
func (ea *ErrorAggregator) GetErrorSignatures() map[string]*ErrorSignature <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        signatures := make(map[string]*ErrorSignature)
        for k, v := range ea.errorSignatures </span><span class="cov0" title="0">{
                signatures[k] = v
        }</span>

        <span class="cov0" title="0">return signatures</span>
}

// GetErrorClusters returns all error clusters
func (ea *ErrorAggregator) GetErrorClusters() map[string]*ErrorCluster <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        clusters := make(map[string]*ErrorCluster)
        for k, v := range ea.errorClusters </span><span class="cov0" title="0">{
                clusters[k] = v
        }</span>

        <span class="cov0" title="0">return clusters</span>
}

// GetErrorTrends returns all error trends
func (ea *ErrorAggregator) GetErrorTrends() map[string]*ErrorTrend <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        trends := make(map[string]*ErrorTrend)
        for k, v := range ea.errorTrends </span><span class="cov0" title="0">{
                trends[k] = v
        }</span>

        <span class="cov0" title="0">return trends</span>
}

// GetHourlyStats returns hourly error statistics
func (ea *ErrorAggregator) GetHourlyStats() map[string]*HourlyErrorStats <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        stats := make(map[string]*HourlyErrorStats)
        for k, v := range ea.hourlyStats </span><span class="cov0" title="0">{
                stats[k] = v
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetDailyStats returns daily error statistics
func (ea *ErrorAggregator) GetDailyStats() map[string]*DailyErrorStats <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        stats := make(map[string]*DailyErrorStats)
        for k, v := range ea.dailyStats </span><span class="cov0" title="0">{
                stats[k] = v
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetTopErrorSignatures returns top error signatures by count
func (ea *ErrorAggregator) GetTopErrorSignatures(limit int) []*ErrorSignature <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        var signatures []*ErrorSignature
        for _, sig := range ea.errorSignatures </span><span class="cov0" title="0">{
                signatures = append(signatures, sig)
        }</span>

        // Sort by count (descending)
        <span class="cov0" title="0">sort.Slice(signatures, func(i, j int) bool </span><span class="cov0" title="0">{
                return signatures[i].Count &gt; signatures[j].Count
        }</span>)

        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(signatures) &gt; limit </span><span class="cov0" title="0">{
                signatures = signatures[:limit]
        }</span>

        <span class="cov0" title="0">return signatures</span>
}

// GetErrorAnalysis returns comprehensive error analysis
func (ea *ErrorAggregator) GetErrorAnalysis() map[string]interface{} <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        return map[string]interface{}{
                "total_signatures": len(ea.errorSignatures),
                "total_clusters":   len(ea.errorClusters),
                "total_trends":     len(ea.errorTrends),
                "hourly_stats":     len(ea.hourlyStats),
                "daily_stats":      len(ea.dailyStats),
                "top_signatures":   ea.GetTopErrorSignatures(10),
                "active_clusters":  ea.getActiveClusters(),
                "trending_errors":  ea.getTrendingErrors(),
        }
}</span>

// getActiveClusters returns active error clusters
func (ea *ErrorAggregator) getActiveClusters() []*ErrorCluster <span class="cov0" title="0">{
        var active []*ErrorCluster

        for _, cluster := range ea.errorClusters </span><span class="cov0" title="0">{
                if cluster.Status == "active" </span><span class="cov0" title="0">{
                        active = append(active, cluster)
                }</span>
        }

        <span class="cov0" title="0">return active</span>
}

// getTrendingErrors returns trending errors
func (ea *ErrorAggregator) getTrendingErrors() []*ErrorTrend <span class="cov0" title="0">{
        var trending []*ErrorTrend

        for _, trend := range ea.errorTrends </span><span class="cov0" title="0">{
                if trend.Trend == "increasing" </span><span class="cov0" title="0">{
                        trending = append(trending, trend)
                }</span>
        }

        <span class="cov0" title="0">return trending</span>
}

// startBackgroundProcesses starts background aggregation processes
func (ea *ErrorAggregator) startBackgroundProcesses() <span class="cov2" title="8">{
        ea.wg.Add(1)
        go ea.aggregationLoop()
}</span>

// aggregationLoop runs the aggregation loop
func (ea *ErrorAggregator) aggregationLoop() <span class="cov2" title="8">{
        defer ea.wg.Done()

        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov2" title="8">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ea.performAggregation()</span>
                case &lt;-ea.shutdownCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// performAggregation performs periodic aggregation
func (ea *ErrorAggregator) performAggregation() <span class="cov0" title="0">{
        // Update top errors for hourly stats
        ea.updateTopErrors()

        // Calculate trends
        ea.calculateAllTrends()

        // Clean up old data
        ea.cleanupOldData()
}</span>

// updateTopErrors updates top errors for time-based stats
func (ea *ErrorAggregator) updateTopErrors() <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        // Update hourly stats
        for _, stats := range ea.hourlyStats </span><span class="cov0" title="0">{
                var topErrors []string

                // Sort error types by count
                type errorCount struct {
                        errorType ErrorType
                        count     int64
                }

                var counts []errorCount
                for errorType, count := range stats.Counts </span><span class="cov0" title="0">{
                        counts = append(counts, errorCount{errorType, count})
                }</span>

                <span class="cov0" title="0">sort.Slice(counts, func(i, j int) bool </span><span class="cov0" title="0">{
                        return counts[i].count &gt; counts[j].count
                }</span>)

                // Get top 5
                <span class="cov0" title="0">limit := 5
                if len(counts) &lt; limit </span><span class="cov0" title="0">{
                        limit = len(counts)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                        topErrors = append(topErrors, string(counts[i].errorType))
                }</span>

                <span class="cov0" title="0">stats.TopErrors = topErrors</span>
        }

        // Update daily stats similarly
        <span class="cov0" title="0">for _, stats := range ea.dailyStats </span><span class="cov0" title="0">{
                var topErrors []string

                type errorCount struct {
                        errorType ErrorType
                        count     int64
                }

                var counts []errorCount
                for errorType, count := range stats.Counts </span><span class="cov0" title="0">{
                        counts = append(counts, errorCount{errorType, count})
                }</span>

                <span class="cov0" title="0">sort.Slice(counts, func(i, j int) bool </span><span class="cov0" title="0">{
                        return counts[i].count &gt; counts[j].count
                }</span>)

                <span class="cov0" title="0">limit := 5
                if len(counts) &lt; limit </span><span class="cov0" title="0">{
                        limit = len(counts)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                        topErrors = append(topErrors, string(counts[i].errorType))
                }</span>

                <span class="cov0" title="0">stats.TopErrors = topErrors</span>
        }
}

// calculateAllTrends calculates trends for all error types
func (ea *ErrorAggregator) calculateAllTrends() <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        for _, trend := range ea.errorTrends </span><span class="cov0" title="0">{
                ea.calculateTrend(trend)
        }</span>
}

// cleanupOldData cleans up old aggregation data
func (ea *ErrorAggregator) cleanupOldData() <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        cutoff := time.Now().Add(-ea.config.ErrorRetentionPeriod)

        // Clean up hourly stats
        for key, stats := range ea.hourlyStats </span><span class="cov0" title="0">{
                if stats.Hour.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(ea.hourlyStats, key)
                }</span>
        }

        // Clean up daily stats
        <span class="cov0" title="0">for key, stats := range ea.dailyStats </span><span class="cov0" title="0">{
                if stats.Date.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(ea.dailyStats, key)
                }</span>
        }

        // Clean up old signatures
        <span class="cov0" title="0">for key, signature := range ea.errorSignatures </span><span class="cov0" title="0">{
                if signature.LastSeen.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(ea.errorSignatures, key)
                }</span>
        }

        // Clean up old clusters
        <span class="cov0" title="0">for key, cluster := range ea.errorClusters </span><span class="cov0" title="0">{
                if cluster.LastSeen.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(ea.errorClusters, key)
                }</span>
        }
}

// Close closes the aggregator
func (ea *ErrorAggregator) Close() <span class="cov0" title="0">{
        ea.cancel()
        close(ea.shutdownCh)
        ea.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// AlertLevel represents the alert level
type AlertLevel string

const (
        AlertLevelInfo     AlertLevel = "info"
        AlertLevelWarning  AlertLevel = "warning"
        AlertLevelError    AlertLevel = "error"
        AlertLevelCritical AlertLevel = "critical"
)

// AlertType represents the type of alert
type AlertType string

const (
        AlertTypeErrorRate       AlertType = "error_rate"
        AlertTypeErrorSpike      AlertType = "error_spike"
        AlertTypeNewError        AlertType = "new_error"
        AlertTypeCriticalError   AlertType = "critical_error"
        AlertTypeSystemDown      AlertType = "system_down"
        AlertTypeServiceDegraded AlertType = "service_degraded"
)

// AlertCondition represents an alert condition
type AlertCondition struct {
        ID          string          `json:"id"`
        Name        string          `json:"name"`
        Type        AlertType       `json:"type"`
        Level       AlertLevel      `json:"level"`
        Description string          `json:"description"`
        Threshold   float64         `json:"threshold"`
        Window      time.Duration   `json:"window"`
        Cooldown    time.Duration   `json:"cooldown"`
        ErrorTypes  []ErrorType     `json:"error_types"`
        Severities  []ErrorSeverity `json:"severities"`
        Enabled     bool            `json:"enabled"`
        CreatedAt   time.Time       `json:"created_at"`
        UpdatedAt   time.Time       `json:"updated_at"`
}

// Alert represents an alert
type Alert struct {
        ID             string                 `json:"id"`
        ConditionID    string                 `json:"condition_id"`
        Type           AlertType              `json:"type"`
        Level          AlertLevel             `json:"level"`
        Title          string                 `json:"title"`
        Message        string                 `json:"message"`
        Details        map[string]interface{} `json:"details"`
        Context        map[string]interface{} `json:"context"`
        Timestamp      time.Time              `json:"timestamp"`
        Status         string                 `json:"status"` // active, resolved, suppressed
        AcknowledgedBy string                 `json:"acknowledged_by,omitempty"`
        AcknowledgedAt *time.Time             `json:"acknowledged_at,omitempty"`
        ResolvedAt     *time.Time             `json:"resolved_at,omitempty"`
        Count          int                    `json:"count"`
        LastSeen       time.Time              `json:"last_seen"`
        Tags           []string               `json:"tags"`
        Severity       ErrorSeverity          `json:"severity"`
        Source         string                 `json:"source"`
        Runbook        string                 `json:"runbook,omitempty"`
        Actions        []string               `json:"actions,omitempty"`
}

// AlertChannel represents an alert channel
type AlertChannel interface {
        Send(ctx context.Context, alert *Alert) error
        Name() string
        IsEnabled() bool
}

// ErrorAlerter manages error alerting
type ErrorAlerter struct {
        config *ErrorHandlerConfig
        logger *logger.Logger
        mu     sync.RWMutex

        // Alert management
        conditions   map[string]*AlertCondition
        activeAlerts map[string]*Alert
        alertHistory []*Alert
        channels     []AlertChannel

        // Alert suppression
        suppressions map[string]time.Time
        rateLimits   map[string]*AlertRateLimit

        // Metrics tracking
        errorCounts map[string]int64
        errorRates  map[string]float64
        lastUpdate  time.Time

        // Background processes
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        shutdownCh chan struct{}
}

// AlertRateLimit represents rate limiting for alerts
type AlertRateLimit struct {
        Count      int
        Window     time.Duration
        LastReset  time.Time
        Timestamps []time.Time
}

// NewErrorAlerter creates a new error alerter
func NewErrorAlerter(config *ErrorHandlerConfig, logger *logger.Logger) *ErrorAlerter <span class="cov3" title="8">{
        ctx, cancel := context.WithCancel(context.Background())

        ea := &amp;ErrorAlerter{
                config:       config,
                logger:       logger,
                conditions:   make(map[string]*AlertCondition),
                activeAlerts: make(map[string]*Alert),
                alertHistory: make([]*Alert, 0),
                channels:     make([]AlertChannel, 0),
                suppressions: make(map[string]time.Time),
                rateLimits:   make(map[string]*AlertRateLimit),
                errorCounts:  make(map[string]int64),
                errorRates:   make(map[string]float64),
                lastUpdate:   time.Now(),
                ctx:          ctx,
                cancel:       cancel,
                shutdownCh:   make(chan struct{}),
        }

        // Initialize default conditions
        ea.initializeDefaultConditions()

        // Start background processes
        ea.startBackgroundProcesses()

        return ea
}</span>

// initializeDefaultConditions initializes default alert conditions
func (ea *ErrorAlerter) initializeDefaultConditions() <span class="cov3" title="8">{
        defaultConditions := []*AlertCondition{
                {
                        ID:          "high_error_rate",
                        Name:        "High Error Rate",
                        Type:        AlertTypeErrorRate,
                        Level:       AlertLevelError,
                        Description: "Error rate exceeds threshold",
                        Threshold:   10.0, // 10 errors per minute
                        Window:      5 * time.Minute,
                        Cooldown:    15 * time.Minute,
                        ErrorTypes:  []ErrorType{ErrorTypeSystem, ErrorTypeDatabase, ErrorTypeNetwork},
                        Severities:  []ErrorSeverity{SeverityHigh, SeverityCritical},
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "critical_error_spike",
                        Name:        "Critical Error Spike",
                        Type:        AlertTypeErrorSpike,
                        Level:       AlertLevelCritical,
                        Description: "Spike in critical errors detected",
                        Threshold:   5.0, // 5 critical errors in short time
                        Window:      2 * time.Minute,
                        Cooldown:    10 * time.Minute,
                        ErrorTypes:  []ErrorType{},
                        Severities:  []ErrorSeverity{SeverityCritical},
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "new_error_pattern",
                        Name:        "New Error Pattern",
                        Type:        AlertTypeNewError,
                        Level:       AlertLevelWarning,
                        Description: "New error pattern detected",
                        Threshold:   1.0, // Any new error pattern
                        Window:      time.Hour,
                        Cooldown:    30 * time.Minute,
                        ErrorTypes:  []ErrorType{},
                        Severities:  []ErrorSeverity{},
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "system_degradation",
                        Name:        "System Degradation",
                        Type:        AlertTypeServiceDegraded,
                        Level:       AlertLevelError,
                        Description: "System performance degradation detected",
                        Threshold:   20.0, // 20% increase in errors
                        Window:      10 * time.Minute,
                        Cooldown:    20 * time.Minute,
                        ErrorTypes:  []ErrorType{ErrorTypeTimeout, ErrorTypeCircuitBreaker},
                        Severities:  []ErrorSeverity{SeverityMedium, SeverityHigh},
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }

        for _, condition := range defaultConditions </span><span class="cov4" title="32">{
                ea.conditions[condition.ID] = condition
        }</span>
}

// CheckAlertConditions checks alert conditions for an error
func (ea *ErrorAlerter) CheckAlertConditions(appErr *AppError) <span class="cov8" title="1016">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        // Update error tracking
        ea.updateErrorTracking(appErr)

        // Check each condition
        for _, condition := range ea.conditions </span><span class="cov9" title="4064">{
                if !condition.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="4064">if ea.shouldTriggerAlert(condition, appErr) </span><span class="cov2" title="6">{
                        ea.triggerAlert(condition, appErr)
                }</span>
        }
}

// updateErrorTracking updates error tracking metrics
func (ea *ErrorAlerter) updateErrorTracking(appErr *AppError) <span class="cov8" title="1016">{
        key := string(appErr.Type)
        ea.errorCounts[key]++

        // Calculate error rate
        now := time.Now()
        if now.Sub(ea.lastUpdate) &gt;= time.Minute </span><span class="cov0" title="0">{
                for errorType, count := range ea.errorCounts </span><span class="cov0" title="0">{
                        ea.errorRates[errorType] = float64(count) / now.Sub(ea.lastUpdate).Minutes()
                }</span>
                <span class="cov0" title="0">ea.lastUpdate = now</span>
        }
}

// shouldTriggerAlert checks if an alert should be triggered
func (ea *ErrorAlerter) shouldTriggerAlert(condition *AlertCondition, appErr *AppError) bool <span class="cov9" title="4064">{
        // Check if error type matches condition
        if len(condition.ErrorTypes) &gt; 0 </span><span class="cov9" title="2032">{
                match := false
                for _, errorType := range condition.ErrorTypes </span><span class="cov10" title="4960">{
                        if errorType == appErr.Type </span><span class="cov5" title="61">{
                                match = true
                                break</span>
                        }
                }
                <span class="cov9" title="2032">if !match </span><span class="cov9" title="1971">{
                        return false
                }</span>
        }

        // Check if severity matches condition
        <span class="cov9" title="2093">if len(condition.Severities) &gt; 0 </span><span class="cov8" title="1077">{
                match := false
                for _, severity := range condition.Severities </span><span class="cov8" title="1136">{
                        if severity == appErr.Severity </span><span class="cov1" title="2">{
                                match = true
                                break</span>
                        }
                }
                <span class="cov8" title="1077">if !match </span><span class="cov8" title="1075">{
                        return false
                }</span>
        }

        // Check if in cooldown period
        <span class="cov8" title="1018">if ea.isInCooldown(condition.ID) </span><span class="cov8" title="1010">{
                return false
        }</span>

        // Check if suppressed
        <span class="cov3" title="8">if ea.isSuppressed(condition.ID) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if rate limited
        <span class="cov3" title="8">if ea.isRateLimited(condition.ID) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check specific condition logic
        <span class="cov3" title="8">switch condition.Type </span>{
        case AlertTypeErrorRate:<span class="cov1" title="1">
                return ea.checkErrorRateCondition(condition, appErr)</span>
        case AlertTypeErrorSpike:<span class="cov0" title="0">
                return ea.checkErrorSpikeCondition(condition, appErr)</span>
        case AlertTypeNewError:<span class="cov2" title="6">
                return ea.checkNewErrorCondition(condition, appErr)</span>
        case AlertTypeCriticalError:<span class="cov0" title="0">
                return appErr.Severity == SeverityCritical</span>
        case AlertTypeServiceDegraded:<span class="cov1" title="1">
                return ea.checkServiceDegradationCondition(condition, appErr)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// checkErrorRateCondition checks error rate condition
func (ea *ErrorAlerter) checkErrorRateCondition(condition *AlertCondition, appErr *AppError) bool <span class="cov1" title="1">{
        key := string(appErr.Type)
        rate, exists := ea.errorRates[key]

        return exists &amp;&amp; rate &gt;= condition.Threshold
}</span>

// checkErrorSpikeCondition checks error spike condition
func (ea *ErrorAlerter) checkErrorSpikeCondition(condition *AlertCondition, appErr *AppError) bool <span class="cov0" title="0">{
        key := string(appErr.Type)
        count, exists := ea.errorCounts[key]

        // Check if we've seen this many errors in the window
        return exists &amp;&amp; float64(count) &gt;= condition.Threshold
}</span>

// checkNewErrorCondition checks new error condition
func (ea *ErrorAlerter) checkNewErrorCondition(condition *AlertCondition, appErr *AppError) bool <span class="cov2" title="6">{
        // This would typically check against a database of known errors
        // For simplicity, we'll assume any error with a new code is new
        return true
}</span>

// checkServiceDegradationCondition checks service degradation condition
func (ea *ErrorAlerter) checkServiceDegradationCondition(condition *AlertCondition, appErr *AppError) bool <span class="cov1" title="1">{
        // This would typically compare current error rates with historical baselines
        // For simplicity, we'll use a basic threshold
        key := string(appErr.Type)
        rate, exists := ea.errorRates[key]

        return exists &amp;&amp; rate &gt;= condition.Threshold
}</span>

// triggerAlert triggers an alert
func (ea *ErrorAlerter) triggerAlert(condition *AlertCondition, appErr *AppError) <span class="cov2" title="6">{
        alertID := fmt.Sprintf("%s_%s_%d", condition.ID, appErr.Type, time.Now().Unix())

        // Check if we already have an active alert for this condition
        if existingAlert, exists := ea.activeAlerts[condition.ID]; exists </span><span class="cov0" title="0">{
                // Update existing alert
                existingAlert.Count++
                existingAlert.LastSeen = time.Now()
                existingAlert.Details["latest_error"] = appErr
                return
        }</span>

        // Create new alert
        <span class="cov2" title="6">alert := &amp;Alert{
                ID:          alertID,
                ConditionID: condition.ID,
                Type:        condition.Type,
                Level:       condition.Level,
                Title:       ea.generateAlertTitle(condition, appErr),
                Message:     ea.generateAlertMessage(condition, appErr),
                Details:     ea.generateAlertDetails(condition, appErr),
                Context:     ea.generateAlertContext(appErr),
                Timestamp:   time.Now(),
                Status:      "active",
                Count:       1,
                LastSeen:    time.Now(),
                Tags:        ea.generateAlertTags(condition, appErr),
                Severity:    appErr.Severity,
                Source:      appErr.Source,
                Runbook:     ea.generateRunbook(condition),
                Actions:     ea.generateActions(condition, appErr),
        }

        // Store alert
        ea.activeAlerts[condition.ID] = alert
        ea.alertHistory = append(ea.alertHistory, alert)

        // Send alert through channels
        ea.sendAlert(alert)

        // Set cooldown
        ea.setCooldown(condition.ID, condition.Cooldown)

        // Update rate limit
        ea.updateRateLimit(condition.ID)

        // Log alert
        ea.logger.Error("Alert triggered",
                "alert_id", alert.ID,
                "condition_id", condition.ID,
                "type", alert.Type,
                "level", alert.Level,
                "title", alert.Title,
                "error_type", appErr.Type,
                "error_severity", appErr.Severity,
        )</span>
}

// generateAlertTitle generates alert title
func (ea *ErrorAlerter) generateAlertTitle(condition *AlertCondition, appErr *AppError) string <span class="cov2" title="6">{
        switch condition.Type </span>{
        case AlertTypeErrorRate:<span class="cov0" title="0">
                return fmt.Sprintf("High Error Rate: %s", appErr.Type)</span>
        case AlertTypeErrorSpike:<span class="cov0" title="0">
                return fmt.Sprintf("Error Spike Detected: %s", appErr.Type)</span>
        case AlertTypeNewError:<span class="cov2" title="6">
                return fmt.Sprintf("New Error Pattern: %s", appErr.Type)</span>
        case AlertTypeCriticalError:<span class="cov0" title="0">
                return fmt.Sprintf("Critical Error: %s", appErr.Type)</span>
        case AlertTypeServiceDegraded:<span class="cov0" title="0">
                return fmt.Sprintf("Service Degradation: %s", appErr.Type)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Alert: %s", condition.Name)</span>
        }
}

// generateAlertMessage generates alert message
func (ea *ErrorAlerter) generateAlertMessage(condition *AlertCondition, appErr *AppError) string <span class="cov2" title="6">{
        switch condition.Type </span>{
        case AlertTypeErrorRate:<span class="cov0" title="0">
                rate := ea.errorRates[string(appErr.Type)]
                return fmt.Sprintf("Error rate for %s has exceeded threshold. Current rate: %.2f errors/minute (threshold: %.2f)",
                        appErr.Type, rate, condition.Threshold)</span>
        case AlertTypeErrorSpike:<span class="cov0" title="0">
                count := ea.errorCounts[string(appErr.Type)]
                return fmt.Sprintf("Spike in %s errors detected. Count: %d in the last %v",
                        appErr.Type, count, condition.Window)</span>
        case AlertTypeNewError:<span class="cov2" title="6">
                return fmt.Sprintf("New error pattern detected: %s - %s", appErr.Type, appErr.Message)</span>
        case AlertTypeCriticalError:<span class="cov0" title="0">
                return fmt.Sprintf("Critical error occurred: %s", appErr.Message)</span>
        case AlertTypeServiceDegraded:<span class="cov0" title="0">
                return fmt.Sprintf("Service degradation detected due to %s errors", appErr.Type)</span>
        default:<span class="cov0" title="0">
                return condition.Description</span>
        }
}

// generateAlertDetails generates alert details
func (ea *ErrorAlerter) generateAlertDetails(condition *AlertCondition, appErr *AppError) map[string]interface{} <span class="cov2" title="6">{
        details := map[string]interface{}{
                "condition_name": condition.Name,
                "condition_type": condition.Type,
                "threshold":      condition.Threshold,
                "window":         condition.Window.String(),
                "error_id":       appErr.ID,
                "error_type":     appErr.Type,
                "error_code":     appErr.Code,
                "error_message":  appErr.Message,
                "error_severity": appErr.Severity,
                "error_category": appErr.Category,
                "timestamp":      appErr.Timestamp,
        }

        if appErr.Details != nil </span><span class="cov2" title="5">{
                details["error_details"] = appErr.Details
        }</span>

        <span class="cov2" title="6">if appErr.Context != nil </span><span class="cov2" title="5">{
                details["error_context"] = appErr.Context
        }</span>

        // Add current metrics
        <span class="cov2" title="6">if rate, exists := ea.errorRates[string(appErr.Type)]; exists </span><span class="cov0" title="0">{
                details["current_error_rate"] = rate
        }</span>

        <span class="cov2" title="6">if count, exists := ea.errorCounts[string(appErr.Type)]; exists </span><span class="cov2" title="6">{
                details["current_error_count"] = count
        }</span>

        <span class="cov2" title="6">return details</span>
}

// generateAlertContext generates alert context
func (ea *ErrorAlerter) generateAlertContext(appErr *AppError) map[string]interface{} <span class="cov2" title="6">{
        context := map[string]interface{}{
                "service":     "hotel-reviews",
                "environment": "production", // This could be configurable
                "timestamp":   time.Now(),
        }

        if appErr.CorrelationID != "" </span><span class="cov0" title="0">{
                context["correlation_id"] = appErr.CorrelationID
        }</span>

        <span class="cov2" title="6">if appErr.RequestID != "" </span><span class="cov0" title="0">{
                context["request_id"] = appErr.RequestID
        }</span>

        <span class="cov2" title="6">if appErr.UserID != "" </span><span class="cov0" title="0">{
                context["user_id"] = appErr.UserID
        }</span>

        <span class="cov2" title="6">if appErr.Source != "" </span><span class="cov2" title="5">{
                context["source"] = appErr.Source
        }</span>

        <span class="cov2" title="6">return context</span>
}

// generateAlertTags generates alert tags
func (ea *ErrorAlerter) generateAlertTags(condition *AlertCondition, appErr *AppError) []string <span class="cov2" title="6">{
        tags := []string{
                fmt.Sprintf("type:%s", appErr.Type),
                fmt.Sprintf("severity:%s", appErr.Severity),
                fmt.Sprintf("category:%s", appErr.Category),
                fmt.Sprintf("alert_type:%s", condition.Type),
                fmt.Sprintf("alert_level:%s", condition.Level),
        }

        if appErr.Retryable </span><span class="cov2" title="4">{
                tags = append(tags, "retryable:true")
        }</span> else<span class="cov1" title="2"> {
                tags = append(tags, "retryable:false")
        }</span>

        <span class="cov2" title="6">return tags</span>
}

// generateRunbook generates runbook link
func (ea *ErrorAlerter) generateRunbook(condition *AlertCondition) string <span class="cov2" title="6">{
        // This would typically return a link to documentation
        return fmt.Sprintf("https://docs.company.com/runbooks/%s", condition.Type)
}</span>

// generateActions generates suggested actions
func (ea *ErrorAlerter) generateActions(condition *AlertCondition, appErr *AppError) []string <span class="cov2" title="6">{
        actions := []string{
                "Check application logs",
                "Review system metrics",
                "Investigate error context",
        }

        switch condition.Type </span>{
        case AlertTypeErrorRate:<span class="cov0" title="0">
                actions = append(actions, "Check system load", "Review recent deployments")</span>
        case AlertTypeErrorSpike:<span class="cov0" title="0">
                actions = append(actions, "Check for recent changes", "Review traffic patterns")</span>
        case AlertTypeNewError:<span class="cov2" title="6">
                actions = append(actions, "Review recent code changes", "Check for new dependencies")</span>
        case AlertTypeCriticalError:<span class="cov0" title="0">
                actions = append(actions, "Escalate to on-call engineer", "Consider service rollback")</span>
        case AlertTypeServiceDegraded:<span class="cov0" title="0">
                actions = append(actions, "Check dependent services", "Review circuit breaker status")</span>
        }

        <span class="cov2" title="6">return actions</span>
}

// sendAlert sends alert through all configured channels
func (ea *ErrorAlerter) sendAlert(alert *Alert) <span class="cov2" title="6">{
        for _, channel := range ea.channels </span><span class="cov0" title="0">{
                if !channel.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">go func(ch AlertChannel) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                        defer cancel()

                        if err := ch.Send(ctx, alert); err != nil </span><span class="cov0" title="0">{
                                ea.logger.Error("Failed to send alert",
                                        "alert_id", alert.ID,
                                        "channel", ch.Name(),
                                        "error", err,
                                )
                        }</span>
                }(channel)
        }
}

// Helper methods for cooldown, suppression, and rate limiting

// isInCooldown checks if condition is in cooldown period
func (ea *ErrorAlerter) isInCooldown(conditionID string) bool <span class="cov8" title="1018">{
        if cooldownUntil, exists := ea.suppressions[conditionID]; exists </span><span class="cov8" title="1010">{
                return time.Now().Before(cooldownUntil)
        }</span>
        <span class="cov3" title="8">return false</span>
}

// setCooldown sets cooldown period for condition
func (ea *ErrorAlerter) setCooldown(conditionID string, duration time.Duration) <span class="cov2" title="6">{
        ea.suppressions[conditionID] = time.Now().Add(duration)
}</span>

// isSuppressed checks if condition is suppressed
func (ea *ErrorAlerter) isSuppressed(conditionID string) bool <span class="cov3" title="8">{
        // This would typically check a suppression database
        return false
}</span>

// isRateLimited checks if condition is rate limited
func (ea *ErrorAlerter) isRateLimited(conditionID string) bool <span class="cov3" title="8">{
        rateLimit, exists := ea.rateLimits[conditionID]
        if !exists </span><span class="cov3" title="8">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // Reset if window has passed
        if now.Sub(rateLimit.LastReset) &gt;= rateLimit.Window </span><span class="cov0" title="0">{
                rateLimit.Count = 0
                rateLimit.LastReset = now
                rateLimit.Timestamps = []time.Time{}
        }</span>

        // Check if we've exceeded the limit
        <span class="cov0" title="0">return rateLimit.Count &gt;= 10</span> // Max 10 alerts per window
}

// updateRateLimit updates rate limit for condition
func (ea *ErrorAlerter) updateRateLimit(conditionID string) <span class="cov2" title="6">{
        rateLimit, exists := ea.rateLimits[conditionID]
        if !exists </span><span class="cov2" title="6">{
                rateLimit = &amp;AlertRateLimit{
                        Count:      0,
                        Window:     time.Hour,
                        LastReset:  time.Now(),
                        Timestamps: []time.Time{},
                }
                ea.rateLimits[conditionID] = rateLimit
        }</span>

        <span class="cov2" title="6">rateLimit.Count++
        rateLimit.Timestamps = append(rateLimit.Timestamps, time.Now())</span>
}

// Public API methods

// AddCondition adds a new alert condition
func (ea *ErrorAlerter) AddCondition(condition *AlertCondition) <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        ea.conditions[condition.ID] = condition
}</span>

// RemoveCondition removes an alert condition
func (ea *ErrorAlerter) RemoveCondition(conditionID string) <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        delete(ea.conditions, conditionID)
}</span>

// GetConditions returns all alert conditions
func (ea *ErrorAlerter) GetConditions() map[string]*AlertCondition <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        conditions := make(map[string]*AlertCondition)
        for k, v := range ea.conditions </span><span class="cov0" title="0">{
                conditions[k] = v
        }</span>

        <span class="cov0" title="0">return conditions</span>
}

// GetActiveAlerts returns all active alerts
func (ea *ErrorAlerter) GetActiveAlerts() map[string]*Alert <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        alerts := make(map[string]*Alert)
        for k, v := range ea.activeAlerts </span><span class="cov0" title="0">{
                alerts[k] = v
        }</span>

        <span class="cov0" title="0">return alerts</span>
}

// GetAlertHistory returns alert history
func (ea *ErrorAlerter) GetAlertHistory() []*Alert <span class="cov0" title="0">{
        ea.mu.RLock()
        defer ea.mu.RUnlock()

        history := make([]*Alert, len(ea.alertHistory))
        copy(history, ea.alertHistory)

        return history
}</span>

// AddChannel adds an alert channel
func (ea *ErrorAlerter) AddChannel(channel AlertChannel) <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        ea.channels = append(ea.channels, channel)
}</span>

// AcknowledgeAlert acknowledges an alert
func (ea *ErrorAlerter) AcknowledgeAlert(alertID, acknowledgedBy string) error <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        for _, alert := range ea.activeAlerts </span><span class="cov0" title="0">{
                if alert.ID == alertID </span><span class="cov0" title="0">{
                        now := time.Now()
                        alert.AcknowledgedBy = acknowledgedBy
                        alert.AcknowledgedAt = &amp;now
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("alert not found: %s", alertID)</span>
}

// ResolveAlert resolves an alert
func (ea *ErrorAlerter) ResolveAlert(alertID string) error <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        for conditionID, alert := range ea.activeAlerts </span><span class="cov0" title="0">{
                if alert.ID == alertID </span><span class="cov0" title="0">{
                        now := time.Now()
                        alert.Status = "resolved"
                        alert.ResolvedAt = &amp;now
                        delete(ea.activeAlerts, conditionID)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("alert not found: %s", alertID)</span>
}

// SuppressCondition suppresses an alert condition
func (ea *ErrorAlerter) SuppressCondition(conditionID string, duration time.Duration) <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        ea.suppressions[conditionID] = time.Now().Add(duration)
}</span>

// startBackgroundProcesses starts background alert processes
func (ea *ErrorAlerter) startBackgroundProcesses() <span class="cov3" title="8">{
        ea.wg.Add(1)
        go ea.alertMaintenanceLoop()
}</span>

// alertMaintenanceLoop runs alert maintenance tasks
func (ea *ErrorAlerter) alertMaintenanceLoop() <span class="cov3" title="8">{
        defer ea.wg.Done()

        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for </span><span class="cov3" title="8">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ea.performMaintenance()</span>
                case &lt;-ea.shutdownCh:<span class="cov3" title="8">
                        return</span>
                }
        }
}

// performMaintenance performs alert maintenance tasks
func (ea *ErrorAlerter) performMaintenance() <span class="cov0" title="0">{
        ea.mu.Lock()
        defer ea.mu.Unlock()

        now := time.Now()

        // Clean up old suppressions
        for conditionID, suppressedUntil := range ea.suppressions </span><span class="cov0" title="0">{
                if now.After(suppressedUntil) </span><span class="cov0" title="0">{
                        delete(ea.suppressions, conditionID)
                }</span>
        }

        // Clean up old rate limits
        <span class="cov0" title="0">for conditionID, rateLimit := range ea.rateLimits </span><span class="cov0" title="0">{
                if now.Sub(rateLimit.LastReset) &gt;= rateLimit.Window*2 </span><span class="cov0" title="0">{
                        delete(ea.rateLimits, conditionID)
                }</span>
        }

        // Clean up old alert history
        <span class="cov0" title="0">if len(ea.alertHistory) &gt; 1000 </span><span class="cov0" title="0">{
                ea.alertHistory = ea.alertHistory[len(ea.alertHistory)-1000:]
        }</span>

        // Auto-resolve old alerts
        <span class="cov0" title="0">for conditionID, alert := range ea.activeAlerts </span><span class="cov0" title="0">{
                if now.Sub(alert.Timestamp) &gt;= 24*time.Hour </span><span class="cov0" title="0">{
                        alert.Status = "auto-resolved"
                        now := time.Now()
                        alert.ResolvedAt = &amp;now
                        delete(ea.activeAlerts, conditionID)
                }</span>
        }
}

// Close closes the alerter
func (ea *ErrorAlerter) Close() <span class="cov3" title="8">{
        ea.cancel()
        close(ea.shutdownCh)
        ea.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "net/http"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
        "github.com/google/uuid"
        "github.com/pkg/errors"
)

// ErrorType represents the type of error
type ErrorType string

const (
        // System errors
        ErrorTypeSystem         ErrorType = "system"
        ErrorTypeDatabase       ErrorType = "database"
        ErrorTypeNetwork        ErrorType = "network"
        ErrorTypeTimeout        ErrorType = "timeout"
        ErrorTypeCircuitBreaker ErrorType = "circuit_breaker"
        ErrorTypeRateLimit      ErrorType = "rate_limit"
        ErrorTypeResource       ErrorType = "resource"
        ErrorTypeConfiguration  ErrorType = "configuration"

        // Business errors
        ErrorTypeBusiness       ErrorType = "business"
        ErrorTypeValidation     ErrorType = "validation"
        ErrorTypeAuthentication ErrorType = "authentication"
        ErrorTypeAuthorization  ErrorType = "authorization"
        ErrorTypeNotFound       ErrorType = "not_found"
        ErrorTypeConflict       ErrorType = "conflict"
        ErrorTypePrecondition   ErrorType = "precondition"

        // External errors
        ErrorTypeExternal   ErrorType = "external"
        ErrorTypeThirdParty ErrorType = "third_party"
        ErrorTypeUpstream   ErrorType = "upstream"
        ErrorTypeDownstream ErrorType = "downstream"

        // Client errors
        ErrorTypeClient           ErrorType = "client"
        ErrorTypeMalformedRequest ErrorType = "malformed_request"
        ErrorTypeUnsupported      ErrorType = "unsupported"
)

// ErrorCategory represents the category of error
type ErrorCategory string

const (
        CategoryTransient    ErrorCategory = "transient"     // Temporary errors that may resolve
        CategoryPermanent    ErrorCategory = "permanent"     // Permanent errors that won't resolve
        CategoryRetryable    ErrorCategory = "retryable"     // Errors that can be retried
        CategoryNonRetryable ErrorCategory = "non_retryable" // Errors that shouldn't be retried
        CategoryCritical     ErrorCategory = "critical"      // Critical errors requiring immediate attention
        CategoryWarning      ErrorCategory = "warning"       // Warning-level errors
        CategoryInfo         ErrorCategory = "info"          // Informational errors
)

// ErrorSeverity represents the severity of an error
type ErrorSeverity string

const (
        SeverityLow      ErrorSeverity = "low"
        SeverityMedium   ErrorSeverity = "medium"
        SeverityHigh     ErrorSeverity = "high"
        SeverityCritical ErrorSeverity = "critical"
)

// ErrorFormat represents the format for error responses
type ErrorFormat string

const (
        FormatJSON ErrorFormat = "json"
        FormatXML  ErrorFormat = "xml"
        FormatText ErrorFormat = "text"
)

// AppError represents a structured application error
type AppError struct {
        ID            string                 `json:"id"`
        Type          ErrorType              `json:"type"`
        Category      ErrorCategory          `json:"category"`
        Severity      ErrorSeverity          `json:"severity"`
        Code          string                 `json:"code"`
        Message       string                 `json:"message"`
        UserMessage   string                 `json:"user_message,omitempty"`
        Details       map[string]interface{} `json:"details,omitempty"`
        Context       map[string]interface{} `json:"context,omitempty"`
        Timestamp     time.Time              `json:"timestamp"`
        CorrelationID string                 `json:"correlation_id,omitempty"`
        RequestID     string                 `json:"request_id,omitempty"`
        UserID        string                 `json:"user_id,omitempty"`
        Source        string                 `json:"source,omitempty"`
        StackTrace    string                 `json:"stack_trace,omitempty"`
        Cause         error                  `json:"-"`
        RetryAfter    *time.Duration         `json:"retry_after,omitempty"`
        HTTPStatus    int                    `json:"http_status"`
        Internal      bool                   `json:"internal"`
        Retryable     bool                   `json:"retryable"`
        Logged        bool                   `json:"logged"`
        Metrics       *ErrorMetrics          `json:"metrics,omitempty"`
}

// ErrorMetrics represents metrics for an error
type ErrorMetrics struct {
        Count         int64       `json:"count"`
        FirstSeen     time.Time   `json:"first_seen"`
        LastSeen      time.Time   `json:"last_seen"`
        Occurrences   []time.Time `json:"occurrences,omitempty"`
        AffectedUsers []string    `json:"affected_users,omitempty"`
        Sources       []string    `json:"sources,omitempty"`
}

// Error implements the error interface
func (e *AppError) Error() string <span class="cov1" title="2">{
        if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("error type: %s, code: %s", e.Type, e.Code)</span>
}

// Unwrap returns the underlying error
func (e *AppError) Unwrap() error <span class="cov1" title="1">{
        return e.Cause
}</span>

// IsRetryable returns true if the error is retryable
func (e *AppError) IsRetryable() bool <span class="cov2" title="3">{
        // Non-retryable category overrides everything
        if e.Category == CategoryNonRetryable </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov1" title="2">return e.Retryable || e.Category == CategoryRetryable</span>
}

// IsCritical returns true if the error is critical
func (e *AppError) IsCritical() bool <span class="cov2" title="3">{
        return e.Severity == SeverityCritical || e.Category == CategoryCritical
}</span>

// IsTemporary returns true if the error is temporary
func (e *AppError) IsTemporary() bool <span class="cov1" title="2">{
        return e.Category == CategoryTransient
}</span>

// ToJSON converts the error to JSON format
func (e *AppError) ToJSON() ([]byte, error) <span class="cov1" title="1">{
        return json.Marshal(e)
}</span>

// ToXML converts the error to XML format
func (e *AppError) ToXML() ([]byte, error) <span class="cov1" title="1">{
        // Create a simplified version for XML marshaling
        type XMLError struct {
                ID            string        `xml:"id"`
                Type          ErrorType     `xml:"type"`
                Category      ErrorCategory `xml:"category"`
                Severity      ErrorSeverity `xml:"severity"`
                Code          string        `xml:"code"`
                Message       string        `xml:"message"`
                UserMessage   string        `xml:"user_message,omitempty"`
                Timestamp     time.Time     `xml:"timestamp"`
                CorrelationID string        `xml:"correlation_id,omitempty"`
                RequestID     string        `xml:"request_id,omitempty"`
                UserID        string        `xml:"user_id,omitempty"`
                Source        string        `xml:"source,omitempty"`
                StackTrace    string        `xml:"stack_trace,omitempty"`
                HTTPStatus    int           `xml:"http_status"`
                Internal      bool          `xml:"internal"`
                Retryable     bool          `xml:"retryable"`
        }
        
        xmlErr := XMLError{
                ID:            e.ID,
                Type:          e.Type,
                Category:      e.Category,
                Severity:      e.Severity,
                Code:          e.Code,
                Message:       e.Message,
                UserMessage:   e.UserMessage,
                Timestamp:     e.Timestamp,
                CorrelationID: e.CorrelationID,
                RequestID:     e.RequestID,
                UserID:        e.UserID,
                Source:        e.Source,
                StackTrace:    e.StackTrace,
                HTTPStatus:    e.HTTPStatus,
                Internal:      e.Internal,
                Retryable:     e.Retryable,
        }
        
        return xml.Marshal(xmlErr)
}</span>

// ErrorResponse represents a structured error response
type ErrorResponse struct {
        Error     *AppError `json:"error"`
        Success   bool      `json:"success"`
        RequestID string    `json:"request_id,omitempty"`
        Timestamp time.Time `json:"timestamp"`
        Path      string    `json:"path,omitempty"`
        Method    string    `json:"method,omitempty"`
        Version   string    `json:"version,omitempty"`
        TraceID   string    `json:"trace_id,omitempty"`
}

// ErrorPattern represents a pattern for error detection
type ErrorPattern struct {
        Type           ErrorType      `json:"type"`
        MessagePattern string         `json:"message_pattern"`
        SourcePattern  string         `json:"source_pattern"`
        HTTPStatus     int            `json:"http_status"`
        Category       ErrorCategory  `json:"category"`
        Severity       ErrorSeverity  `json:"severity"`
        Retryable      bool           `json:"retryable"`
        RetryAfter     *time.Duration `json:"retry_after,omitempty"`
}

// ErrorHandlerConfig represents the configuration for error handling
type ErrorHandlerConfig struct {
        EnableMetrics          bool          `json:"enable_metrics"`
        EnableAlerting         bool          `json:"enable_alerting"`
        EnableStackTrace       bool          `json:"enable_stack_trace"`
        EnableDetailedLogging  bool          `json:"enable_detailed_logging"`
        EnableErrorAggregation bool          `json:"enable_error_aggregation"`
        EnableRateLimiting     bool          `json:"enable_rate_limiting"`
        MaxStackTraceDepth     int           `json:"max_stack_trace_depth"`
        ErrorRetentionPeriod   time.Duration `json:"error_retention_period"`
        MetricsInterval        time.Duration `json:"metrics_interval"`
        AlertingThreshold      int           `json:"alerting_threshold"`
        AlertingWindow         time.Duration `json:"alerting_window"`
        RateLimitWindow        time.Duration `json:"rate_limit_window"`
        RateLimitThreshold     int           `json:"rate_limit_threshold"`
        DefaultFormat          ErrorFormat   `json:"default_format"`
        IncludeInternalErrors  bool          `json:"include_internal_errors"`
        SanitizeUserData       bool          `json:"sanitize_user_data"`
}

// DefaultErrorHandlerConfig returns the default configuration
func DefaultErrorHandlerConfig() *ErrorHandlerConfig <span class="cov3" title="9">{
        return &amp;ErrorHandlerConfig{
                EnableMetrics:          true,
                EnableAlerting:         true,
                EnableStackTrace:       true,
                EnableDetailedLogging:  true,
                EnableErrorAggregation: true,
                EnableRateLimiting:     true,
                MaxStackTraceDepth:     50,
                ErrorRetentionPeriod:   24 * time.Hour,
                MetricsInterval:        30 * time.Second,
                AlertingThreshold:      10,
                AlertingWindow:         5 * time.Minute,
                RateLimitWindow:        time.Minute,
                RateLimitThreshold:     100,
                DefaultFormat:          FormatJSON,
                IncludeInternalErrors:  false,
                SanitizeUserData:       true,
        }
}</span>

// ErrorHandler handles all application errors
type ErrorHandler struct {
        config         *ErrorHandlerConfig
        logger         *logger.Logger
        patterns       []ErrorPattern
        aggregator     *ErrorAggregator
        metrics        *ErrorMetricsCollector
        alerter        *ErrorAlerter
        rateLimiter    *ErrorRateLimiter
        circuitBreaker *CircuitBreaker
        retryConfig    *RetryConfig
        healthChecker  *HealthChecker
        mu             sync.RWMutex
        errorStats     map[string]*ErrorMetrics
        errorHistory   map[string][]*AppError
        errorPatterns  map[string]int
        correlationMap map[string][]string
        shutdownChan   chan struct{}
        wg             sync.WaitGroup
}

// NewErrorHandler creates a new error handler
func NewErrorHandler(
        config *ErrorHandlerConfig,
        logger *logger.Logger,
        circuitBreaker *CircuitBreaker,
        retryConfig *RetryConfig,
) *ErrorHandler <span class="cov3" title="8">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultErrorHandlerConfig()
        }</span>

        <span class="cov3" title="8">eh := &amp;ErrorHandler{
                config:         config,
                logger:         logger,
                patterns:       defaultErrorPatterns(),
                circuitBreaker: circuitBreaker,
                retryConfig:    retryConfig,
                errorStats:     make(map[string]*ErrorMetrics),
                errorHistory:   make(map[string][]*AppError),
                errorPatterns:  make(map[string]int),
                correlationMap: make(map[string][]string),
                shutdownChan:   make(chan struct{}),
        }

        // Initialize components
        eh.aggregator = NewErrorAggregator(config, logger)
        if config.EnableMetrics </span><span class="cov1" title="1">{
                eh.metrics = NewErrorMetricsCollector(config, logger)
        }</span>
        <span class="cov3" title="8">eh.alerter = NewErrorAlerter(config, logger)
        eh.rateLimiter = NewErrorRateLimiter(config, logger)
        eh.healthChecker = NewHealthChecker(config, logger)

        // Start background processes
        eh.startBackgroundProcesses()

        return eh</span>
}

// Handle handles an error and returns a structured response
func (eh *ErrorHandler) Handle(ctx context.Context, err error) *AppError <span class="cov9" title="1017">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check if it's already an AppError
        <span class="cov9" title="1016">if appErr, ok := err.(*AppError); ok </span><span class="cov1" title="1">{
                return eh.enhanceError(ctx, appErr)
        }</span>

        // Create new AppError from regular error
        <span class="cov9" title="1015">appErr := eh.createAppError(ctx, err)
        return eh.enhanceError(ctx, appErr)</span>
}

// HandleHTTP handles an error for HTTP responses
func (eh *ErrorHandler) HandleHTTP(ctx context.Context, w http.ResponseWriter, r *http.Request, err error) <span class="cov2" title="3">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="3">appErr := eh.Handle(ctx, err)
        eh.writeHTTPResponse(ctx, w, r, appErr)</span>
}

// createAppError creates an AppError from a regular error
func (eh *ErrorHandler) createAppError(ctx context.Context, err error) *AppError <span class="cov9" title="1015">{
        // Check if error rate limiting is enabled
        if eh.config.EnableRateLimiting &amp;&amp; eh.rateLimiter.ShouldLimit(ctx, err) </span><span class="cov9" title="950">{
                return eh.createRateLimitError(ctx, err)
        }</span>

        // Classify error based on patterns
        <span class="cov6" title="65">pattern := eh.classifyError(err)

        appErr := &amp;AppError{
                ID:          uuid.New().String(),
                Type:        pattern.Type,
                Category:    pattern.Category,
                Severity:    pattern.Severity,
                Code:        eh.generateErrorCode(pattern.Type, err),
                Message:     err.Error(),
                UserMessage: eh.generateUserMessage(pattern.Type, err),
                Details:     eh.extractErrorDetails(err),
                Context:     eh.extractErrorContext(ctx),
                Timestamp:   time.Now(),
                Source:      eh.getErrorSource(),
                Cause:       err,
                HTTPStatus:  pattern.HTTPStatus,
                Internal:    eh.isInternalError(pattern.Type),
                Retryable:   pattern.Retryable,
                Logged:      false,
                RetryAfter:  pattern.RetryAfter,
        }

        // Add stack trace if enabled
        if eh.config.EnableStackTrace </span><span class="cov6" title="65">{
                appErr.StackTrace = eh.getStackTrace(eh.config.MaxStackTraceDepth)
        }</span>

        // Add correlation and request IDs
        <span class="cov6" title="65">appErr.CorrelationID = logger.GetCorrelationID(ctx)
        appErr.RequestID = logger.GetRequestID(ctx)
        appErr.UserID = logger.GetUserID(ctx)

        return appErr</span>
}

// enhanceError enhances an existing AppError with additional information
func (eh *ErrorHandler) enhanceError(ctx context.Context, appErr *AppError) *AppError <span class="cov9" title="1016">{
        // Initialize metrics if not present
        if appErr.Metrics == nil </span><span class="cov9" title="1016">{
                appErr.Metrics = &amp;ErrorMetrics{
                        Count:     1,
                        FirstSeen: appErr.Timestamp,
                        LastSeen:  appErr.Timestamp,
                }
        }</span>

        // Update error statistics
        <span class="cov9" title="1016">eh.updateErrorStats(appErr)

        // Record metrics
        if eh.config.EnableMetrics &amp;&amp; eh.metrics != nil </span><span class="cov3" title="5">{
                eh.metrics.RecordError(appErr)
        }</span>

        // Check for error patterns
        <span class="cov9" title="1016">if eh.config.EnableErrorAggregation </span><span class="cov9" title="1016">{
                eh.aggregator.RecordError(appErr)
        }</span>

        // Log error if not already logged
        <span class="cov9" title="1016">if !appErr.Logged </span><span class="cov9" title="1016">{
                eh.logError(ctx, appErr)
                appErr.Logged = true
        }</span>

        // Check alerting conditions
        <span class="cov9" title="1016">if eh.config.EnableAlerting </span><span class="cov9" title="1016">{
                eh.alerter.CheckAlertConditions(appErr)
        }</span>

        // Update health check status
        <span class="cov9" title="1016">eh.healthChecker.RecordError(appErr)

        return appErr</span>
}

// classifyError classifies an error based on patterns
func (eh *ErrorHandler) classifyError(err error) ErrorPattern <span class="cov6" title="75">{
        errMsg := err.Error()
        source := eh.getErrorSource()

        // Check built-in patterns
        for _, pattern := range eh.patterns </span><span class="cov9" title="554">{
                if eh.matchesPattern(errMsg, pattern.MessagePattern) ||
                        eh.matchesPattern(source, pattern.SourcePattern) </span><span class="cov4" title="13">{
                        return pattern
                }</span>
        }

        // Check for specific error types
        <span class="cov6" title="62">switch </span>{
        case eh.isTimeoutError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeTimeout,
                        HTTPStatus: http.StatusRequestTimeout,
                        Category:   CategoryTransient,
                        Severity:   SeverityMedium,
                        Retryable:  true,
                        RetryAfter: &amp;[]time.Duration{time.Second * 5}[0],
                }</span>
        case eh.isNetworkError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeNetwork,
                        HTTPStatus: http.StatusBadGateway,
                        Category:   CategoryTransient,
                        Severity:   SeverityMedium,
                        Retryable:  true,
                        RetryAfter: &amp;[]time.Duration{time.Second * 3}[0],
                }</span>
        case eh.isDatabaseError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeDatabase,
                        HTTPStatus: http.StatusInternalServerError,
                        Category:   CategoryTransient,
                        Severity:   SeverityHigh,
                        Retryable:  true,
                        RetryAfter: &amp;[]time.Duration{time.Second * 2}[0],
                }</span>
        case eh.isValidationError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeValidation,
                        HTTPStatus: http.StatusBadRequest,
                        Category:   CategoryPermanent,
                        Severity:   SeverityLow,
                        Retryable:  false,
                }</span>
        case eh.isAuthenticationError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeAuthentication,
                        HTTPStatus: http.StatusUnauthorized,
                        Category:   CategoryPermanent,
                        Severity:   SeverityMedium,
                        Retryable:  false,
                }</span>
        case eh.isAuthorizationError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeAuthorization,
                        HTTPStatus: http.StatusForbidden,
                        Category:   CategoryPermanent,
                        Severity:   SeverityMedium,
                        Retryable:  false,
                }</span>
        case eh.isNotFoundError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeNotFound,
                        HTTPStatus: http.StatusNotFound,
                        Category:   CategoryPermanent,
                        Severity:   SeverityLow,
                        Retryable:  false,
                }</span>
        case eh.isConflictError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeConflict,
                        HTTPStatus: http.StatusConflict,
                        Category:   CategoryPermanent,
                        Severity:   SeverityMedium,
                        Retryable:  false,
                }</span>
        case eh.isCircuitBreakerError(err):<span class="cov0" title="0">
                return ErrorPattern{
                        Type:       ErrorTypeCircuitBreaker,
                        HTTPStatus: http.StatusServiceUnavailable,
                        Category:   CategoryTransient,
                        Severity:   SeverityHigh,
                        Retryable:  true,
                        RetryAfter: &amp;[]time.Duration{time.Second * 10}[0],
                }</span>
        case eh.isRateLimitError(err):<span class="cov1" title="2">
                return ErrorPattern{
                        Type:       ErrorTypeRateLimit,
                        HTTPStatus: http.StatusTooManyRequests,
                        Category:   CategoryTransient,
                        Severity:   SeverityMedium,
                        Retryable:  true,
                        RetryAfter: &amp;[]time.Duration{time.Second * 60}[0],
                }</span>
        }

        // Default pattern
        <span class="cov6" title="60">return ErrorPattern{
                Type:       ErrorTypeSystem,
                HTTPStatus: http.StatusInternalServerError,
                Category:   CategoryTransient,
                Severity:   SeverityMedium,
                Retryable:  true,
                RetryAfter: &amp;[]time.Duration{time.Second * 5}[0],
        }</span>
}

// writeHTTPResponse writes an HTTP error response
func (eh *ErrorHandler) writeHTTPResponse(ctx context.Context, w http.ResponseWriter, r *http.Request, appErr *AppError) <span class="cov2" title="3">{
        // Determine response format
        format := eh.getResponseFormat(r)

        // Create error response
        response := &amp;ErrorResponse{
                Error:     appErr,
                Success:   false,
                RequestID: appErr.RequestID,
                Timestamp: time.Now(),
                Path:      r.URL.Path,
                Method:    r.Method,
                Version:   "1.0",
                TraceID:   logger.GetTraceID(ctx),
        }

        // Sanitize response if needed
        if eh.config.SanitizeUserData </span><span class="cov2" title="3">{
                response = eh.sanitizeResponse(response)
        }</span>

        // Set response headers
        <span class="cov2" title="3">w.Header().Set("Content-Type", eh.getContentType(format))
        w.Header().Set("X-Error-ID", appErr.ID)
        w.Header().Set("X-Error-Type", string(appErr.Type))

        if appErr.CorrelationID != "" </span><span class="cov0" title="0">{
                w.Header().Set("X-Correlation-ID", appErr.CorrelationID)
        }</span>

        <span class="cov2" title="3">if appErr.RetryAfter != nil </span><span class="cov2" title="3">{
                w.Header().Set("Retry-After", strconv.Itoa(int(appErr.RetryAfter.Seconds())))
        }</span>

        // Write response
        <span class="cov2" title="3">w.WriteHeader(appErr.HTTPStatus)

        var responseData []byte
        var err error

        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                responseData, err = json.Marshal(response)</span>
        case FormatXML:<span class="cov1" title="1">
                responseData, err = xml.Marshal(response)</span>
        case FormatText:<span class="cov1" title="1">
                responseData = []byte(appErr.Message)</span>
        default:<span class="cov0" title="0">
                responseData, err = json.Marshal(response)</span>
        }

        <span class="cov2" title="3">if err != nil </span><span class="cov1" title="1">{
                eh.logger.ErrorContext(ctx, "Failed to marshal error response", "error", err)
                w.Write([]byte(`{"error": "Internal server error"}`))
                return
        }</span>

        <span class="cov1" title="2">w.Write(responseData)</span>
}

// Error type checking methods
func (eh *ErrorHandler) isTimeoutError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "timeout") ||
                strings.Contains(err.Error(), "deadline exceeded") ||
                errors.Is(err, context.DeadlineExceeded)
}</span>

func (eh *ErrorHandler) isNetworkError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "network") ||
                strings.Contains(err.Error(), "connection") ||
                strings.Contains(err.Error(), "no route to host") ||
                strings.Contains(err.Error(), "connection refused")
}</span>

func (eh *ErrorHandler) isDatabaseError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "database") ||
                strings.Contains(err.Error(), "sql") ||
                strings.Contains(err.Error(), "postgres") ||
                strings.Contains(err.Error(), "mysql") ||
                strings.Contains(err.Error(), "gorm")
}</span>

func (eh *ErrorHandler) isValidationError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "validation") ||
                strings.Contains(err.Error(), "invalid") ||
                strings.Contains(err.Error(), "required") ||
                strings.Contains(err.Error(), "malformed")
}</span>

func (eh *ErrorHandler) isAuthenticationError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "authentication") ||
                strings.Contains(err.Error(), "unauthorized") ||
                strings.Contains(err.Error(), "invalid credentials") ||
                strings.Contains(err.Error(), "login failed")
}</span>

func (eh *ErrorHandler) isAuthorizationError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "authorization") ||
                strings.Contains(err.Error(), "forbidden") ||
                strings.Contains(err.Error(), "access denied") ||
                strings.Contains(err.Error(), "permission denied")
}</span>

func (eh *ErrorHandler) isNotFoundError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "not found") ||
                strings.Contains(err.Error(), "record not found") ||
                strings.Contains(err.Error(), "does not exist")
}</span>

func (eh *ErrorHandler) isConflictError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "conflict") ||
                strings.Contains(err.Error(), "already exists") ||
                strings.Contains(err.Error(), "duplicate") ||
                strings.Contains(err.Error(), "unique constraint")
}</span>

func (eh *ErrorHandler) isCircuitBreakerError(err error) bool <span class="cov6" title="62">{
        return IsCircuitBreakerError(err) ||
                strings.Contains(err.Error(), "circuit breaker")
}</span>

func (eh *ErrorHandler) isRateLimitError(err error) bool <span class="cov6" title="62">{
        return strings.Contains(err.Error(), "rate limit") ||
                strings.Contains(err.Error(), "too many requests") ||
                strings.Contains(err.Error(), "quota exceeded")
}</span>

func (eh *ErrorHandler) isInternalError(errorType ErrorType) bool <span class="cov6" title="65">{
        return errorType == ErrorTypeSystem ||
                errorType == ErrorTypeDatabase ||
                errorType == ErrorTypeConfiguration ||
                errorType == ErrorTypeResource
}</span>

// Helper methods
func (eh *ErrorHandler) matchesPattern(text, pattern string) bool <span class="cov10" title="1095">{
        if pattern == "" </span><span class="cov9" title="541">{
                return false
        }</span>
        <span class="cov9" title="554">return strings.Contains(strings.ToLower(text), strings.ToLower(pattern))</span>
}

func (eh *ErrorHandler) generateErrorCode(errorType ErrorType, err error) string <span class="cov6" title="65">{
        base := strings.ToUpper(string(errorType))
        hash := fmt.Sprintf("%x", []byte(err.Error()))
        if len(hash) &gt; 8 </span><span class="cov6" title="65">{
                hash = hash[:8]
        }</span>
        <span class="cov6" title="65">return fmt.Sprintf("%s_%s", base, hash)</span>
}

func (eh *ErrorHandler) generateUserMessage(errorType ErrorType, err error) string <span class="cov6" title="65">{
        switch errorType </span>{
        case ErrorTypeValidation:<span class="cov1" title="1">
                return "Please check your input and try again."</span>
        case ErrorTypeAuthentication:<span class="cov1" title="1">
                return "Please check your credentials and try again."</span>
        case ErrorTypeAuthorization:<span class="cov0" title="0">
                return "You don't have permission to perform this action."</span>
        case ErrorTypeNotFound:<span class="cov0" title="0">
                return "The requested resource was not found."</span>
        case ErrorTypeConflict:<span class="cov0" title="0">
                return "The resource already exists or conflicts with existing data."</span>
        case ErrorTypeTimeout:<span class="cov1" title="1">
                return "The request timed out. Please try again."</span>
        case ErrorTypeNetwork:<span class="cov0" title="0">
                return "Network error occurred. Please check your connection."</span>
        case ErrorTypeRateLimit:<span class="cov1" title="1">
                return "Too many requests. Please wait before trying again."</span>
        case ErrorTypeCircuitBreaker:<span class="cov0" title="0">
                return "Service temporarily unavailable. Please try again later."</span>
        default:<span class="cov6" title="61">
                return "An unexpected error occurred. Please try again."</span>
        }
}

func (eh *ErrorHandler) extractErrorDetails(err error) map[string]interface{} <span class="cov6" title="65">{
        details := make(map[string]interface{})

        // Extract details from wrapped errors
        if unwrapped := errors.Unwrap(err); unwrapped != nil </span><span class="cov0" title="0">{
                details["underlying_error"] = unwrapped.Error()
        }</span>

        // Extract details from error type
        <span class="cov6" title="65">details["error_type"] = fmt.Sprintf("%T", err)

        return details</span>
}

func (eh *ErrorHandler) extractErrorContext(ctx context.Context) map[string]interface{} <span class="cov6" title="65">{
        context := make(map[string]interface{})

        // Add context values
        if requestID := logger.GetRequestID(ctx); requestID != "" </span><span class="cov0" title="0">{
                context["request_id"] = requestID
        }</span>

        <span class="cov6" title="65">if userID := logger.GetUserID(ctx); userID != "" </span><span class="cov0" title="0">{
                context["user_id"] = userID
        }</span>

        <span class="cov6" title="65">if traceID := logger.GetTraceID(ctx); traceID != "" </span><span class="cov0" title="0">{
                context["trace_id"] = traceID
        }</span>

        <span class="cov6" title="65">return context</span>
}

func (eh *ErrorHandler) getErrorSource() string <span class="cov7" title="140">{
        if pc, file, line, ok := runtime.Caller(3); ok </span><span class="cov7" title="140">{
                fn := runtime.FuncForPC(pc)
                if fn != nil </span><span class="cov7" title="140">{
                        return fmt.Sprintf("%s:%d (%s)", file, line, fn.Name())
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s:%d", file, line)</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

func (eh *ErrorHandler) getStackTrace(maxDepth int) string <span class="cov6" title="65">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        stack := string(buf[:n])

        // Limit stack trace depth
        lines := strings.Split(stack, "\n")
        if len(lines) &gt; maxDepth*2 </span><span class="cov0" title="0">{
                lines = lines[:maxDepth*2]
        }</span>

        <span class="cov6" title="65">return strings.Join(lines, "\n")</span>
}

func (eh *ErrorHandler) getResponseFormat(r *http.Request) ErrorFormat <span class="cov2" title="3">{
        // Check Accept header
        accept := r.Header.Get("Accept")
        switch </span>{
        case strings.Contains(accept, "application/json"):<span class="cov1" title="1">
                return FormatJSON</span>
        case strings.Contains(accept, "application/xml"):<span class="cov1" title="1">
                return FormatXML</span>
        case strings.Contains(accept, "text/plain"):<span class="cov1" title="1">
                return FormatText</span>
        default:<span class="cov0" title="0">
                return eh.config.DefaultFormat</span>
        }
}

func (eh *ErrorHandler) getContentType(format ErrorFormat) string <span class="cov2" title="3">{
        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                return "application/json"</span>
        case FormatXML:<span class="cov1" title="1">
                return "application/xml"</span>
        case FormatText:<span class="cov1" title="1">
                return "text/plain"</span>
        default:<span class="cov0" title="0">
                return "application/json"</span>
        }
}

func (eh *ErrorHandler) sanitizeResponse(response *ErrorResponse) *ErrorResponse <span class="cov2" title="3">{
        // Create a copy
        sanitized := *response
        sanitized.Error = &amp;AppError{}
        *sanitized.Error = *response.Error

        // Remove sensitive information
        if sanitized.Error.Internal </span><span class="cov2" title="3">{
                sanitized.Error.StackTrace = ""
                sanitized.Error.Details = nil
                sanitized.Error.Context = nil
                sanitized.Error.Source = ""
        }</span>

        <span class="cov2" title="3">return &amp;sanitized</span>
}

func (eh *ErrorHandler) createRateLimitError(ctx context.Context, err error) *AppError <span class="cov9" title="950">{
        return &amp;AppError{
                ID:            uuid.New().String(),
                Type:          ErrorTypeRateLimit,
                Category:      CategoryTransient,
                Severity:      SeverityMedium,
                Code:          "RATE_LIMIT_EXCEEDED",
                Message:       "Rate limit exceeded",
                UserMessage:   "Too many requests. Please wait before trying again.",
                Timestamp:     time.Now(),
                HTTPStatus:    http.StatusTooManyRequests,
                Retryable:     true,
                RetryAfter:    &amp;[]time.Duration{time.Minute}[0],
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }
}</span>

func (eh *ErrorHandler) updateErrorStats(appErr *AppError) <span class="cov9" title="1016">{
        eh.mu.Lock()
        defer eh.mu.Unlock()

        key := fmt.Sprintf("%s:%s", appErr.Type, appErr.Code)

        if stats, exists := eh.errorStats[key]; exists </span><span class="cov9" title="1004">{
                atomic.AddInt64(&amp;stats.Count, 1)
                stats.LastSeen = appErr.Timestamp
                stats.Occurrences = append(stats.Occurrences, appErr.Timestamp)

                // Add user ID if present
                if appErr.UserID != "" </span><span class="cov0" title="0">{
                        stats.AffectedUsers = append(stats.AffectedUsers, appErr.UserID)
                }</span>

                // Add source if present
                <span class="cov9" title="1004">if appErr.Source != "" </span><span class="cov6" title="55">{
                        stats.Sources = append(stats.Sources, appErr.Source)
                }</span>
        } else<span class="cov4" title="12"> {
                eh.errorStats[key] = &amp;ErrorMetrics{
                        Count:       1,
                        FirstSeen:   appErr.Timestamp,
                        LastSeen:    appErr.Timestamp,
                        Occurrences: []time.Time{appErr.Timestamp},
                        AffectedUsers: func() []string </span><span class="cov4" title="12">{
                                if appErr.UserID != "" </span><span class="cov0" title="0">{
                                        return []string{appErr.UserID}
                                }</span>
                                <span class="cov4" title="12">return nil</span>
                        }(),
                        Sources: func() []string <span class="cov4" title="12">{
                                if appErr.Source != "" </span><span class="cov3" title="10">{
                                        return []string{appErr.Source}
                                }</span>
                                <span class="cov1" title="2">return nil</span>
                        }(),
                }
        }
}

func (eh *ErrorHandler) logError(ctx context.Context, appErr *AppError) <span class="cov9" title="1016">{
        fields := map[string]interface{}{
                "error_id":       appErr.ID,
                "error_type":     appErr.Type,
                "error_category": appErr.Category,
                "error_severity": appErr.Severity,
                "error_code":     appErr.Code,
                "http_status":    appErr.HTTPStatus,
                "retryable":      appErr.Retryable,
                "internal":       appErr.Internal,
        }

        if appErr.Details != nil </span><span class="cov6" title="65">{
                fields["details"] = appErr.Details
        }</span>

        <span class="cov9" title="1016">if appErr.Context != nil </span><span class="cov6" title="65">{
                fields["context"] = appErr.Context
        }</span>

        <span class="cov9" title="1016">if appErr.Source != "" </span><span class="cov6" title="65">{
                fields["source"] = appErr.Source
        }</span>

        // Log based on severity
        <span class="cov9" title="1016">switch appErr.Severity </span>{
        case SeverityLow:<span class="cov1" title="1">
                eh.logger.WithFields(fields).InfoContext(ctx, appErr.Message)</span>
        case SeverityMedium:<span class="cov9" title="1013">
                eh.logger.WithFields(fields).WarnContext(ctx, appErr.Message)</span>
        case SeverityHigh, SeverityCritical:<span class="cov1" title="1">
                // Include stack trace for high severity errors
                if appErr.StackTrace != "" </span><span class="cov1" title="1">{
                        fields["stack_trace"] = appErr.StackTrace
                }</span>
                <span class="cov1" title="1">eh.logger.WithFields(fields).ErrorContext(ctx, appErr.Message)</span>
        }
}

func (eh *ErrorHandler) startBackgroundProcesses() <span class="cov3" title="8">{
        // Start metrics collection
        if eh.config.EnableMetrics </span><span class="cov1" title="1">{
                eh.wg.Add(1)
                go eh.metricsCollectionLoop()
        }</span>

        // Start error cleanup
        <span class="cov3" title="8">eh.wg.Add(1)
        go eh.cleanupLoop()</span>
}

func (eh *ErrorHandler) metricsCollectionLoop() <span class="cov1" title="1">{
        defer eh.wg.Done()

        ticker := time.NewTicker(eh.config.MetricsInterval)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        eh.collectMetrics()</span>
                case &lt;-eh.shutdownChan:<span class="cov1" title="1">
                        return</span>
                }
        }
}

func (eh *ErrorHandler) cleanupLoop() <span class="cov3" title="8">{
        defer eh.wg.Done()

        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()

        for </span><span class="cov3" title="8">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        eh.cleanupOldErrors()</span>
                case &lt;-eh.shutdownChan:<span class="cov3" title="8">
                        return</span>
                }
        }
}

func (eh *ErrorHandler) collectMetrics() <span class="cov0" title="0">{
        eh.mu.RLock()
        defer eh.mu.RUnlock()

        // Collect error statistics
        for key, stats := range eh.errorStats </span><span class="cov0" title="0">{
                parts := strings.Split(key, ":")
                if len(parts) &gt;= 2 &amp;&amp; eh.metrics != nil </span><span class="cov0" title="0">{
                        eh.metrics.UpdateErrorStats(parts[0], parts[1], stats)
                }</span>
        }
}

func (eh *ErrorHandler) cleanupOldErrors() <span class="cov0" title="0">{
        eh.mu.Lock()
        defer eh.mu.Unlock()

        cutoff := time.Now().Add(-eh.config.ErrorRetentionPeriod)

        // Clean up old error statistics
        for key, stats := range eh.errorStats </span><span class="cov0" title="0">{
                if stats.LastSeen.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(eh.errorStats, key)
                }</span>
        }

        // Clean up old error history
        <span class="cov0" title="0">for key, history := range eh.errorHistory </span><span class="cov0" title="0">{
                filtered := make([]*AppError, 0)
                for _, err := range history </span><span class="cov0" title="0">{
                        if err.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                                filtered = append(filtered, err)
                        }</span>
                }

                <span class="cov0" title="0">if len(filtered) == 0 </span><span class="cov0" title="0">{
                        delete(eh.errorHistory, key)
                }</span> else<span class="cov0" title="0"> {
                        eh.errorHistory[key] = filtered
                }</span>
        }
}

// Public API methods

// AddErrorPattern adds a custom error pattern
func (eh *ErrorHandler) AddErrorPattern(pattern ErrorPattern) <span class="cov1" title="1">{
        eh.mu.Lock()
        defer eh.mu.Unlock()

        eh.patterns = append(eh.patterns, pattern)
}</span>

// GetErrorStats returns error statistics
func (eh *ErrorHandler) GetErrorStats() map[string]*ErrorMetrics <span class="cov2" title="3">{
        eh.mu.RLock()
        defer eh.mu.RUnlock()

        stats := make(map[string]*ErrorMetrics)
        for key, metrics := range eh.errorStats </span><span class="cov3" title="8">{
                stats[key] = metrics
        }</span>

        <span class="cov2" title="3">return stats</span>
}

// GetErrorHistory returns error history
func (eh *ErrorHandler) GetErrorHistory() map[string][]*AppError <span class="cov0" title="0">{
        eh.mu.RLock()
        defer eh.mu.RUnlock()

        history := make(map[string][]*AppError)
        for key, errors := range eh.errorHistory </span><span class="cov0" title="0">{
                history[key] = errors
        }</span>

        <span class="cov0" title="0">return history</span>
}

// IsHealthy returns true if the error handler is healthy
func (eh *ErrorHandler) IsHealthy() bool <span class="cov1" title="2">{
        return eh.healthChecker.IsHealthy()
}</span>

// GetHealthStatus returns the health status
func (eh *ErrorHandler) GetHealthStatus() map[string]interface{} <span class="cov1" title="2">{
        return eh.healthChecker.GetHealthStatus()
}</span>

// Close closes the error handler
func (eh *ErrorHandler) Close() error <span class="cov3" title="8">{
        close(eh.shutdownChan)
        eh.wg.Wait()

        // Close components
        if eh.metrics != nil </span><span class="cov1" title="1">{
                eh.metrics.Close()
        }</span>
        <span class="cov3" title="8">if eh.alerter != nil </span><span class="cov3" title="8">{
                eh.alerter.Close()
        }</span>
        <span class="cov3" title="8">if eh.healthChecker != nil </span><span class="cov3" title="8">{
                eh.healthChecker.Close()
        }</span>

        <span class="cov3" title="8">return nil</span>
}

// defaultErrorPatterns returns default error patterns
func defaultErrorPatterns() []ErrorPattern <span class="cov3" title="8">{
        return []ErrorPattern{
                {
                        Type:           ErrorTypeTimeout,
                        MessagePattern: "timeout",
                        HTTPStatus:     http.StatusRequestTimeout,
                        Category:       CategoryTransient,
                        Severity:       SeverityMedium,
                        Retryable:      true,
                        RetryAfter:     &amp;[]time.Duration{time.Second * 5}[0],
                },
                {
                        Type:           ErrorTypeNetwork,
                        MessagePattern: "network",
                        HTTPStatus:     http.StatusBadGateway,
                        Category:       CategoryTransient,
                        Severity:       SeverityMedium,
                        Retryable:      true,
                        RetryAfter:     &amp;[]time.Duration{time.Second * 3}[0],
                },
                {
                        Type:           ErrorTypeDatabase,
                        MessagePattern: "database",
                        HTTPStatus:     http.StatusInternalServerError,
                        Category:       CategoryTransient,
                        Severity:       SeverityHigh,
                        Retryable:      true,
                        RetryAfter:     &amp;[]time.Duration{time.Second * 2}[0],
                },
                {
                        Type:           ErrorTypeValidation,
                        MessagePattern: "validation",
                        HTTPStatus:     http.StatusBadRequest,
                        Category:       CategoryPermanent,
                        Severity:       SeverityLow,
                        Retryable:      false,
                },
                {
                        Type:           ErrorTypeAuthentication,
                        MessagePattern: "authentication",
                        HTTPStatus:     http.StatusUnauthorized,
                        Category:       CategoryPermanent,
                        Severity:       SeverityMedium,
                        Retryable:      false,
                },
                {
                        Type:           ErrorTypeAuthorization,
                        MessagePattern: "authorization",
                        HTTPStatus:     http.StatusForbidden,
                        Category:       CategoryPermanent,
                        Severity:       SeverityMedium,
                        Retryable:      false,
                },
                {
                        Type:           ErrorTypeNotFound,
                        MessagePattern: "not found",
                        HTTPStatus:     http.StatusNotFound,
                        Category:       CategoryPermanent,
                        Severity:       SeverityLow,
                        Retryable:      false,
                },
                {
                        Type:           ErrorTypeConflict,
                        MessagePattern: "conflict",
                        HTTPStatus:     http.StatusConflict,
                        Category:       CategoryPermanent,
                        Severity:       SeverityMedium,
                        Retryable:      false,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// HealthStatus represents the health status
type HealthStatus string

const (
        HealthStatusHealthy   HealthStatus = "healthy"
        HealthStatusDegraded  HealthStatus = "degraded"
        HealthStatusUnhealthy HealthStatus = "unhealthy"
        HealthStatusUnknown   HealthStatus = "unknown"
)

// HealthMetric represents a health metric
type HealthMetric struct {
        Name        string       `json:"name"`
        Value       float64      `json:"value"`
        Threshold   float64      `json:"threshold"`
        Status      HealthStatus `json:"status"`
        LastUpdated time.Time    `json:"last_updated"`
        Description string       `json:"description"`
}

// HealthCheck represents a health check
type HealthCheck struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Status     HealthStatus           `json:"status"`
        Message    string                 `json:"message"`
        Details    map[string]interface{} `json:"details"`
        Timestamp  time.Time              `json:"timestamp"`
        Duration   time.Duration          `json:"duration"`
        Metrics    []*HealthMetric        `json:"metrics"`
        LastError  string                 `json:"last_error,omitempty"`
        ErrorCount int                    `json:"error_count"`
        Enabled    bool                   `json:"enabled"`
}

// HealthCondition represents a health condition
type HealthCondition struct {
        ID              string        `json:"id"`
        Name            string        `json:"name"`
        Description     string        `json:"description"`
        MetricName      string        `json:"metric_name"`
        Operator        string        `json:"operator"` // gt, lt, eq, ge, le
        Threshold       float64       `json:"threshold"`
        Window          time.Duration `json:"window"`
        ConsecutiveHits int           `json:"consecutive_hits"`
        Enabled         bool          `json:"enabled"`
        CreatedAt       time.Time     `json:"created_at"`
        UpdatedAt       time.Time     `json:"updated_at"`
}

// HealthEvent represents a health event
type HealthEvent struct {
        ID          string                 `json:"id"`
        Type        string                 `json:"type"` // status_change, threshold_breach, recovery
        Status      HealthStatus           `json:"status"`
        PrevStatus  HealthStatus           `json:"prev_status"`
        Message     string                 `json:"message"`
        Details     map[string]interface{} `json:"details"`
        Timestamp   time.Time              `json:"timestamp"`
        ConditionID string                 `json:"condition_id,omitempty"`
        Severity    string                 `json:"severity"`
}

// HealthChecker monitors system health based on error patterns
type HealthChecker struct {
        config *ErrorHandlerConfig
        logger *logger.Logger
        mu     sync.RWMutex

        // Health tracking
        currentStatus    HealthStatus
        lastStatusChange time.Time
        checks           map[string]*HealthCheck
        conditions       map[string]*HealthCondition
        metrics          map[string]*HealthMetric
        events           []*HealthEvent

        // Error tracking for health
        errorRates  map[string]float64
        errorCounts map[string]int64
        errorTrends map[string][]float64
        lastUpdate  time.Time

        // Thresholds
        healthyThreshold   float64
        degradedThreshold  float64
        unhealthyThreshold float64

        // Background processes
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        shutdownCh chan struct{}
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(config *ErrorHandlerConfig, logger *logger.Logger) *HealthChecker <span class="cov3" title="8">{
        ctx, cancel := context.WithCancel(context.Background())

        hc := &amp;HealthChecker{
                config:             config,
                logger:             logger,
                currentStatus:      HealthStatusHealthy,
                lastStatusChange:   time.Now(),
                checks:             make(map[string]*HealthCheck),
                conditions:         make(map[string]*HealthCondition),
                metrics:            make(map[string]*HealthMetric),
                events:             make([]*HealthEvent, 0),
                errorRates:         make(map[string]float64),
                errorCounts:        make(map[string]int64),
                errorTrends:        make(map[string][]float64),
                lastUpdate:         time.Now(),
                healthyThreshold:   5.0,  // 5 errors per minute
                degradedThreshold:  20.0, // 20 errors per minute
                unhealthyThreshold: 50.0, // 50 errors per minute
                ctx:                ctx,
                cancel:             cancel,
                shutdownCh:         make(chan struct{}),
        }

        // Initialize default checks and conditions
        hc.initializeDefaultChecks()
        hc.initializeDefaultConditions()

        // Start background processes
        hc.startBackgroundProcesses()

        return hc
}</span>

// initializeDefaultChecks initializes default health checks
func (hc *HealthChecker) initializeDefaultChecks() <span class="cov3" title="8">{
        defaultChecks := []*HealthCheck{
                {
                        ID:        "error_rate",
                        Name:      "Error Rate Check",
                        Status:    HealthStatusHealthy,
                        Message:   "System error rate is within acceptable limits",
                        Details:   make(map[string]interface{}),
                        Timestamp: time.Now(),
                        Metrics:   make([]*HealthMetric, 0),
                        Enabled:   true,
                },
                {
                        ID:        "critical_errors",
                        Name:      "Critical Errors Check",
                        Status:    HealthStatusHealthy,
                        Message:   "No critical errors detected",
                        Details:   make(map[string]interface{}),
                        Timestamp: time.Now(),
                        Metrics:   make([]*HealthMetric, 0),
                        Enabled:   true,
                },
                {
                        ID:        "system_stability",
                        Name:      "System Stability Check",
                        Status:    HealthStatusHealthy,
                        Message:   "System is stable",
                        Details:   make(map[string]interface{}),
                        Timestamp: time.Now(),
                        Metrics:   make([]*HealthMetric, 0),
                        Enabled:   true,
                },
                {
                        ID:        "error_trends",
                        Name:      "Error Trends Check",
                        Status:    HealthStatusHealthy,
                        Message:   "Error trends are stable",
                        Details:   make(map[string]interface{}),
                        Timestamp: time.Now(),
                        Metrics:   make([]*HealthMetric, 0),
                        Enabled:   true,
                },
        }

        for _, check := range defaultChecks </span><span class="cov4" title="32">{
                hc.checks[check.ID] = check
        }</span>
}

// initializeDefaultConditions initializes default health conditions
func (hc *HealthChecker) initializeDefaultConditions() <span class="cov3" title="8">{
        defaultConditions := []*HealthCondition{
                {
                        ID:              "high_error_rate",
                        Name:            "High Error Rate",
                        Description:     "Triggers when error rate exceeds threshold",
                        MetricName:      "error_rate",
                        Operator:        "gt",
                        Threshold:       20.0,
                        Window:          5 * time.Minute,
                        ConsecutiveHits: 3,
                        Enabled:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                },
                {
                        ID:              "critical_error_spike",
                        Name:            "Critical Error Spike",
                        Description:     "Triggers when critical errors spike",
                        MetricName:      "critical_error_rate",
                        Operator:        "gt",
                        Threshold:       5.0,
                        Window:          2 * time.Minute,
                        ConsecutiveHits: 2,
                        Enabled:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                },
                {
                        ID:              "error_trend_degradation",
                        Name:            "Error Trend Degradation",
                        Description:     "Triggers when error trends show degradation",
                        MetricName:      "error_trend_slope",
                        Operator:        "gt",
                        Threshold:       0.5,
                        Window:          10 * time.Minute,
                        ConsecutiveHits: 5,
                        Enabled:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                },
                {
                        ID:              "system_instability",
                        Name:            "System Instability",
                        Description:     "Triggers when system shows instability",
                        MetricName:      "stability_score",
                        Operator:        "lt",
                        Threshold:       0.7,
                        Window:          15 * time.Minute,
                        ConsecutiveHits: 3,
                        Enabled:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                },
        }

        for _, condition := range defaultConditions </span><span class="cov4" title="32">{
                hc.conditions[condition.ID] = condition
        }</span>
}

// RecordError records an error for health monitoring
func (hc *HealthChecker) RecordError(appErr *AppError) <span class="cov8" title="1016">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        // Update error tracking
        hc.updateErrorTracking(appErr)

        // Update health metrics
        hc.updateHealthMetrics(appErr)

        // Check health conditions
        hc.checkHealthConditions()

        // Update overall health status
        hc.updateOverallHealth()
}</span>

// updateErrorTracking updates error tracking for health monitoring
func (hc *HealthChecker) updateErrorTracking(appErr *AppError) <span class="cov8" title="1016">{
        key := string(appErr.Type)
        hc.errorCounts[key]++

        // Update rates
        now := time.Now()
        if now.Sub(hc.lastUpdate) &gt;= time.Minute </span><span class="cov0" title="0">{
                for errorType, count := range hc.errorCounts </span><span class="cov0" title="0">{
                        rate := float64(count) / now.Sub(hc.lastUpdate).Minutes()
                        hc.errorRates[errorType] = rate

                        // Update trends
                        if trends, exists := hc.errorTrends[errorType]; exists </span><span class="cov0" title="0">{
                                trends = append(trends, rate)
                                if len(trends) &gt; 10 </span><span class="cov0" title="0">{
                                        trends = trends[1:]
                                }</span>
                                <span class="cov0" title="0">hc.errorTrends[errorType] = trends</span>
                        } else<span class="cov0" title="0"> {
                                hc.errorTrends[errorType] = []float64{rate}
                        }</span>
                }
                <span class="cov0" title="0">hc.lastUpdate = now</span>
        }
}

// updateHealthMetrics updates health metrics
func (hc *HealthChecker) updateHealthMetrics(appErr *AppError) <span class="cov8" title="1016">{
        // Update error rate metric
        totalRate := 0.0
        for _, rate := range hc.errorRates </span><span class="cov0" title="0">{
                totalRate += rate
        }</span>

        <span class="cov8" title="1016">hc.updateMetric("error_rate", totalRate, hc.degradedThreshold, "Total error rate per minute")

        // Update critical error rate
        criticalRate := 0.0
        for errorType, rate := range hc.errorRates </span><span class="cov0" title="0">{
                if errorType == string(ErrorTypeSystem) || errorType == string(ErrorTypeDatabase) </span><span class="cov0" title="0">{
                        criticalRate += rate
                }</span>
        }

        <span class="cov8" title="1016">hc.updateMetric("critical_error_rate", criticalRate, 5.0, "Critical error rate per minute")

        // Update stability score
        stabilityScore := hc.calculateStabilityScore()
        hc.updateMetric("stability_score", stabilityScore, 0.7, "System stability score (0-1)")

        // Update error trend slope
        trendSlope := hc.calculateTrendSlope()
        hc.updateMetric("error_trend_slope", trendSlope, 0.5, "Error trend slope (positive = increasing)")

        // Update service availability
        availability := hc.calculateServiceAvailability()
        hc.updateMetric("service_availability", availability, 0.95, "Service availability (0-1)")

        // Update response time impact
        responseTimeImpact := hc.calculateResponseTimeImpact()
        hc.updateMetric("response_time_impact", responseTimeImpact, 0.8, "Response time impact (0-1)")</span>
}

// updateMetric updates a specific health metric
func (hc *HealthChecker) updateMetric(name string, value, threshold float64, description string) <span class="cov10" title="6096">{
        status := HealthStatusHealthy
        if value &gt; threshold </span><span class="cov9" title="3048">{
                status = HealthStatusDegraded
                if value &gt; threshold*2 </span><span class="cov0" title="0">{
                        status = HealthStatusUnhealthy
                }</span>
        }

        <span class="cov10" title="6096">hc.metrics[name] = &amp;HealthMetric{
                Name:        name,
                Value:       value,
                Threshold:   threshold,
                Status:      status,
                LastUpdated: time.Now(),
                Description: description,
        }</span>
}

// calculateStabilityScore calculates system stability score
func (hc *HealthChecker) calculateStabilityScore() float64 <span class="cov8" title="1016">{
        if len(hc.errorRates) == 0 </span><span class="cov8" title="1016">{
                return 1.0
        }</span>

        // Calculate stability based on error rate consistency
        <span class="cov0" title="0">totalRate := 0.0
        maxRate := 0.0

        for _, rate := range hc.errorRates </span><span class="cov0" title="0">{
                totalRate += rate
                if rate &gt; maxRate </span><span class="cov0" title="0">{
                        maxRate = rate
                }</span>
        }

        <span class="cov0" title="0">if totalRate == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // Stability decreases with higher error rates and rate variance
        <span class="cov0" title="0">avgRate := totalRate / float64(len(hc.errorRates))
        variance := (maxRate - avgRate) / avgRate

        stabilityScore := 1.0 - (avgRate / 100.0) - (variance / 10.0)

        if stabilityScore &lt; 0 </span><span class="cov0" title="0">{
                stabilityScore = 0
        }</span>
        <span class="cov0" title="0">if stabilityScore &gt; 1 </span><span class="cov0" title="0">{
                stabilityScore = 1
        }</span>

        <span class="cov0" title="0">return stabilityScore</span>
}

// calculateTrendSlope calculates error trend slope
func (hc *HealthChecker) calculateTrendSlope() float64 <span class="cov8" title="1016">{
        if len(hc.errorTrends) == 0 </span><span class="cov8" title="1016">{
                return 0.0
        }</span>

        <span class="cov0" title="0">totalSlope := 0.0
        trendCount := 0

        for _, trends := range hc.errorTrends </span><span class="cov0" title="0">{
                if len(trends) &gt;= 2 </span><span class="cov0" title="0">{
                        slope := trends[len(trends)-1] - trends[0]
                        totalSlope += slope
                        trendCount++
                }</span>
        }

        <span class="cov0" title="0">if trendCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return totalSlope / float64(trendCount)</span>
}

// calculateServiceAvailability calculates service availability
func (hc *HealthChecker) calculateServiceAvailability() float64 <span class="cov8" title="1016">{
        // This is a simplified calculation
        // In practice, this would consider actual service uptime

        totalErrors := 0.0
        for _, rate := range hc.errorRates </span><span class="cov0" title="0">{
                totalErrors += rate
        }</span>

        // Assume 1000 requests per minute baseline
        <span class="cov8" title="1016">baseline := 1000.0
        availability := (baseline - totalErrors) / baseline

        if availability &lt; 0 </span><span class="cov0" title="0">{
                availability = 0
        }</span>
        <span class="cov8" title="1016">if availability &gt; 1 </span><span class="cov0" title="0">{
                availability = 1
        }</span>

        <span class="cov8" title="1016">return availability</span>
}

// calculateResponseTimeImpact calculates response time impact
func (hc *HealthChecker) calculateResponseTimeImpact() float64 <span class="cov8" title="1016">{
        // This is a simplified calculation
        // In practice, this would consider actual response time metrics

        totalErrors := 0.0
        for _, rate := range hc.errorRates </span><span class="cov0" title="0">{
                totalErrors += rate
        }</span>

        // Higher error rates typically correlate with slower response times
        <span class="cov8" title="1016">impact := 1.0 - (totalErrors / 100.0)

        if impact &lt; 0 </span><span class="cov0" title="0">{
                impact = 0
        }</span>
        <span class="cov8" title="1016">if impact &gt; 1 </span><span class="cov0" title="0">{
                impact = 1
        }</span>

        <span class="cov8" title="1016">return impact</span>
}

// checkHealthConditions checks all health conditions
func (hc *HealthChecker) checkHealthConditions() <span class="cov8" title="1016">{
        for _, condition := range hc.conditions </span><span class="cov9" title="4064">{
                if !condition.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="4064">hc.checkCondition(condition)</span>
        }
}

// checkCondition checks a specific health condition
func (hc *HealthChecker) checkCondition(condition *HealthCondition) <span class="cov9" title="4064">{
        metric, exists := hc.metrics[condition.MetricName]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="4064">triggered := false

        switch condition.Operator </span>{
        case "gt":<span class="cov9" title="3048">
                triggered = metric.Value &gt; condition.Threshold</span>
        case "lt":<span class="cov8" title="1016">
                triggered = metric.Value &lt; condition.Threshold</span>
        case "eq":<span class="cov0" title="0">
                triggered = metric.Value == condition.Threshold</span>
        case "ge":<span class="cov0" title="0">
                triggered = metric.Value &gt;= condition.Threshold</span>
        case "le":<span class="cov0" title="0">
                triggered = metric.Value &lt;= condition.Threshold</span>
        }

        <span class="cov9" title="4064">if triggered </span><span class="cov0" title="0">{
                hc.handleConditionTriggered(condition, metric)
        }</span>
}

// handleConditionTriggered handles a triggered condition
func (hc *HealthChecker) handleConditionTriggered(condition *HealthCondition, metric *HealthMetric) <span class="cov0" title="0">{
        // Create health event
        event := &amp;HealthEvent{
                ID:         fmt.Sprintf("condition_%s_%d", condition.ID, time.Now().Unix()),
                Type:       "threshold_breach",
                Status:     metric.Status,
                PrevStatus: hc.currentStatus,
                Message:    fmt.Sprintf("Condition '%s' triggered: %s = %.2f (threshold: %.2f)", condition.Name, metric.Name, metric.Value, condition.Threshold),
                Details: map[string]interface{}{
                        "condition_id": condition.ID,
                        "metric_name":  metric.Name,
                        "metric_value": metric.Value,
                        "threshold":    condition.Threshold,
                        "operator":     condition.Operator,
                },
                Timestamp:   time.Now(),
                ConditionID: condition.ID,
                Severity:    hc.getSeverityFromStatus(metric.Status),
        }

        hc.events = append(hc.events, event)

        // Update related health check
        hc.updateHealthCheck(condition, metric)

        // Log the event
        hc.logger.Warn("Health condition triggered",
                "condition_id", condition.ID,
                "condition_name", condition.Name,
                "metric_name", metric.Name,
                "metric_value", metric.Value,
                "threshold", condition.Threshold,
                "status", metric.Status,
        )
}</span>

// updateHealthCheck updates a health check based on condition
func (hc *HealthChecker) updateHealthCheck(condition *HealthCondition, metric *HealthMetric) <span class="cov0" title="0">{
        // Find related health check
        var checkID string
        switch condition.MetricName </span>{
        case "error_rate":<span class="cov0" title="0">
                checkID = "error_rate"</span>
        case "critical_error_rate":<span class="cov0" title="0">
                checkID = "critical_errors"</span>
        case "stability_score":<span class="cov0" title="0">
                checkID = "system_stability"</span>
        case "error_trend_slope":<span class="cov0" title="0">
                checkID = "error_trends"</span>
        default:<span class="cov0" title="0">
                checkID = "error_rate"</span>
        }

        <span class="cov0" title="0">if check, exists := hc.checks[checkID]; exists </span><span class="cov0" title="0">{
                check.Status = metric.Status
                check.Message = fmt.Sprintf("Condition '%s' triggered: %s = %.2f", condition.Name, metric.Name, metric.Value)
                check.Timestamp = time.Now()
                check.Details["last_condition"] = condition.ID
                check.Details["last_metric_value"] = metric.Value
                check.Details["last_threshold"] = condition.Threshold

                // Update metrics
                check.Metrics = []*HealthMetric{metric}

                if metric.Status != HealthStatusHealthy </span><span class="cov0" title="0">{
                        check.ErrorCount++
                        check.LastError = check.Message
                }</span>
        }
}

// updateOverallHealth updates overall health status
func (hc *HealthChecker) updateOverallHealth() <span class="cov8" title="1016">{
        // Determine overall status based on individual checks
        overallStatus := HealthStatusHealthy

        unhealthyCount := 0
        degradedCount := 0

        for _, check := range hc.checks </span><span class="cov9" title="4064">{
                if !check.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="4064">switch check.Status </span>{
                case HealthStatusUnhealthy:<span class="cov0" title="0">
                        unhealthyCount++</span>
                case HealthStatusDegraded:<span class="cov0" title="0">
                        degradedCount++</span>
                }
        }

        // Determine overall status
        <span class="cov8" title="1016">if unhealthyCount &gt; 0 </span><span class="cov0" title="0">{
                overallStatus = HealthStatusUnhealthy
        }</span> else<span class="cov8" title="1016"> if degradedCount &gt; 0 </span><span class="cov0" title="0">{
                overallStatus = HealthStatusDegraded
        }</span>

        // Update status if changed
        <span class="cov8" title="1016">if overallStatus != hc.currentStatus </span><span class="cov0" title="0">{
                prevStatus := hc.currentStatus
                hc.currentStatus = overallStatus
                hc.lastStatusChange = time.Now()

                // Create status change event
                event := &amp;HealthEvent{
                        ID:         fmt.Sprintf("status_change_%d", time.Now().Unix()),
                        Type:       "status_change",
                        Status:     overallStatus,
                        PrevStatus: prevStatus,
                        Message:    fmt.Sprintf("Overall health status changed from %s to %s", prevStatus, overallStatus),
                        Details: map[string]interface{}{
                                "unhealthy_checks": unhealthyCount,
                                "degraded_checks":  degradedCount,
                                "total_checks":     len(hc.checks),
                        },
                        Timestamp: time.Now(),
                        Severity:  hc.getSeverityFromStatus(overallStatus),
                }

                hc.events = append(hc.events, event)

                // Log status change
                hc.logger.Info("Health status changed",
                        "prev_status", prevStatus,
                        "new_status", overallStatus,
                        "unhealthy_checks", unhealthyCount,
                        "degraded_checks", degradedCount,
                )
        }</span>
}

// getSeverityFromStatus converts health status to severity
func (hc *HealthChecker) getSeverityFromStatus(status HealthStatus) string <span class="cov0" title="0">{
        switch status </span>{
        case HealthStatusHealthy:<span class="cov0" title="0">
                return "info"</span>
        case HealthStatusDegraded:<span class="cov0" title="0">
                return "warning"</span>
        case HealthStatusUnhealthy:<span class="cov0" title="0">
                return "error"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Public API methods

// IsHealthy returns true if the system is healthy
func (hc *HealthChecker) IsHealthy() bool <span class="cov1" title="2">{
        hc.mu.RLock()
        defer hc.mu.RUnlock()

        return hc.currentStatus == HealthStatusHealthy
}</span>

// GetHealthStatus returns current health status
func (hc *HealthChecker) GetHealthStatus() map[string]interface{} <span class="cov1" title="2">{
        hc.mu.RLock()
        defer hc.mu.RUnlock()

        return map[string]interface{}{
                "status":             hc.currentStatus,
                "last_status_change": hc.lastStatusChange,
                "checks":             hc.checks,
                "metrics":            hc.metrics,
                "conditions":         hc.conditions,
                "recent_events":      hc.getRecentEvents(10),
                "error_rates":        hc.errorRates,
                "error_trends":       hc.errorTrends,
        }
}</span>

// GetHealthChecks returns all health checks
func (hc *HealthChecker) GetHealthChecks() map[string]*HealthCheck <span class="cov0" title="0">{
        hc.mu.RLock()
        defer hc.mu.RUnlock()

        checks := make(map[string]*HealthCheck)
        for k, v := range hc.checks </span><span class="cov0" title="0">{
                checks[k] = v
        }</span>

        <span class="cov0" title="0">return checks</span>
}

// GetHealthMetrics returns all health metrics
func (hc *HealthChecker) GetHealthMetrics() map[string]*HealthMetric <span class="cov0" title="0">{
        hc.mu.RLock()
        defer hc.mu.RUnlock()

        metrics := make(map[string]*HealthMetric)
        for k, v := range hc.metrics </span><span class="cov0" title="0">{
                metrics[k] = v
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// GetHealthEvents returns recent health events
func (hc *HealthChecker) GetHealthEvents() []*HealthEvent <span class="cov0" title="0">{
        hc.mu.RLock()
        defer hc.mu.RUnlock()

        events := make([]*HealthEvent, len(hc.events))
        copy(events, hc.events)

        return events
}</span>

// getRecentEvents returns recent health events
func (hc *HealthChecker) getRecentEvents(limit int) []*HealthEvent <span class="cov1" title="2">{
        if len(hc.events) &lt;= limit </span><span class="cov1" title="2">{
                return hc.events
        }</span>

        <span class="cov0" title="0">return hc.events[len(hc.events)-limit:]</span>
}

// AddHealthCheck adds a custom health check
func (hc *HealthChecker) AddHealthCheck(check *HealthCheck) <span class="cov0" title="0">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        hc.checks[check.ID] = check
}</span>

// AddHealthCondition adds a custom health condition
func (hc *HealthChecker) AddHealthCondition(condition *HealthCondition) <span class="cov0" title="0">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        hc.conditions[condition.ID] = condition
}</span>

// RunHealthCheck runs all health checks
func (hc *HealthChecker) RunHealthCheck() <span class="cov0" title="0">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        // Update all health checks
        for _, check := range hc.checks </span><span class="cov0" title="0">{
                if !check.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">start := time.Now()

                // Run the check (this is a simplified version)
                // In practice, each check would have its own logic
                check.Timestamp = time.Now()
                check.Duration = time.Since(start)

                // Update check status based on metrics
                hc.updateCheckStatus(check)</span>
        }

        // Update overall health
        <span class="cov0" title="0">hc.updateOverallHealth()</span>
}

// updateCheckStatus updates check status based on current metrics
func (hc *HealthChecker) updateCheckStatus(check *HealthCheck) <span class="cov0" title="0">{
        // This is a simplified status update
        // In practice, each check would have specific logic

        switch check.ID </span>{
        case "error_rate":<span class="cov0" title="0">
                if metric, exists := hc.metrics["error_rate"]; exists </span><span class="cov0" title="0">{
                        check.Status = metric.Status
                        check.Message = fmt.Sprintf("Error rate: %.2f/min", metric.Value)
                        check.Metrics = []*HealthMetric{metric}
                }</span>
        case "critical_errors":<span class="cov0" title="0">
                if metric, exists := hc.metrics["critical_error_rate"]; exists </span><span class="cov0" title="0">{
                        check.Status = metric.Status
                        check.Message = fmt.Sprintf("Critical error rate: %.2f/min", metric.Value)
                        check.Metrics = []*HealthMetric{metric}
                }</span>
        case "system_stability":<span class="cov0" title="0">
                if metric, exists := hc.metrics["stability_score"]; exists </span><span class="cov0" title="0">{
                        check.Status = metric.Status
                        check.Message = fmt.Sprintf("Stability score: %.2f", metric.Value)
                        check.Metrics = []*HealthMetric{metric}
                }</span>
        case "error_trends":<span class="cov0" title="0">
                if metric, exists := hc.metrics["error_trend_slope"]; exists </span><span class="cov0" title="0">{
                        check.Status = metric.Status
                        check.Message = fmt.Sprintf("Error trend slope: %.2f", metric.Value)
                        check.Metrics = []*HealthMetric{metric}
                }</span>
        }
}

// startBackgroundProcesses starts background health monitoring processes
func (hc *HealthChecker) startBackgroundProcesses() <span class="cov3" title="8">{
        hc.wg.Add(1)
        go hc.healthMonitoringLoop()
}</span>

// healthMonitoringLoop runs health monitoring loop
func (hc *HealthChecker) healthMonitoringLoop() <span class="cov3" title="8">{
        defer hc.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov3" title="8">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        hc.RunHealthCheck()</span>
                case &lt;-hc.shutdownCh:<span class="cov3" title="8">
                        return</span>
                }
        }
}

// Close closes the health checker
func (hc *HealthChecker) Close() <span class="cov3" title="8">{
        hc.cancel()
        close(hc.shutdownCh)
        hc.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

// ErrorMetricsCollector collects and reports error metrics
type ErrorMetricsCollector struct {
        config *ErrorHandlerConfig
        logger *logger.Logger
        mu     sync.RWMutex

        // Prometheus metrics
        errorCounter        *prometheus.CounterVec
        errorDuration       *prometheus.HistogramVec
        errorSeverityGauge  *prometheus.GaugeVec
        activeErrors        *prometheus.GaugeVec
        errorRateGauge      *prometheus.GaugeVec
        errorPatternCounter *prometheus.CounterVec

        // Internal metrics
        errorCounts       map[string]int64
        errorRates        map[string]float64
        errorSeverities   map[string]map[ErrorSeverity]int64
        errorPatterns     map[string]int64
        lastMetricsUpdate time.Time

        // Background processes
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        shutdownCh chan struct{}
}

// NewErrorMetricsCollector creates a new error metrics collector
func NewErrorMetricsCollector(config *ErrorHandlerConfig, logger *logger.Logger) *ErrorMetricsCollector <span class="cov1" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        emc := &amp;ErrorMetricsCollector{
                config:            config,
                logger:            logger,
                errorCounts:       make(map[string]int64),
                errorRates:        make(map[string]float64),
                errorSeverities:   make(map[string]map[ErrorSeverity]int64),
                errorPatterns:     make(map[string]int64),
                lastMetricsUpdate: time.Now(),
                ctx:               ctx,
                cancel:            cancel,
                shutdownCh:        make(chan struct{}),
        }

        // Initialize Prometheus metrics
        emc.initializeMetrics()

        // Start background processes
        emc.startBackgroundProcesses()

        return emc
}</span>

// initializeMetrics initializes Prometheus metrics
func (emc *ErrorMetricsCollector) initializeMetrics() <span class="cov1" title="1">{
        emc.errorCounter = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "error_handler_errors_total",
                        Help: "Total number of errors handled by type and severity",
                },
                []string{"type", "severity", "category", "retryable"},
        )

        emc.errorDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "error_handler_processing_duration_seconds",
                        Help:    "Time spent processing errors",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"type", "severity"},
        )

        emc.errorSeverityGauge = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "error_handler_severity_count",
                        Help: "Current count of errors by severity level",
                },
                []string{"severity"},
        )

        emc.activeErrors = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "error_handler_active_errors",
                        Help: "Number of active errors by type",
                },
                []string{"type"},
        )

        emc.errorRateGauge = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "error_handler_error_rate",
                        Help: "Error rate by type (errors per minute)",
                },
                []string{"type"},
        )

        emc.errorPatternCounter = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "error_handler_patterns_total",
                        Help: "Total number of error patterns detected",
                },
                []string{"pattern", "type"},
        )
}</span>

// RecordError records an error occurrence
func (emc *ErrorMetricsCollector) RecordError(appErr *AppError) <span class="cov10" title="5">{
        start := time.Now()
        defer func() </span><span class="cov10" title="5">{
                duration := time.Since(start)
                emc.errorDuration.WithLabelValues(
                        string(appErr.Type),
                        string(appErr.Severity),
                ).Observe(duration.Seconds())
        }</span>()

        // Update Prometheus metrics
        <span class="cov10" title="5">emc.errorCounter.WithLabelValues(
                string(appErr.Type),
                string(appErr.Severity),
                string(appErr.Category),
                fmt.Sprintf("%t", appErr.Retryable),
        ).Inc()

        // Update internal metrics
        emc.mu.Lock()
        defer emc.mu.Unlock()

        // Update error counts
        typeKey := string(appErr.Type)
        emc.errorCounts[typeKey]++

        // Update severity counts
        if _, exists := emc.errorSeverities[typeKey]; !exists </span><span class="cov10" title="5">{
                emc.errorSeverities[typeKey] = make(map[ErrorSeverity]int64)
        }</span>
        <span class="cov10" title="5">emc.errorSeverities[typeKey][appErr.Severity]++

        // Update error patterns
        if appErr.Code != "" </span><span class="cov10" title="5">{
                patternKey := fmt.Sprintf("%s:%s", appErr.Type, appErr.Code)
                emc.errorPatterns[patternKey]++

                emc.errorPatternCounter.WithLabelValues(
                        appErr.Code,
                        string(appErr.Type),
                ).Inc()
        }</span>

        // Update active errors gauge
        <span class="cov10" title="5">emc.activeErrors.WithLabelValues(string(appErr.Type)).Inc()

        // Update severity gauge
        emc.errorSeverityGauge.WithLabelValues(string(appErr.Severity)).Inc()</span>
}

// UpdateErrorStats updates error statistics
func (emc *ErrorMetricsCollector) UpdateErrorStats(errorType, errorCode string, stats *ErrorMetrics) <span class="cov0" title="0">{
        emc.mu.Lock()
        defer emc.mu.Unlock()

        // Calculate error rate (errors per minute)
        duration := time.Since(stats.FirstSeen)
        if duration &gt; 0 </span><span class="cov0" title="0">{
                rate := float64(stats.Count) / duration.Minutes()
                emc.errorRates[errorType] = rate

                // Update Prometheus gauge
                emc.errorRateGauge.WithLabelValues(errorType).Set(rate)
        }</span>
}

// GetMetrics returns current metrics
func (emc *ErrorMetricsCollector) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        emc.mu.RLock()
        defer emc.mu.RUnlock()

        return map[string]interface{}{
                "error_counts":     emc.errorCounts,
                "error_rates":      emc.errorRates,
                "error_severities": emc.errorSeverities,
                "error_patterns":   emc.errorPatterns,
                "last_update":      emc.lastMetricsUpdate,
        }
}</span>

// GetErrorRate returns the error rate for a specific type
func (emc *ErrorMetricsCollector) GetErrorRate(errorType string) float64 <span class="cov0" title="0">{
        emc.mu.RLock()
        defer emc.mu.RUnlock()

        if rate, exists := emc.errorRates[errorType]; exists </span><span class="cov0" title="0">{
                return rate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetErrorCount returns the error count for a specific type
func (emc *ErrorMetricsCollector) GetErrorCount(errorType string) int64 <span class="cov0" title="0">{
        emc.mu.RLock()
        defer emc.mu.RUnlock()

        if count, exists := emc.errorCounts[errorType]; exists </span><span class="cov0" title="0">{
                return count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ResetMetrics resets all metrics
func (emc *ErrorMetricsCollector) ResetMetrics() <span class="cov0" title="0">{
        emc.mu.Lock()
        defer emc.mu.Unlock()

        emc.errorCounts = make(map[string]int64)
        emc.errorRates = make(map[string]float64)
        emc.errorSeverities = make(map[string]map[ErrorSeverity]int64)
        emc.errorPatterns = make(map[string]int64)
        emc.lastMetricsUpdate = time.Now()
}</span>

// startBackgroundProcesses starts background metric collection processes
func (emc *ErrorMetricsCollector) startBackgroundProcesses() <span class="cov1" title="1">{
        emc.wg.Add(1)
        go emc.metricsUpdateLoop()
}</span>

// metricsUpdateLoop runs the metrics update loop
func (emc *ErrorMetricsCollector) metricsUpdateLoop() <span class="cov1" title="1">{
        defer emc.wg.Done()

        ticker := time.NewTicker(emc.config.MetricsInterval)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        emc.updateMetrics()</span>
                case &lt;-emc.shutdownCh:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// updateMetrics updates the metrics periodically
func (emc *ErrorMetricsCollector) updateMetrics() <span class="cov0" title="0">{
        emc.mu.Lock()
        defer emc.mu.Unlock()

        emc.lastMetricsUpdate = time.Now()

        // Log metrics if enabled
        if emc.config.EnableDetailedLogging </span><span class="cov0" title="0">{
                emc.logger.Info("Error metrics update",
                        "error_counts", emc.errorCounts,
                        "error_rates", emc.errorRates,
                        "total_patterns", len(emc.errorPatterns),
                )
        }</span>
}

// Close closes the metrics collector
func (emc *ErrorMetricsCollector) Close() <span class="cov1" title="1">{
        emc.cancel()
        close(emc.shutdownCh)
        emc.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// RateLimitStrategy represents the rate limiting strategy
type RateLimitStrategy string

const (
        RateLimitStrategyFixed   RateLimitStrategy = "fixed"   // Fixed window
        RateLimitStrategySliding RateLimitStrategy = "sliding" // Sliding window
        RateLimitStrategyToken   RateLimitStrategy = "token"   // Token bucket
        RateLimitStrategyLeaky   RateLimitStrategy = "leaky"   // Leaky bucket
)

// RateLimitRule represents a rate limiting rule
type RateLimitRule struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Strategy    RateLimitStrategy `json:"strategy"`
        Limit       int               `json:"limit"`
        Window      time.Duration     `json:"window"`
        ErrorTypes  []ErrorType       `json:"error_types"`
        Severities  []ErrorSeverity   `json:"severities"`
        UserBased   bool              `json:"user_based"`
        IPBased     bool              `json:"ip_based"`
        GlobalLimit bool              `json:"global_limit"`
        Enabled     bool              `json:"enabled"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
}

// RateLimitBucket represents a rate limiting bucket
type RateLimitBucket struct {
        Key        string            `json:"key"`
        Count      int               `json:"count"`
        LastReset  time.Time         `json:"last_reset"`
        LastAccess time.Time         `json:"last_access"`
        Timestamps []time.Time       `json:"timestamps"`
        Tokens     int               `json:"tokens"`
        MaxTokens  int               `json:"max_tokens"`
        RefillRate time.Duration     `json:"refill_rate"`
        Strategy   RateLimitStrategy `json:"strategy"`
}

// RateLimitResult represents the result of rate limiting
type RateLimitResult struct {
        Allowed      bool          `json:"allowed"`
        Remaining    int           `json:"remaining"`
        ResetTime    time.Time     `json:"reset_time"`
        RetryAfter   time.Duration `json:"retry_after"`
        RuleID       string        `json:"rule_id"`
        Key          string        `json:"key"`
        ErrorMessage string        `json:"error_message,omitempty"`
}

// ErrorRateLimiter manages rate limiting for errors
type ErrorRateLimiter struct {
        config *ErrorHandlerConfig
        logger *logger.Logger
        mu     sync.RWMutex

        // Rate limiting rules
        rules   map[string]*RateLimitRule
        buckets map[string]*RateLimitBucket

        // Statistics
        stats map[string]*RateLimitStats

        // Background processes
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        shutdownCh chan struct{}
}

// RateLimitStats represents rate limiting statistics
type RateLimitStats struct {
        RuleID          string    `json:"rule_id"`
        TotalRequests   int64     `json:"total_requests"`
        AllowedRequests int64     `json:"allowed_requests"`
        BlockedRequests int64     `json:"blocked_requests"`
        LastRequest     time.Time `json:"last_request"`
        FirstRequest    time.Time `json:"first_request"`
}

// NewErrorRateLimiter creates a new error rate limiter
func NewErrorRateLimiter(config *ErrorHandlerConfig, logger *logger.Logger) *ErrorRateLimiter <span class="cov2" title="8">{
        ctx, cancel := context.WithCancel(context.Background())

        erl := &amp;ErrorRateLimiter{
                config:     config,
                logger:     logger,
                rules:      make(map[string]*RateLimitRule),
                buckets:    make(map[string]*RateLimitBucket),
                stats:      make(map[string]*RateLimitStats),
                ctx:        ctx,
                cancel:     cancel,
                shutdownCh: make(chan struct{}),
        }

        // Initialize default rules
        erl.initializeDefaultRules()

        // Start background processes
        erl.startBackgroundProcesses()

        return erl
}</span>

// initializeDefaultRules initializes default rate limiting rules
func (erl *ErrorRateLimiter) initializeDefaultRules() <span class="cov2" title="8">{
        defaultRules := []*RateLimitRule{
                {
                        ID:          "global_error_limit",
                        Name:        "Global Error Limit",
                        Strategy:    RateLimitStrategySliding,
                        Limit:       100,
                        Window:      time.Minute,
                        ErrorTypes:  []ErrorType{},
                        Severities:  []ErrorSeverity{},
                        UserBased:   false,
                        IPBased:     false,
                        GlobalLimit: true,
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "user_error_limit",
                        Name:        "Per-User Error Limit",
                        Strategy:    RateLimitStrategyFixed,
                        Limit:       50,
                        Window:      time.Minute,
                        ErrorTypes:  []ErrorType{},
                        Severities:  []ErrorSeverity{},
                        UserBased:   true,
                        IPBased:     false,
                        GlobalLimit: false,
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "critical_error_limit",
                        Name:        "Critical Error Limit",
                        Strategy:    RateLimitStrategyToken,
                        Limit:       10,
                        Window:      time.Minute,
                        ErrorTypes:  []ErrorType{},
                        Severities:  []ErrorSeverity{SeverityCritical},
                        UserBased:   false,
                        IPBased:     false,
                        GlobalLimit: true,
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        ID:          "validation_error_limit",
                        Name:        "Validation Error Limit",
                        Strategy:    RateLimitStrategyLeaky,
                        Limit:       200,
                        Window:      time.Minute,
                        ErrorTypes:  []ErrorType{ErrorTypeValidation},
                        Severities:  []ErrorSeverity{},
                        UserBased:   true,
                        IPBased:     true,
                        GlobalLimit: false,
                        Enabled:     true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }

        for _, rule := range defaultRules </span><span class="cov3" title="32">{
                erl.rules[rule.ID] = rule
        }</span>
}

// ShouldLimit checks if an error should be rate limited
func (erl *ErrorRateLimiter) ShouldLimit(ctx context.Context, err error) bool <span class="cov6" title="1015">{
        // Convert to AppError if needed
        var appErr *AppError
        if ae, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                appErr = ae
        }</span> else<span class="cov6" title="1015"> {
                // Create minimal AppError for rate limiting
                appErr = &amp;AppError{
                        Type:      ErrorTypeSystem,
                        Severity:  SeverityMedium,
                        Timestamp: time.Now(),
                        UserID:    logger.GetUserID(ctx),
                }
        }</span>

        // Check against all applicable rules
        <span class="cov6" title="1015">for _, rule := range erl.rules </span><span class="cov6" title="1627">{
                if !rule.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="1627">if erl.ruleMatches(rule, appErr) </span><span class="cov6" title="1130">{
                        result := erl.checkRateLimit(rule, appErr, ctx)
                        if !result.Allowed </span><span class="cov6" title="950">{
                                erl.logger.WarnContext(ctx, "Error rate limited",
                                        "rule_id", rule.ID,
                                        "rule_name", rule.Name,
                                        "error_type", appErr.Type,
                                        "user_id", appErr.UserID,
                                        "remaining", result.Remaining,
                                        "retry_after", result.RetryAfter,
                                )
                                return true
                        }</span>
                }
        }

        <span class="cov4" title="65">return false</span>
}

// ruleMatches checks if a rule matches the error
func (erl *ErrorRateLimiter) ruleMatches(rule *RateLimitRule, appErr *AppError) bool <span class="cov6" title="1627">{
        // Check error types
        if len(rule.ErrorTypes) &gt; 0 </span><span class="cov5" title="314">{
                match := false
                for _, errorType := range rule.ErrorTypes </span><span class="cov5" title="314">{
                        if errorType == appErr.Type </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                <span class="cov5" title="314">if !match </span><span class="cov5" title="314">{
                        return false
                }</span>
        }

        // Check severities
        <span class="cov6" title="1313">if len(rule.Severities) &gt; 0 </span><span class="cov5" title="183">{
                match := false
                for _, severity := range rule.Severities </span><span class="cov5" title="183">{
                        if severity == appErr.Severity </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                <span class="cov5" title="183">if !match </span><span class="cov5" title="183">{
                        return false
                }</span>
        }

        <span class="cov6" title="1130">return true</span>
}

// checkRateLimit checks rate limit for a rule
func (erl *ErrorRateLimiter) checkRateLimit(rule *RateLimitRule, appErr *AppError, ctx context.Context) *RateLimitResult <span class="cov6" title="1130">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        // Generate bucket key
        bucketKey := erl.generateBucketKey(rule, appErr, ctx)

        // Get or create bucket
        bucket, exists := erl.buckets[bucketKey]
        if !exists </span><span class="cov2" title="12">{
                bucket = erl.createBucket(bucketKey, rule)
                erl.buckets[bucketKey] = bucket
        }</span>

        // Update statistics
        <span class="cov6" title="1130">erl.updateStats(rule.ID, appErr)

        // Check rate limit based on strategy
        switch rule.Strategy </span>{
        case RateLimitStrategyFixed:<span class="cov5" title="218">
                return erl.checkFixedWindow(bucket, rule)</span>
        case RateLimitStrategySliding:<span class="cov6" title="912">
                return erl.checkSlidingWindow(bucket, rule)</span>
        case RateLimitStrategyToken:<span class="cov0" title="0">
                return erl.checkTokenBucket(bucket, rule)</span>
        case RateLimitStrategyLeaky:<span class="cov0" title="0">
                return erl.checkLeakyBucket(bucket, rule)</span>
        default:<span class="cov0" title="0">
                return &amp;RateLimitResult{
                        Allowed: true,
                        RuleID:  rule.ID,
                        Key:     bucketKey,
                }</span>
        }
}

// generateBucketKey generates a unique key for the rate limiting bucket
func (erl *ErrorRateLimiter) generateBucketKey(rule *RateLimitRule, appErr *AppError, ctx context.Context) string <span class="cov6" title="1130">{
        var keyParts []string

        keyParts = append(keyParts, rule.ID)

        if rule.GlobalLimit </span><span class="cov6" title="912">{
                keyParts = append(keyParts, "global")
        }</span>

        <span class="cov6" title="1130">if rule.UserBased &amp;&amp; appErr.UserID != "" </span><span class="cov0" title="0">{
                keyParts = append(keyParts, "user", appErr.UserID)
        }</span>

        <span class="cov6" title="1130">if rule.IPBased </span><span class="cov0" title="0">{
                // This would typically extract IP from context
                // For simplicity, we'll use a placeholder
                keyParts = append(keyParts, "ip", "127.0.0.1")
        }</span>

        <span class="cov6" title="1130">if len(keyParts) == 1 </span><span class="cov5" title="218">{
                keyParts = append(keyParts, "default")
        }</span>

        <span class="cov6" title="1130">return fmt.Sprintf("%s", keyParts)</span>
}

// createBucket creates a new rate limiting bucket
func (erl *ErrorRateLimiter) createBucket(key string, rule *RateLimitRule) *RateLimitBucket <span class="cov2" title="12">{
        now := time.Now()

        bucket := &amp;RateLimitBucket{
                Key:        key,
                Count:      0,
                LastReset:  now,
                LastAccess: now,
                Timestamps: []time.Time{},
                Tokens:     rule.Limit,
                MaxTokens:  rule.Limit,
                RefillRate: rule.Window / time.Duration(rule.Limit),
                Strategy:   rule.Strategy,
        }

        return bucket
}</span>

// checkFixedWindow checks fixed window rate limiting
func (erl *ErrorRateLimiter) checkFixedWindow(bucket *RateLimitBucket, rule *RateLimitRule) *RateLimitResult <span class="cov5" title="218">{
        now := time.Now()

        // Reset if window has passed
        if now.Sub(bucket.LastReset) &gt;= rule.Window </span><span class="cov0" title="0">{
                bucket.Count = 0
                bucket.LastReset = now
        }</span>

        // Check if limit exceeded
        <span class="cov5" title="218">if bucket.Count &gt;= rule.Limit </span><span class="cov4" title="153">{
                return &amp;RateLimitResult{
                        Allowed:      false,
                        Remaining:    0,
                        ResetTime:    bucket.LastReset.Add(rule.Window),
                        RetryAfter:   bucket.LastReset.Add(rule.Window).Sub(now),
                        RuleID:       rule.ID,
                        Key:          bucket.Key,
                        ErrorMessage: fmt.Sprintf("Rate limit exceeded for rule %s", rule.Name),
                }
        }</span>

        // Increment counter
        <span class="cov4" title="65">bucket.Count++
        bucket.LastAccess = now

        return &amp;RateLimitResult{
                Allowed:   true,
                Remaining: rule.Limit - bucket.Count,
                ResetTime: bucket.LastReset.Add(rule.Window),
                RuleID:    rule.ID,
                Key:       bucket.Key,
        }</span>
}

// checkSlidingWindow checks sliding window rate limiting
func (erl *ErrorRateLimiter) checkSlidingWindow(bucket *RateLimitBucket, rule *RateLimitRule) *RateLimitResult <span class="cov6" title="912">{
        now := time.Now()
        cutoff := now.Add(-rule.Window)

        // Remove old timestamps
        var validTimestamps []time.Time
        for _, ts := range bucket.Timestamps </span><span class="cov10" title="84673">{
                if ts.After(cutoff) </span><span class="cov10" title="84673">{
                        validTimestamps = append(validTimestamps, ts)
                }</span>
        }
        <span class="cov6" title="912">bucket.Timestamps = validTimestamps

        // Check if limit exceeded
        if len(bucket.Timestamps) &gt;= rule.Limit </span><span class="cov6" title="797">{
                oldestTimestamp := bucket.Timestamps[0]
                return &amp;RateLimitResult{
                        Allowed:      false,
                        Remaining:    0,
                        ResetTime:    oldestTimestamp.Add(rule.Window),
                        RetryAfter:   oldestTimestamp.Add(rule.Window).Sub(now),
                        RuleID:       rule.ID,
                        Key:          bucket.Key,
                        ErrorMessage: fmt.Sprintf("Rate limit exceeded for rule %s", rule.Name),
                }
        }</span>

        // Add current timestamp
        <span class="cov4" title="115">bucket.Timestamps = append(bucket.Timestamps, now)
        bucket.LastAccess = now

        return &amp;RateLimitResult{
                Allowed:   true,
                Remaining: rule.Limit - len(bucket.Timestamps),
                ResetTime: now.Add(rule.Window),
                RuleID:    rule.ID,
                Key:       bucket.Key,
        }</span>
}

// checkTokenBucket checks token bucket rate limiting
func (erl *ErrorRateLimiter) checkTokenBucket(bucket *RateLimitBucket, rule *RateLimitRule) *RateLimitResult <span class="cov0" title="0">{
        now := time.Now()

        // Refill tokens based on time elapsed
        elapsed := now.Sub(bucket.LastAccess)
        tokensToAdd := int(elapsed / bucket.RefillRate)

        if tokensToAdd &gt; 0 </span><span class="cov0" title="0">{
                bucket.Tokens = min(bucket.MaxTokens, bucket.Tokens+tokensToAdd)
                bucket.LastAccess = now
        }</span>

        // Check if tokens available
        <span class="cov0" title="0">if bucket.Tokens &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;RateLimitResult{
                        Allowed:      false,
                        Remaining:    0,
                        ResetTime:    now.Add(bucket.RefillRate),
                        RetryAfter:   bucket.RefillRate,
                        RuleID:       rule.ID,
                        Key:          bucket.Key,
                        ErrorMessage: fmt.Sprintf("Rate limit exceeded for rule %s", rule.Name),
                }
        }</span>

        // Consume token
        <span class="cov0" title="0">bucket.Tokens--
        bucket.LastAccess = now

        return &amp;RateLimitResult{
                Allowed:   true,
                Remaining: bucket.Tokens,
                ResetTime: now.Add(bucket.RefillRate),
                RuleID:    rule.ID,
                Key:       bucket.Key,
        }</span>
}

// checkLeakyBucket checks leaky bucket rate limiting
func (erl *ErrorRateLimiter) checkLeakyBucket(bucket *RateLimitBucket, rule *RateLimitRule) *RateLimitResult <span class="cov0" title="0">{
        now := time.Now()

        // Leak tokens based on time elapsed
        elapsed := now.Sub(bucket.LastAccess)
        tokensToLeak := int(elapsed / bucket.RefillRate)

        if tokensToLeak &gt; 0 </span><span class="cov0" title="0">{
                bucket.Count = max(0, bucket.Count-tokensToLeak)
                bucket.LastAccess = now
        }</span>

        // Check if bucket is full
        <span class="cov0" title="0">if bucket.Count &gt;= rule.Limit </span><span class="cov0" title="0">{
                return &amp;RateLimitResult{
                        Allowed:      false,
                        Remaining:    0,
                        ResetTime:    now.Add(bucket.RefillRate),
                        RetryAfter:   bucket.RefillRate,
                        RuleID:       rule.ID,
                        Key:          bucket.Key,
                        ErrorMessage: fmt.Sprintf("Rate limit exceeded for rule %s", rule.Name),
                }
        }</span>

        // Add to bucket
        <span class="cov0" title="0">bucket.Count++
        bucket.LastAccess = now

        return &amp;RateLimitResult{
                Allowed:   true,
                Remaining: rule.Limit - bucket.Count,
                ResetTime: now.Add(bucket.RefillRate),
                RuleID:    rule.ID,
                Key:       bucket.Key,
        }</span>
}

// updateStats updates rate limiting statistics
func (erl *ErrorRateLimiter) updateStats(ruleID string, appErr *AppError) <span class="cov6" title="1130">{
        stats, exists := erl.stats[ruleID]
        if !exists </span><span class="cov2" title="12">{
                stats = &amp;RateLimitStats{
                        RuleID:       ruleID,
                        FirstRequest: appErr.Timestamp,
                }
                erl.stats[ruleID] = stats
        }</span>

        <span class="cov6" title="1130">stats.TotalRequests++
        stats.LastRequest = appErr.Timestamp</span>
}

// Helper functions
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Public API methods

// AddRule adds a new rate limiting rule
func (erl *ErrorRateLimiter) AddRule(rule *RateLimitRule) <span class="cov0" title="0">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        erl.rules[rule.ID] = rule
}</span>

// RemoveRule removes a rate limiting rule
func (erl *ErrorRateLimiter) RemoveRule(ruleID string) <span class="cov0" title="0">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        delete(erl.rules, ruleID)

        // Clean up associated buckets
        for key, bucket := range erl.buckets </span><span class="cov0" title="0">{
                if bucket.Key == ruleID </span><span class="cov0" title="0">{
                        delete(erl.buckets, key)
                }</span>
        }
}

// GetRules returns all rate limiting rules
func (erl *ErrorRateLimiter) GetRules() map[string]*RateLimitRule <span class="cov0" title="0">{
        erl.mu.RLock()
        defer erl.mu.RUnlock()

        rules := make(map[string]*RateLimitRule)
        for k, v := range erl.rules </span><span class="cov0" title="0">{
                rules[k] = v
        }</span>

        <span class="cov0" title="0">return rules</span>
}

// GetBuckets returns all rate limiting buckets
func (erl *ErrorRateLimiter) GetBuckets() map[string]*RateLimitBucket <span class="cov0" title="0">{
        erl.mu.RLock()
        defer erl.mu.RUnlock()

        buckets := make(map[string]*RateLimitBucket)
        for k, v := range erl.buckets </span><span class="cov0" title="0">{
                buckets[k] = v
        }</span>

        <span class="cov0" title="0">return buckets</span>
}

// GetStats returns rate limiting statistics
func (erl *ErrorRateLimiter) GetStats() map[string]*RateLimitStats <span class="cov0" title="0">{
        erl.mu.RLock()
        defer erl.mu.RUnlock()

        stats := make(map[string]*RateLimitStats)
        for k, v := range erl.stats </span><span class="cov0" title="0">{
                stats[k] = v
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// ResetBucket resets a specific bucket
func (erl *ErrorRateLimiter) ResetBucket(bucketKey string) <span class="cov0" title="0">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        if bucket, exists := erl.buckets[bucketKey]; exists </span><span class="cov0" title="0">{
                bucket.Count = 0
                bucket.LastReset = time.Now()
                bucket.Timestamps = []time.Time{}
                bucket.Tokens = bucket.MaxTokens
        }</span>
}

// ResetAllBuckets resets all buckets
func (erl *ErrorRateLimiter) ResetAllBuckets() <span class="cov0" title="0">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        now := time.Now()
        for _, bucket := range erl.buckets </span><span class="cov0" title="0">{
                bucket.Count = 0
                bucket.LastReset = now
                bucket.Timestamps = []time.Time{}
                bucket.Tokens = bucket.MaxTokens
        }</span>
}

// GetRateLimitStatus returns current rate limit status
func (erl *ErrorRateLimiter) GetRateLimitStatus() map[string]interface{} <span class="cov0" title="0">{
        erl.mu.RLock()
        defer erl.mu.RUnlock()

        status := map[string]interface{}{
                "total_rules":    len(erl.rules),
                "active_buckets": len(erl.buckets),
                "total_stats":    len(erl.stats),
        }

        // Add rule status
        ruleStatus := make(map[string]interface{})
        for ruleID, rule := range erl.rules </span><span class="cov0" title="0">{
                ruleStatus[ruleID] = map[string]interface{}{
                        "enabled":  rule.Enabled,
                        "strategy": rule.Strategy,
                        "limit":    rule.Limit,
                        "window":   rule.Window.String(),
                }
        }</span>
        <span class="cov0" title="0">status["rules"] = ruleStatus

        // Add bucket status
        bucketStatus := make(map[string]interface{})
        for key, bucket := range erl.buckets </span><span class="cov0" title="0">{
                bucketStatus[key] = map[string]interface{}{
                        "count":       bucket.Count,
                        "tokens":      bucket.Tokens,
                        "last_access": bucket.LastAccess,
                        "strategy":    bucket.Strategy,
                }
        }</span>
        <span class="cov0" title="0">status["buckets"] = bucketStatus

        return status</span>
}

// startBackgroundProcesses starts background rate limiting processes
func (erl *ErrorRateLimiter) startBackgroundProcesses() <span class="cov2" title="8">{
        erl.wg.Add(1)
        go erl.cleanupLoop()
}</span>

// cleanupLoop runs cleanup tasks
func (erl *ErrorRateLimiter) cleanupLoop() <span class="cov2" title="8">{
        defer erl.wg.Done()

        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for </span><span class="cov2" title="8">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        erl.performCleanup()</span>
                case &lt;-erl.shutdownCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// performCleanup performs cleanup of old buckets and stats
func (erl *ErrorRateLimiter) performCleanup() <span class="cov0" title="0">{
        erl.mu.Lock()
        defer erl.mu.Unlock()

        now := time.Now()

        // Clean up old buckets
        for key, bucket := range erl.buckets </span><span class="cov0" title="0">{
                if now.Sub(bucket.LastAccess) &gt;= time.Hour </span><span class="cov0" title="0">{
                        delete(erl.buckets, key)
                }</span>
        }

        // Clean up old stats
        <span class="cov0" title="0">for ruleID, stats := range erl.stats </span><span class="cov0" title="0">{
                if now.Sub(stats.LastRequest) &gt;= 24*time.Hour </span><span class="cov0" title="0">{
                        delete(erl.stats, ruleID)
                }</span>
        }
}

// Close closes the rate limiter
func (erl *ErrorRateLimiter) Close() <span class="cov0" title="0">{
        erl.cancel()
        close(erl.shutdownCh)
        erl.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package infrastructure

import (
        "context"
        "fmt"

        "github.com/redis/go-redis/v9"
        "github.com/segmentio/kafka-go"
)

// NewRedisHealthCheck creates a health check for Redis
func NewRedisHealthCheck(client *redis.Client) func(context.Context) error <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis health check failed: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// NewKafkaHealthCheck creates a health check for Kafka
func NewKafkaHealthCheck(writer *kafka.Writer) func(context.Context) error <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                // For Kafka, we'll just check if the writer is configured
                // In production, you might want to actually try to connect to the broker
                if writer == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("kafka writer is not configured")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package infrastructure

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// JSONLinesProcessor implements the domain.JSONProcessor interface
type JSONLinesProcessor struct {
        repository domain.ReviewRepository
        logger     *logger.Logger
        batchSize  int
        workerPool int
        validator  *ReviewValidator
}

// ReviewValidator handles validation of review data
type ReviewValidator struct {
        requiredFields []string
        maxCommentLen  int
        maxTitleLen    int
}

// ProcessingStats tracks processing statistics
type ProcessingStats struct {
        TotalLines     int64
        ProcessedLines int64
        ErrorLines     int64
        SkippedLines   int64
        StartTime      time.Time
        EndTime        time.Time
}

// LineError represents an error that occurred while processing a line
type LineError struct {
        LineNumber int64
        Content    string
        Error      error
}

// BatchJob represents a batch of lines to process
type BatchJob struct {
        Lines      []string
        StartLine  int64
        ProviderID uuid.UUID
}

// ProcessingResult represents the result of processing a batch
type ProcessingResult struct {
        Reviews      []domain.Review
        Hotels       []domain.Hotel
        ReviewerInfo []domain.ReviewerInfo
        Errors       []LineError
}

// ReviewJSON represents the JSON structure for reviews
type ReviewJSON struct {
        ID           string      `json:"id"`
        HotelID      string      `json:"hotel_id"`
        HotelName    string      `json:"hotel_name"`
        Rating       interface{} `json:"rating"`
        Title        string      `json:"title"`
        Comment      string      `json:"comment"`
        ReviewDate   string      `json:"review_date"`
        StayDate     string      `json:"stay_date,omitempty"`
        TripType     string      `json:"trip_type,omitempty"`
        RoomType     string      `json:"room_type,omitempty"`
        Language     string      `json:"language,omitempty"`
        IsVerified   interface{} `json:"is_verified,omitempty"`
        HelpfulVotes interface{} `json:"helpful_votes,omitempty"`
        TotalVotes   interface{} `json:"total_votes,omitempty"`

        // Reviewer information
        ReviewerName    string `json:"reviewer_name,omitempty"`
        ReviewerEmail   string `json:"reviewer_email,omitempty"`
        ReviewerCountry string `json:"reviewer_country,omitempty"`

        // Hotel information
        HotelAddress    string      `json:"hotel_address,omitempty"`
        HotelCity       string      `json:"hotel_city,omitempty"`
        HotelCountry    string      `json:"hotel_country,omitempty"`
        HotelPostalCode string      `json:"hotel_postal_code,omitempty"`
        HotelPhone      string      `json:"hotel_phone,omitempty"`
        HotelEmail      string      `json:"hotel_email,omitempty"`
        HotelStarRating interface{} `json:"hotel_star_rating,omitempty"`
        HotelAmenities  []string    `json:"hotel_amenities,omitempty"`
        HotelLatitude   interface{} `json:"hotel_latitude,omitempty"`
        HotelLongitude  interface{} `json:"hotel_longitude,omitempty"`

        // Detailed ratings
        ServiceRating     interface{} `json:"service_rating,omitempty"`
        CleanlinessRating interface{} `json:"cleanliness_rating,omitempty"`
        LocationRating    interface{} `json:"location_rating,omitempty"`
        ValueRating       interface{} `json:"value_rating,omitempty"`
        ComfortRating     interface{} `json:"comfort_rating,omitempty"`
        FacilitiesRating  interface{} `json:"facilities_rating,omitempty"`

        // Additional metadata
        Source   string                 `json:"source,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// NewJSONLinesProcessor creates a new JSON Lines processor
func NewJSONLinesProcessor(repository domain.ReviewRepository, logger *logger.Logger) domain.JSONProcessor <span class="cov0" title="0">{
        validator := &amp;ReviewValidator{
                requiredFields: []string{"id", "hotel_id", "hotel_name", "rating", "comment", "review_date"},
                maxCommentLen:  10000,
                maxTitleLen:    500,
        }

        return &amp;JSONLinesProcessor{
                repository: repository,
                logger:     logger,
                batchSize:  1000,
                workerPool: 4,
                validator:  validator,
        }
}</span>

// ProcessFile processes a JSON Lines file
func (j *JSONLinesProcessor) ProcessFile(ctx context.Context, reader io.Reader, providerID uuid.UUID, processingID uuid.UUID) error <span class="cov0" title="0">{
        start := time.Now()
        stats := &amp;ProcessingStats{
                StartTime: start,
        }

        j.logger.InfoContext(ctx, "Starting JSON Lines file processing",
                "provider_id", providerID,
                "processing_id", processingID,
        )

        // Create buffered reader for efficient line-by-line reading
        scanner := bufio.NewScanner(reader)

        // Increase buffer size for large lines
        const maxCapacity = 1024 * 1024 // 1MB per line
        buf := make([]byte, maxCapacity)
        scanner.Buffer(buf, maxCapacity)

        // Process lines in batches using worker pool
        batchChan := make(chan BatchJob, j.workerPool)
        resultChan := make(chan ProcessingResult, j.workerPool)

        // Start worker goroutines
        var wg sync.WaitGroup
        for i := 0; i &lt; j.workerPool; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go j.worker(ctx, batchChan, resultChan, &amp;wg)
        }</span>

        // Start result collector
        <span class="cov0" title="0">go j.resultCollector(ctx, resultChan, stats, processingID)

        // Read and batch lines
        var batch []string
        var lineNumber int64
        var batchStartLine int64

        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNumber++
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        stats.SkippedLines++
                        continue</span>
                }

                // Add line to batch
                <span class="cov0" title="0">if len(batch) == 0 </span><span class="cov0" title="0">{
                        batchStartLine = lineNumber
                }</span>
                <span class="cov0" title="0">batch = append(batch, line)

                // Send batch when full
                if len(batch) &gt;= j.batchSize </span><span class="cov0" title="0">{
                        select </span>{
                        case batchChan &lt;- BatchJob{
                                Lines:      batch,
                                StartLine:  batchStartLine,
                                ProviderID: providerID,
                        }:<span class="cov0" title="0">
                                batch = make([]string, 0, j.batchSize)</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                close(batchChan)
                                return ctx.Err()</span>
                        }
                }
        }

        // Send remaining batch
        <span class="cov0" title="0">if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case batchChan &lt;- BatchJob{
                        Lines:      batch,
                        StartLine:  batchStartLine,
                        ProviderID: providerID,
                }:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(batchChan)
                        return ctx.Err()</span>
                }
        }

        // Check for scanner errors
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                close(batchChan)
                return fmt.Errorf("error reading file: %w", err)
        }</span>

        <span class="cov0" title="0">stats.TotalLines = lineNumber

        // Close batch channel and wait for workers
        close(batchChan)
        wg.Wait()
        close(resultChan)

        // Wait for result collector to finish
        time.Sleep(100 * time.Millisecond)

        stats.EndTime = time.Now()
        duration := stats.EndTime.Sub(stats.StartTime)

        j.logger.InfoContext(ctx, "JSON Lines file processing completed",
                "provider_id", providerID,
                "processing_id", processingID,
                "total_lines", stats.TotalLines,
                "processed_lines", stats.ProcessedLines,
                "error_lines", stats.ErrorLines,
                "skipped_lines", stats.SkippedLines,
                "duration_ms", duration.Milliseconds(),
                "lines_per_second", float64(stats.TotalLines)/duration.Seconds(),
        )

        return nil</span>
}

// worker processes batches of lines
func (j *JSONLinesProcessor) worker(ctx context.Context, batchChan &lt;-chan BatchJob, resultChan chan&lt;- ProcessingResult, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for batch := range batchChan </span><span class="cov0" title="0">{
                result := j.processBatch(ctx, batch)

                select </span>{
                case resultChan &lt;- result:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// processBatch processes a batch of lines
func (j *JSONLinesProcessor) processBatch(ctx context.Context, batch BatchJob) ProcessingResult <span class="cov0" title="0">{
        result := ProcessingResult{
                Reviews:      make([]domain.Review, 0, len(batch.Lines)),
                Hotels:       make([]domain.Hotel, 0),
                ReviewerInfo: make([]domain.ReviewerInfo, 0),
                Errors:       make([]LineError, 0),
        }

        hotelMap := make(map[string]*domain.Hotel)
        reviewerMap := make(map[string]*domain.ReviewerInfo)

        for i, line := range batch.Lines </span><span class="cov0" title="0">{
                lineNumber := batch.StartLine + int64(i)

                review, hotel, reviewer, err := j.parseLine(ctx, line, batch.ProviderID)
                if err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, LineError{
                                LineNumber: lineNumber,
                                Content:    line,
                                Error:      err,
                        })
                        continue</span>
                }

                <span class="cov0" title="0">result.Reviews = append(result.Reviews, *review)

                // Collect unique hotels
                if hotel != nil </span><span class="cov0" title="0">{
                        if _, exists := hotelMap[hotel.Name]; !exists </span><span class="cov0" title="0">{
                                hotelMap[hotel.Name] = hotel
                        }</span>
                }

                // Collect unique reviewers
                <span class="cov0" title="0">if reviewer != nil &amp;&amp; reviewer.Email != "" </span><span class="cov0" title="0">{
                        if _, exists := reviewerMap[reviewer.Email]; !exists </span><span class="cov0" title="0">{
                                reviewerMap[reviewer.Email] = reviewer
                        }</span>
                }
        }

        // Convert maps to slices
        <span class="cov0" title="0">for _, hotel := range hotelMap </span><span class="cov0" title="0">{
                result.Hotels = append(result.Hotels, *hotel)
        }</span>
        <span class="cov0" title="0">for _, reviewer := range reviewerMap </span><span class="cov0" title="0">{
                result.ReviewerInfo = append(result.ReviewerInfo, *reviewer)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// resultCollector collects processing results and saves to database
func (j *JSONLinesProcessor) resultCollector(ctx context.Context, resultChan &lt;-chan ProcessingResult, stats *ProcessingStats, processingID uuid.UUID) <span class="cov0" title="0">{
        for result := range resultChan </span><span class="cov0" title="0">{
                // Save hotels first (upsert to handle duplicates)
                if len(result.Hotels) &gt; 0 </span><span class="cov0" title="0">{
                        for _, hotel := range result.Hotels </span><span class="cov0" title="0">{
                                if err := j.repository.CreateHotel(ctx, &amp;hotel); err != nil </span><span class="cov0" title="0">{
                                        j.logger.WarnContext(ctx, "Failed to upsert hotel",
                                                "hotel_name", hotel.Name,
                                                "error", err,
                                        )
                                }</span>
                        }
                }

                // Save reviewer info (upsert to handle duplicates)
                <span class="cov0" title="0">if len(result.ReviewerInfo) &gt; 0 </span><span class="cov0" title="0">{
                        for _, reviewer := range result.ReviewerInfo </span><span class="cov0" title="0">{
                                if err := j.repository.CreateReviewerInfo(ctx, &amp;reviewer); err != nil </span><span class="cov0" title="0">{
                                        j.logger.WarnContext(ctx, "Failed to upsert reviewer info",
                                                "reviewer_email", reviewer.Email,
                                                "error", err,
                                        )
                                }</span>
                        }
                }

                // Save reviews in batch
                <span class="cov0" title="0">if len(result.Reviews) &gt; 0 </span><span class="cov0" title="0">{
                        if err := j.repository.CreateBatch(ctx, result.Reviews); err != nil </span><span class="cov0" title="0">{
                                j.logger.ErrorContext(ctx, "Failed to save review batch",
                                        "batch_size", len(result.Reviews),
                                        "error", err,
                                )
                                stats.ErrorLines += int64(len(result.Reviews))
                        }</span> else<span class="cov0" title="0"> {
                                stats.ProcessedLines += int64(len(result.Reviews))
                        }</span>
                }

                // Log errors
                <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, lineError := range result.Errors </span><span class="cov0" title="0">{
                                j.logger.WarnContext(ctx, "Line processing error",
                                        "line_number", lineError.LineNumber,
                                        "error", lineError.Error,
                                )
                        }</span>
                        <span class="cov0" title="0">stats.ErrorLines += int64(len(result.Errors))</span>
                }

                // Update processing status periodically
                <span class="cov0" title="0">if err := j.repository.UpdateProcessingStatus(ctx, processingID, "processing", int(stats.ProcessedLines), ""); err != nil </span><span class="cov0" title="0">{
                        j.logger.WarnContext(ctx, "Failed to update processing status", "error", err)
                }</span>
        }
}

// parseLine parses a single JSON line
func (j *JSONLinesProcessor) parseLine(ctx context.Context, line string, providerID uuid.UUID) (*domain.Review, *domain.Hotel, *domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal([]byte(line), &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Parse review
        <span class="cov0" title="0">review, err := j.parseReview(ctx, &amp;reviewJSON, providerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to parse review: %w", err)
        }</span>

        // Parse hotel
        <span class="cov0" title="0">hotel, err := j.parseHotel(ctx, &amp;reviewJSON)
        if err != nil </span><span class="cov0" title="0">{
                j.logger.WarnContext(ctx, "Failed to parse hotel", "error", err)
                hotel = nil
        }</span>

        // Parse reviewer info
        <span class="cov0" title="0">reviewer, err := j.parseReviewerInfo(ctx, &amp;reviewJSON)
        if err != nil </span><span class="cov0" title="0">{
                j.logger.WarnContext(ctx, "Failed to parse reviewer info", "error", err)
                reviewer = nil
        }</span>

        <span class="cov0" title="0">return review, hotel, reviewer, nil</span>
}

// parseReview parses a review from JSON
func (j *JSONLinesProcessor) parseReview(ctx context.Context, reviewJSON *ReviewJSON, providerID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        // Parse rating
        rating, err := j.parseFloat(reviewJSON.Rating)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid rating: %w", err)
        }</span>

        // Parse review date
        <span class="cov0" title="0">reviewDate, err := j.parseDate(reviewJSON.ReviewDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid review date: %w", err)
        }</span>

        // Parse hotel ID
        <span class="cov0" title="0">hotelID, err := uuid.Parse(reviewJSON.HotelID)
        if err != nil </span><span class="cov0" title="0">{
                // Generate UUID from hotel name if not provided
                hotelID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.HotelName))
        }</span>

        // Parse reviewer ID (generate from email if available)
        <span class="cov0" title="0">reviewerID := uuid.New()
        if reviewJSON.ReviewerEmail != "" </span><span class="cov0" title="0">{
                reviewerID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.ReviewerEmail))
        }</span>

        <span class="cov0" title="0">review := &amp;domain.Review{
                ID:             uuid.New(),
                ProviderID:     providerID,
                HotelID:        hotelID,
                ReviewerInfoID: &amp;reviewerID,
                ExternalID:     reviewJSON.ID,
                Rating:         rating,
                Title:          reviewJSON.Title,
                Comment:        reviewJSON.Comment,
                ReviewDate:     reviewDate,
                Language:       j.getStringOrDefault(reviewJSON.Language, "en"),
                Source:         reviewJSON.Source,
                Metadata:       reviewJSON.Metadata,
        }

        // Parse optional fields
        if reviewJSON.StayDate != "" </span><span class="cov0" title="0">{
                if stayDate, err := j.parseDate(reviewJSON.StayDate); err == nil </span><span class="cov0" title="0">{
                        review.StayDate = &amp;stayDate
                }</span>
        }

        <span class="cov0" title="0">if reviewJSON.TripType != "" </span><span class="cov0" title="0">{
                review.TripType = reviewJSON.TripType
        }</span>

        <span class="cov0" title="0">if reviewJSON.RoomType != "" </span><span class="cov0" title="0">{
                review.RoomType = reviewJSON.RoomType
        }</span>

        <span class="cov0" title="0">if isVerified, err := j.parseBool(reviewJSON.IsVerified); err == nil </span><span class="cov0" title="0">{
                review.IsVerified = isVerified
        }</span>

        <span class="cov0" title="0">if helpfulVotes, err := j.parseInt(reviewJSON.HelpfulVotes); err == nil </span><span class="cov0" title="0">{
                review.HelpfulVotes = helpfulVotes
        }</span>

        <span class="cov0" title="0">if totalVotes, err := j.parseInt(reviewJSON.TotalVotes); err == nil </span><span class="cov0" title="0">{
                review.TotalVotes = totalVotes
        }</span>

        // Parse detailed ratings
        <span class="cov0" title="0">if serviceRating, err := j.parseFloat(reviewJSON.ServiceRating); err == nil </span><span class="cov0" title="0">{
                review.ServiceRating = &amp;serviceRating
        }</span>

        <span class="cov0" title="0">if cleanlinessRating, err := j.parseFloat(reviewJSON.CleanlinessRating); err == nil </span><span class="cov0" title="0">{
                review.CleanlinessRating = &amp;cleanlinessRating
        }</span>

        <span class="cov0" title="0">if locationRating, err := j.parseFloat(reviewJSON.LocationRating); err == nil </span><span class="cov0" title="0">{
                review.LocationRating = &amp;locationRating
        }</span>

        <span class="cov0" title="0">if valueRating, err := j.parseFloat(reviewJSON.ValueRating); err == nil </span><span class="cov0" title="0">{
                review.ValueRating = &amp;valueRating
        }</span>

        <span class="cov0" title="0">if comfortRating, err := j.parseFloat(reviewJSON.ComfortRating); err == nil </span><span class="cov0" title="0">{
                review.ComfortRating = &amp;comfortRating
        }</span>

        <span class="cov0" title="0">if facilitiesRating, err := j.parseFloat(reviewJSON.FacilitiesRating); err == nil </span><span class="cov0" title="0">{
                review.FacilitiesRating = &amp;facilitiesRating
        }</span>

        <span class="cov0" title="0">return review, nil</span>
}

// parseHotel parses hotel information from JSON
func (j *JSONLinesProcessor) parseHotel(ctx context.Context, reviewJSON *ReviewJSON) (*domain.Hotel, error) <span class="cov1" title="1">{
        hotelID, err := uuid.Parse(reviewJSON.HotelID)
        if err != nil </span><span class="cov1" title="1">{
                hotelID = uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.HotelName))
        }</span>

        <span class="cov1" title="1">hotel := &amp;domain.Hotel{
                ID:         hotelID,
                Name:       reviewJSON.HotelName,
                Address:    reviewJSON.HotelAddress,
                City:       reviewJSON.HotelCity,
                Country:    reviewJSON.HotelCountry,
                PostalCode: reviewJSON.HotelPostalCode,
                Phone:      reviewJSON.HotelPhone,
                Email:      reviewJSON.HotelEmail,
                Amenities:  reviewJSON.HotelAmenities,
        }

        // Parse optional fields
        if starRating, err := j.parseInt(reviewJSON.HotelStarRating); err == nil </span><span class="cov1" title="1">{
                hotel.StarRating = starRating
        }</span>

        <span class="cov1" title="1">if latitude, err := j.parseFloat(reviewJSON.HotelLatitude); err == nil </span><span class="cov0" title="0">{
                hotel.Latitude = latitude
        }</span>

        <span class="cov1" title="1">if longitude, err := j.parseFloat(reviewJSON.HotelLongitude); err == nil </span><span class="cov0" title="0">{
                hotel.Longitude = longitude
        }</span>

        <span class="cov1" title="1">return hotel, nil</span>
}

// parseReviewerInfo parses reviewer information from JSON
func (j *JSONLinesProcessor) parseReviewerInfo(ctx context.Context, reviewJSON *ReviewJSON) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        if reviewJSON.ReviewerEmail == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reviewer email is required")
        }</span>

        <span class="cov0" title="0">reviewerID := uuid.NewSHA1(uuid.NameSpaceURL, []byte(reviewJSON.ReviewerEmail))

        reviewer := &amp;domain.ReviewerInfo{
                ID:       reviewerID,
                Name:     reviewJSON.ReviewerName,
                Email:    reviewJSON.ReviewerEmail,
                Location: reviewJSON.ReviewerCountry,
        }

        return reviewer, nil</span>
}

// ValidateFile validates the file format and structure
func (j *JSONLinesProcessor) ValidateFile(ctx context.Context, reader io.Reader) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        lineNumber := 0

        // Check first few lines for format validation
        for scanner.Scan() &amp;&amp; lineNumber &lt; 10 </span><span class="cov0" title="0">{
                lineNumber++
                line := strings.TrimSpace(scanner.Text())

                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var reviewJSON ReviewJSON
                if err := json.Unmarshal([]byte(line), &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid JSON format at line %d: %w", lineNumber, err)
                }</span>

                <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed at line %d: %w", lineNumber, err)
                }</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}

// CountRecords counts the number of records in the file
func (j *JSONLinesProcessor) CountRecords(ctx context.Context, reader io.Reader) (int, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        count := 0

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line != "" </span><span class="cov0" title="0">{
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count, scanner.Err()</span>
}

// ParseReview parses a single review from JSON line
func (j *JSONLinesProcessor) ParseReview(ctx context.Context, jsonLine []byte, providerID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if err := j.validator.validateReviewJSON(&amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">review, _, _, err := j.parseLine(ctx, string(jsonLine), providerID)
        return review, err</span>
}

// ParseHotel parses hotel information from JSON line
func (j *JSONLinesProcessor) ParseHotel(ctx context.Context, jsonLine []byte) (*domain.Hotel, error) <span class="cov1" title="1">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov1" title="1">return j.parseHotel(ctx, &amp;reviewJSON)</span>
}

// ParseReviewerInfo parses reviewer information from JSON line
func (j *JSONLinesProcessor) ParseReviewerInfo(ctx context.Context, jsonLine []byte) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewJSON ReviewJSON
        if err := json.Unmarshal(jsonLine, &amp;reviewJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return j.parseReviewerInfo(ctx, &amp;reviewJSON)</span>
}

// ValidateReview validates a review
func (j *JSONLinesProcessor) ValidateReview(ctx context.Context, review *domain.Review) error <span class="cov0" title="0">{
        if review.Rating &lt; 1.0 || review.Rating &gt; 5.0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rating must be between 1.0 and 5.0")
        }</span>

        <span class="cov0" title="0">if review.Comment == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("comment cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(review.Comment) &gt; j.validator.maxCommentLen </span><span class="cov0" title="0">{
                return fmt.Errorf("comment exceeds maximum length of %d characters", j.validator.maxCommentLen)
        }</span>

        <span class="cov0" title="0">if review.Title != "" &amp;&amp; len(review.Title) &gt; j.validator.maxTitleLen </span><span class="cov0" title="0">{
                return fmt.Errorf("title exceeds maximum length of %d characters", j.validator.maxTitleLen)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateHotel validates a hotel
func (j *JSONLinesProcessor) ValidateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        if hotel.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("hotel name cannot be empty")
        }</span>

        <span class="cov0" title="0">if hotel.StarRating &lt; 1 || hotel.StarRating &gt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("star rating must be between 1 and 5")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateReviewerInfo validates reviewer information
func (j *JSONLinesProcessor) ValidateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        if reviewerInfo.Email == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("reviewer email cannot be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessBatch processes a batch of reviews
func (j *JSONLinesProcessor) ProcessBatch(ctx context.Context, reviews []domain.Review) error <span class="cov0" title="0">{
        return j.repository.CreateBatch(ctx, reviews)
}</span>

// GetBatchSize returns the current batch size
func (j *JSONLinesProcessor) GetBatchSize() int <span class="cov1" title="1">{
        return j.batchSize
}</span>

// SetBatchSize sets the batch size
func (j *JSONLinesProcessor) SetBatchSize(size int) <span class="cov1" title="1">{
        j.batchSize = size
}</span>

// Validation methods for ReviewValidator
func (v *ReviewValidator) validateReviewJSON(reviewJSON *ReviewJSON) error <span class="cov0" title="0">{
        for _, field := range v.requiredFields </span><span class="cov0" title="0">{
                if err := v.checkRequiredField(reviewJSON, field); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (v *ReviewValidator) checkRequiredField(reviewJSON *ReviewJSON, field string) error <span class="cov0" title="0">{
        switch field </span>{
        case "id":<span class="cov0" title="0">
                if reviewJSON.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "hotel_id":<span class="cov0" title="0">
                if reviewJSON.HotelID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "hotel_name":<span class="cov0" title="0">
                if reviewJSON.HotelName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "rating":<span class="cov0" title="0">
                if reviewJSON.Rating == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "comment":<span class="cov0" title="0">
                if reviewJSON.Comment == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        case "review_date":<span class="cov0" title="0">
                if reviewJSON.ReviewDate == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper parsing methods
func (j *JSONLinesProcessor) parseFloat(value interface{}) (float64, error) <span class="cov7" title="10">{
        if value == nil </span><span class="cov4" title="3">{
                return 0, fmt.Errorf("value is nil")
        }</span>

        <span class="cov6" title="7">switch v := value.(type) </span>{
        case float64:<span class="cov1" title="1">
                return v, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int:<span class="cov1" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case string:<span class="cov2" title="2">
                return strconv.ParseFloat(v, 64)</span>
        case json.Number:<span class="cov2" title="2">
                return v.Float64()</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("cannot convert %T to float64", v)</span>
        }
}

func (j *JSONLinesProcessor) parseInt(value interface{}) (int, error) <span class="cov7" title="9">{
        if value == nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("value is nil")
        }</span>

        <span class="cov6" title="8">switch v := value.(type) </span>{
        case int:<span class="cov1" title="1">
                return v, nil</span>
        case int64:<span class="cov0" title="0">
                return int(v), nil</span>
        case float64:<span class="cov2" title="2">
                return int(v), nil</span>
        case float32:<span class="cov0" title="0">
                return int(v), nil</span>
        case string:<span class="cov4" title="3">
                return strconv.Atoi(v)</span>
        case json.Number:<span class="cov2" title="2">
                return strconv.Atoi(string(v))</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to int", v)</span>
        }
}

func (j *JSONLinesProcessor) parseBool(value interface{}) (bool, error) <span class="cov8" title="13">{
        if value == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("value is nil")
        }</span>

        <span class="cov7" title="12">switch v := value.(type) </span>{
        case bool:<span class="cov1" title="1">
                return v, nil</span>
        case string:<span class="cov7" title="9">
                // Handle common boolean string representations
                switch strings.ToLower(v) </span>{
                case "yes", "y", "on", "1":<span class="cov4" title="3">
                        return true, nil</span>
                case "no", "n", "off", "0":<span class="cov4" title="3">
                        return false, nil</span>
                default:<span class="cov4" title="3">
                        return strconv.ParseBool(v)</span>
                }
        case int:<span class="cov2" title="2">
                return v != 0, nil</span>
        case float64:<span class="cov0" title="0">
                return v != 0, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("cannot convert %T to bool", v)</span>
        }
}

func (j *JSONLinesProcessor) parseDate(dateStr string) (time.Time, error) <span class="cov6" title="8">{
        if dateStr == "" </span><span class="cov1" title="1">{
                return time.Time{}, fmt.Errorf("date string is empty")
        }</span>

        // Try Unix timestamp first
        <span class="cov6" title="7">if timestamp, err := strconv.ParseInt(dateStr, 10, 64); err == nil </span><span class="cov1" title="1">{
                return time.Unix(timestamp, 0), nil
        }</span>

        // Try different date formats
        <span class="cov5" title="6">formats := []string{
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05.000Z",
                "2006-01-02T15:04:05-07:00",
                "2006-01-02 15:04:05",
                "2006-01-02",
                "01/02/2006",
                "02/01/2006",
        }

        for _, format := range formats </span><span class="cov10" title="27">{
                if t, err := time.Parse(format, dateStr); err == nil </span><span class="cov4" title="4">{
                        return t, nil
                }</span>
        }

        <span class="cov2" title="2">return time.Time{}, fmt.Errorf("cannot parse date: %s", dateStr)</span>
}

func (j *JSONLinesProcessor) getStringOrDefault(value, defaultValue string) string <span class="cov5" title="6">{
        if value == "" </span><span class="cov2" title="2">{
                return defaultValue
        }</span>
        <span class="cov4" title="4">return value</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/segmentio/kafka-go"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// KafkaConfig holds Kafka configuration
type KafkaConfig struct {
        Brokers              []string      `mapstructure:"brokers" json:"brokers"`
        ReviewTopic          string        `mapstructure:"review_topic" json:"review_topic"`
        ProcessingTopic      string        `mapstructure:"processing_topic" json:"processing_topic"`
        DeadLetterTopic      string        `mapstructure:"dead_letter_topic" json:"dead_letter_topic"`
        ConsumerGroup        string        `mapstructure:"consumer_group" json:"consumer_group"`
        BatchSize            int           `mapstructure:"batch_size" json:"batch_size"`
        BatchTimeout         time.Duration `mapstructure:"batch_timeout" json:"batch_timeout"`
        MaxRetries           int           `mapstructure:"max_retries" json:"max_retries"`
        RetryDelay           time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        EnableSASL           bool          `mapstructure:"enable_sasl" json:"enable_sasl"`
        SASLUsername         string        `mapstructure:"sasl_username" json:"sasl_username"`
        SASLPassword         string        `mapstructure:"sasl_password" json:"sasl_password"`
        EnableTLS            bool          `mapstructure:"enable_tls" json:"enable_tls"`
        MaxMessageSize       int           `mapstructure:"max_message_size" json:"max_message_size"`
        CompressionType      string        `mapstructure:"compression_type" json:"compression_type"`
        ProducerFlushTimeout time.Duration `mapstructure:"producer_flush_timeout" json:"producer_flush_timeout"`
        ConsumerTimeout      time.Duration `mapstructure:"consumer_timeout" json:"consumer_timeout"`
        EnableIdempotence    bool          `mapstructure:"enable_idempotence" json:"enable_idempotence"`
        Partitions           int           `mapstructure:"partitions" json:"partitions"`
        ReplicationFactor    int           `mapstructure:"replication_factor" json:"replication_factor"`
}

// EventType represents different types of events
type EventType string

const (
        // Processing Events
        ProcessingStartedEvent   EventType = "processing.started"
        ProcessingProgressEvent  EventType = "processing.progress"
        ProcessingCompletedEvent EventType = "processing.completed"
        ProcessingFailedEvent    EventType = "processing.failed"
        ProcessingRetryEvent     EventType = "processing.retry"
        ProcessingCancelledEvent EventType = "processing.cancelled"

        // Review Events
        ReviewCreatedEvent   EventType = "review.created"
        ReviewUpdatedEvent   EventType = "review.updated"
        ReviewDeletedEvent   EventType = "review.deleted"
        ReviewValidatedEvent EventType = "review.validated"
        ReviewEnrichedEvent  EventType = "review.enriched"
        ReviewBatchCreated   EventType = "review.batch.created"
        ReviewBatchFailed    EventType = "review.batch.failed"

        // Hotel Events
        HotelCreatedEvent     EventType = "hotel.created"
        HotelUpdatedEvent     EventType = "hotel.updated"
        HotelSummaryUpdated   EventType = "hotel.summary.updated"
        HotelAnalyticsUpdated EventType = "hotel.analytics.updated"

        // Provider Events
        ProviderConnectedEvent    EventType = "provider.connected"
        ProviderDisconnectedEvent EventType = "provider.disconnected"
        ProviderErrorEvent        EventType = "provider.error"

        // System Events
        SystemHealthCheckEvent EventType = "system.health.check"
        SystemErrorEvent       EventType = "system.error"
        SystemMetricsEvent     EventType = "system.metrics"
)

// BaseEvent represents the base structure for all events
type BaseEvent struct {
        ID            string                 `json:"id"`
        Type          EventType              `json:"type"`
        Source        string                 `json:"source"`
        Timestamp     time.Time              `json:"timestamp"`
        Version       string                 `json:"version"`
        CorrelationID string                 `json:"correlation_id,omitempty"`
        UserID        string                 `json:"user_id,omitempty"`
        SessionID     string                 `json:"session_id,omitempty"`
        TraceID       string                 `json:"trace_id,omitempty"`
        SpanID        string                 `json:"span_id,omitempty"`
        Data          map[string]interface{} `json:"data"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// ProcessingEvent represents file processing events
type ProcessingEvent struct {
        BaseEvent
        JobID            uuid.UUID `json:"job_id"`
        ProviderID       uuid.UUID `json:"provider_id"`
        FileURL          string    `json:"file_url"`
        Status           string    `json:"status"`
        RecordsTotal     int64     `json:"records_total"`
        RecordsProcessed int64     `json:"records_processed"`
        ErrorCount       int64     `json:"error_count"`
        ErrorMessage     string    `json:"error_message,omitempty"`
        ProcessingTime   int64     `json:"processing_time_ms"`
        RetryCount       int       `json:"retry_count"`
}

// ReviewEvent represents review-related events
type ReviewEvent struct {
        BaseEvent
        ReviewID   uuid.UUID `json:"review_id"`
        HotelID    uuid.UUID `json:"hotel_id"`
        ProviderID uuid.UUID `json:"provider_id"`
        Rating     float64   `json:"rating"`
        Sentiment  string    `json:"sentiment,omitempty"`
        Language   string    `json:"language,omitempty"`
        BatchID    string    `json:"batch_id,omitempty"`
        BatchSize  int       `json:"batch_size,omitempty"`
}

// HotelEvent represents hotel-related events
type HotelEvent struct {
        BaseEvent
        HotelID        uuid.UUID `json:"hotel_id"`
        HotelName      string    `json:"hotel_name"`
        City           string    `json:"city,omitempty"`
        Country        string    `json:"country,omitempty"`
        TotalReviews   int       `json:"total_reviews,omitempty"`
        AverageRating  float64   `json:"average_rating,omitempty"`
        PreviousRating float64   `json:"previous_rating,omitempty"`
        RatingChange   float64   `json:"rating_change,omitempty"`
}

// ProviderEvent represents provider-related events
type ProviderEvent struct {
        BaseEvent
        ProviderID   uuid.UUID `json:"provider_id"`
        ProviderName string    `json:"provider_name"`
        Status       string    `json:"status"`
        ErrorMessage string    `json:"error_message,omitempty"`
        LastSync     time.Time `json:"last_sync,omitempty"`
}

// SystemEvent represents system-level events
type SystemEvent struct {
        BaseEvent
        Component    string                 `json:"component"`
        Status       string                 `json:"status"`
        Message      string                 `json:"message,omitempty"`
        Metrics      map[string]interface{} `json:"metrics,omitempty"`
        ErrorDetails map[string]interface{} `json:"error_details,omitempty"`
}

// KafkaProducer handles publishing events to Kafka
type KafkaProducer struct {
        writer *kafka.Writer
        config *KafkaConfig
        logger *logger.Logger
        mu     sync.RWMutex
}

// NewKafkaProducer creates a new Kafka producer
func NewKafkaProducer(config *KafkaConfig, logger *logger.Logger) (*KafkaProducer, error) <span class="cov10" title="9">{
        if len(config.Brokers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("at least one broker is required")
        }</span>

        // Note: Compression handling simplified for compatibility

        // Create Kafka writer
        <span class="cov9" title="8">writer := &amp;kafka.Writer{
                Addr:         kafka.TCP(config.Brokers...),
                BatchSize:    config.BatchSize,
                BatchTimeout: config.BatchTimeout,
                RequiredAcks: kafka.RequireAll,
                Async:        false,
                WriteTimeout: config.ProducerFlushTimeout,
                ReadTimeout:  config.ConsumerTimeout,
                ErrorLogger: kafka.LoggerFunc(func(msg string, args ...interface{}) </span><span class="cov0" title="0">{
                        logger.Error("Kafka producer error", "message", fmt.Sprintf(msg, args...))
                }</span>),
        }

        // Configure TLS if enabled
        <span class="cov9" title="8">if config.EnableTLS </span><span class="cov1" title="1">{
                writer.Transport = &amp;kafka.Transport{
                        // TLS: &amp;tls.Config{}, // Configure as needed
                }
        }</span>

        // Configure SASL if enabled
        <span class="cov9" title="8">if config.EnableSASL </span><span class="cov1" title="1">{
                // Note: SASL configuration simplified for compatibility
                writer.Transport = &amp;kafka.Transport{
                        // SASL: mechanism.Plain{
                        //     Username: config.SASLUsername,
                        //     Password: config.SASLPassword,
                        // },
                }
        }</span>

        <span class="cov9" title="8">producer := &amp;KafkaProducer{
                writer: writer,
                config: config,
                logger: logger,
        }

        return producer, nil</span>
}

// PublishEvent publishes an event to the appropriate topic
func (p *KafkaProducer) PublishEvent(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        // Serialize event
        eventBytes, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // Determine topic based on event type
        <span class="cov0" title="0">topic := p.getTopicForEvent(event)
        if topic == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown event type: %T", event)
        }</span>

        // Create message
        <span class="cov0" title="0">message := kafka.Message{
                Topic: topic,
                Value: eventBytes,
                Time:  time.Now(),
                Headers: []kafka.Header{
                        {Key: "event-type", Value: []byte(p.getEventType(event))},
                        {Key: "source", Value: []byte("hotel-reviews-microservice")},
                        {Key: "version", Value: []byte("1.0")},
                },
        }

        // Add partition key if available
        if partitionKey := p.getPartitionKey(event); partitionKey != "" </span><span class="cov0" title="0">{
                message.Key = []byte(partitionKey)
        }</span>

        // Add correlation ID if available
        <span class="cov0" title="0">if correlationID := p.getCorrelationID(event); correlationID != "" </span><span class="cov0" title="0">{
                message.Headers = append(message.Headers, kafka.Header{
                        Key:   "correlation-id",
                        Value: []byte(correlationID),
                })
        }</span>

        // Publish message
        <span class="cov0" title="0">err = p.writer.WriteMessages(ctx, message)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.ErrorContext(ctx, "Failed to publish event",
                        "error", err,
                        "topic", topic,
                        "event_type", p.getEventType(event),
                )
                return fmt.Errorf("failed to publish event: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.InfoContext(ctx, "Event published successfully",
                "topic", topic,
                "event_type", p.getEventType(event),
                "message_size", len(eventBytes),
        )

        return nil</span>
}

// PublishProcessingEvent publishes a processing event
func (p *KafkaProducer) PublishProcessingEvent(ctx context.Context, event *ProcessingEvent) error <span class="cov0" title="0">{
        return p.PublishEvent(ctx, event)
}</span>

// PublishReviewEvent publishes a review event
func (p *KafkaProducer) PublishReviewEvent(ctx context.Context, event *ReviewEvent) error <span class="cov0" title="0">{
        return p.PublishEvent(ctx, event)
}</span>

// PublishHotelEvent publishes a hotel event
func (p *KafkaProducer) PublishHotelEvent(ctx context.Context, event *HotelEvent) error <span class="cov0" title="0">{
        return p.PublishEvent(ctx, event)
}</span>

// PublishProviderEvent publishes a provider event
func (p *KafkaProducer) PublishProviderEvent(ctx context.Context, event *ProviderEvent) error <span class="cov0" title="0">{
        return p.PublishEvent(ctx, event)
}</span>

// PublishSystemEvent publishes a system event
func (p *KafkaProducer) PublishSystemEvent(ctx context.Context, event *SystemEvent) error <span class="cov0" title="0">{
        return p.PublishEvent(ctx, event)
}</span>

// Close closes the producer
func (p *KafkaProducer) Close() error <span class="cov1" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.writer != nil </span><span class="cov1" title="1">{
                err := p.writer.Close()
                p.writer = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getTopicForEvent determines the appropriate topic for an event
func (p *KafkaProducer) getTopicForEvent(event interface{}) string <span class="cov7" title="5">{
        switch event.(type) </span>{
        case *ProcessingEvent:<span class="cov1" title="1">
                return p.config.ProcessingTopic</span>
        case *ReviewEvent:<span class="cov1" title="1">
                return p.config.ReviewTopic</span>
        case *HotelEvent:<span class="cov1" title="1">
                return p.config.ReviewTopic</span>
        case *ProviderEvent:<span class="cov0" title="0">
                return p.config.ProcessingTopic</span>
        case *SystemEvent:<span class="cov1" title="1">
                return p.config.ProcessingTopic</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// getEventType extracts the event type from an event
func (p *KafkaProducer) getEventType(event interface{}) string <span class="cov6" title="4">{
        switch e := event.(type) </span>{
        case *ProcessingEvent:<span class="cov1" title="1">
                return string(e.Type)</span>
        case *ReviewEvent:<span class="cov1" title="1">
                return string(e.Type)</span>
        case *HotelEvent:<span class="cov0" title="0">
                return string(e.Type)</span>
        case *ProviderEvent:<span class="cov0" title="0">
                return string(e.Type)</span>
        case *SystemEvent:<span class="cov1" title="1">
                return string(e.Type)</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// getPartitionKey extracts the partition key from an event
func (p *KafkaProducer) getPartitionKey(event interface{}) string <span class="cov6" title="4">{
        switch e := event.(type) </span>{
        case *ProcessingEvent:<span class="cov1" title="1">
                return e.ProviderID.String()</span>
        case *ReviewEvent:<span class="cov1" title="1">
                return e.HotelID.String()</span>
        case *HotelEvent:<span class="cov1" title="1">
                return e.HotelID.String()</span>
        case *ProviderEvent:<span class="cov0" title="0">
                return e.ProviderID.String()</span>
        case *SystemEvent:<span class="cov0" title="0">
                return e.Component</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// getCorrelationID extracts the correlation ID from an event
func (p *KafkaProducer) getCorrelationID(event interface{}) string <span class="cov6" title="4">{
        switch e := event.(type) </span>{
        case *ProcessingEvent:<span class="cov1" title="1">
                return e.CorrelationID</span>
        case *ReviewEvent:<span class="cov0" title="0">
                return e.CorrelationID</span>
        case *HotelEvent:<span class="cov0" title="0">
                return e.CorrelationID</span>
        case *ProviderEvent:<span class="cov0" title="0">
                return e.CorrelationID</span>
        case *SystemEvent:<span class="cov3" title="2">
                return e.CorrelationID</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// EventHandler defines the interface for handling events
type EventHandler interface {
        Handle(ctx context.Context, event interface{}) error
        CanHandle(eventType EventType) bool
}

// KafkaConsumer handles consuming events from Kafka
type KafkaConsumer struct {
        reader   *kafka.Reader
        config   *KafkaConfig
        logger   *logger.Logger
        handlers map[EventType][]EventHandler
        mu       sync.RWMutex
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
}

// NewKafkaConsumer creates a new Kafka consumer
func NewKafkaConsumer(config *KafkaConfig, logger *logger.Logger) (*KafkaConsumer, error) <span class="cov5" title="3">{
        if len(config.Brokers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("at least one broker is required")
        }</span>

        <span class="cov3" title="2">if config.ConsumerGroup == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("consumer group is required")
        }</span>

        <span class="cov1" title="1">ctx, cancel := context.WithCancel(context.Background())

        // Create Kafka reader
        reader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:        config.Brokers,
                GroupID:        config.ConsumerGroup,
                Topic:          config.ReviewTopic,
                MaxBytes:       config.MaxMessageSize,
                CommitInterval: 1 * time.Second,
                StartOffset:    kafka.LastOffset,
                ErrorLogger: kafka.LoggerFunc(func(msg string, args ...interface{}) </span><span class="cov8" title="6">{
                        logger.Error("Kafka consumer error", "message", fmt.Sprintf(msg, args...))
                }</span>),
        })

        <span class="cov1" title="1">consumer := &amp;KafkaConsumer{
                reader:   reader,
                config:   config,
                logger:   logger,
                handlers: make(map[EventType][]EventHandler),
                ctx:      ctx,
                cancel:   cancel,
        }

        return consumer, nil</span>
}

// RegisterHandler registers an event handler
func (c *KafkaConsumer) RegisterHandler(eventType EventType, handler EventHandler) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.handlers[eventType] == nil </span><span class="cov0" title="0">{
                c.handlers[eventType] = make([]EventHandler, 0)
        }</span>
        <span class="cov0" title="0">c.handlers[eventType] = append(c.handlers[eventType], handler)

        c.logger.Info("Event handler registered",
                "event_type", eventType,
                "handler_count", len(c.handlers[eventType]),
        )</span>
}

// Start starts the consumer
func (c *KafkaConsumer) Start() error <span class="cov0" title="0">{
        c.logger.Info("Starting Kafka consumer",
                "consumer_group", c.config.ConsumerGroup,
                "brokers", c.config.Brokers,
        )

        c.wg.Add(1)
        go c.consumeLoop()

        return nil
}</span>

// Stop stops the consumer
func (c *KafkaConsumer) Stop() error <span class="cov0" title="0">{
        c.logger.Info("Stopping Kafka consumer...")

        c.cancel()
        c.wg.Wait()

        if c.reader != nil </span><span class="cov0" title="0">{
                err := c.reader.Close()
                c.reader = nil
                return err
        }</span>

        <span class="cov0" title="0">c.logger.Info("Kafka consumer stopped")
        return nil</span>
}

// consumeLoop is the main consumption loop
func (c *KafkaConsumer) consumeLoop() <span class="cov0" title="0">{
        defer c.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        message, err := c.reader.ReadMessage(c.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == context.Canceled </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">c.logger.Error("Failed to read message", "error", err)
                                continue</span>
                        }

                        // Process message
                        <span class="cov0" title="0">if err := c.processMessage(c.ctx, message); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Failed to process message",
                                        "error", err,
                                        "topic", message.Topic,
                                        "partition", message.Partition,
                                        "offset", message.Offset,
                                )

                                // Send to dead letter queue if processing fails
                                if err := c.sendToDeadLetterQueue(c.ctx, message, err); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("Failed to send message to dead letter queue",
                                                "error", err,
                                                "original_error", err,
                                        )
                                }</span>
                        }
                }
        }
}

// processMessage processes a single message
func (c *KafkaConsumer) processMessage(ctx context.Context, message kafka.Message) error <span class="cov0" title="0">{
        // Extract event type from headers
        eventType := c.getEventTypeFromHeaders(message.Headers)
        if eventType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing event type in message headers")
        }</span>

        // Deserialize event
        <span class="cov0" title="0">event, err := c.deserializeEvent(message.Value, EventType(eventType))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deserialize event: %w", err)
        }</span>

        // Get handlers for this event type
        <span class="cov0" title="0">c.mu.RLock()
        handlers, exists := c.handlers[EventType(eventType)]
        c.mu.RUnlock()

        if !exists || len(handlers) == 0 </span><span class="cov0" title="0">{
                c.logger.Warn("No handlers registered for event type",
                        "event_type", eventType,
                        "topic", message.Topic,
                )
                return nil
        }</span>

        // Process event with all registered handlers
        <span class="cov0" title="0">for _, handler := range handlers </span><span class="cov0" title="0">{
                if handler.CanHandle(EventType(eventType)) </span><span class="cov0" title="0">{
                        if err := handler.Handle(ctx, event); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Handler failed to process event",
                                        "error", err,
                                        "event_type", eventType,
                                        "handler", fmt.Sprintf("%T", handler),
                                )
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">c.logger.Debug("Message processed successfully",
                "event_type", eventType,
                "topic", message.Topic,
                "partition", message.Partition,
                "offset", message.Offset,
                "handlers_count", len(handlers),
        )

        return nil</span>
}

// deserializeEvent deserializes an event based on its type
func (c *KafkaConsumer) deserializeEvent(data []byte, eventType EventType) (interface{}, error) <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(string(eventType), "processing."):<span class="cov0" title="0">
                var event ProcessingEvent
                if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;event, nil</span>
        case strings.HasPrefix(string(eventType), "review."):<span class="cov0" title="0">
                var event ReviewEvent
                if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;event, nil</span>
        case strings.HasPrefix(string(eventType), "hotel."):<span class="cov0" title="0">
                var event HotelEvent
                if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;event, nil</span>
        case strings.HasPrefix(string(eventType), "provider."):<span class="cov0" title="0">
                var event ProviderEvent
                if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;event, nil</span>
        case strings.HasPrefix(string(eventType), "system."):<span class="cov0" title="0">
                var event SystemEvent
                if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;event, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown event type: %s", eventType)</span>
        }
}

// getEventTypeFromHeaders extracts the event type from message headers
func (c *KafkaConsumer) getEventTypeFromHeaders(headers []kafka.Header) string <span class="cov0" title="0">{
        for _, header := range headers </span><span class="cov0" title="0">{
                if header.Key == "event-type" </span><span class="cov0" title="0">{
                        return string(header.Value)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// sendToDeadLetterQueue sends a failed message to the dead letter queue
func (c *KafkaConsumer) sendToDeadLetterQueue(ctx context.Context, message kafka.Message, processingError error) error <span class="cov0" title="0">{
        if c.config.DeadLetterTopic == "" </span><span class="cov0" title="0">{
                return nil // No dead letter queue configured
        }</span>

        // Create dead letter message
        <span class="cov0" title="0">deadLetterMessage := kafka.Message{
                Topic: c.config.DeadLetterTopic,
                Key:   message.Key,
                Value: message.Value,
                Time:  time.Now(),
                Headers: append(message.Headers, kafka.Header{
                        Key:   "processing-error",
                        Value: []byte(processingError.Error()),
                }, kafka.Header{
                        Key:   "original-topic",
                        Value: []byte(message.Topic),
                }, kafka.Header{
                        Key:   "original-partition",
                        Value: []byte(fmt.Sprintf("%d", message.Partition)),
                }, kafka.Header{
                        Key:   "original-offset",
                        Value: []byte(fmt.Sprintf("%d", message.Offset)),
                }),
        }

        // Create a temporary writer for dead letter queue
        writer := &amp;kafka.Writer{
                Addr:         kafka.TCP(c.config.Brokers...),
                Topic:        c.config.DeadLetterTopic,
                BatchSize:    1,
                BatchTimeout: 100 * time.Millisecond,
                RequiredAcks: kafka.RequireOne,
                Async:        false,
        }
        defer writer.Close()

        return writer.WriteMessages(ctx, deadLetterMessage)</span>
}

// EventBuilders provide convenient ways to create events

// NewProcessingEvent creates a new processing event
func NewProcessingEvent(eventType EventType, jobID, providerID uuid.UUID, fileURL string) *ProcessingEvent <span class="cov0" title="0">{
        return &amp;ProcessingEvent{
                BaseEvent: BaseEvent{
                        ID:        uuid.New().String(),
                        Type:      eventType,
                        Source:    "hotel-reviews-processing",
                        Timestamp: time.Now(),
                        Version:   "1.0",
                        Data:      make(map[string]interface{}),
                },
                JobID:      jobID,
                ProviderID: providerID,
                FileURL:    fileURL,
        }
}</span>

// NewReviewEvent creates a new review event
func NewReviewEvent(eventType EventType, reviewID, hotelID, providerID uuid.UUID) *ReviewEvent <span class="cov0" title="0">{
        return &amp;ReviewEvent{
                BaseEvent: BaseEvent{
                        ID:        uuid.New().String(),
                        Type:      eventType,
                        Source:    "hotel-reviews-service",
                        Timestamp: time.Now(),
                        Version:   "1.0",
                        Data:      make(map[string]interface{}),
                },
                ReviewID:   reviewID,
                HotelID:    hotelID,
                ProviderID: providerID,
        }
}</span>

// NewHotelEvent creates a new hotel event
func NewHotelEvent(eventType EventType, hotelID uuid.UUID, hotelName string) *HotelEvent <span class="cov0" title="0">{
        return &amp;HotelEvent{
                BaseEvent: BaseEvent{
                        ID:        uuid.New().String(),
                        Type:      eventType,
                        Source:    "hotel-reviews-service",
                        Timestamp: time.Now(),
                        Version:   "1.0",
                        Data:      make(map[string]interface{}),
                },
                HotelID:   hotelID,
                HotelName: hotelName,
        }
}</span>

// NewProviderEvent creates a new provider event
func NewProviderEvent(eventType EventType, providerID uuid.UUID, providerName string) *ProviderEvent <span class="cov0" title="0">{
        return &amp;ProviderEvent{
                BaseEvent: BaseEvent{
                        ID:        uuid.New().String(),
                        Type:      eventType,
                        Source:    "hotel-reviews-service",
                        Timestamp: time.Now(),
                        Version:   "1.0",
                        Data:      make(map[string]interface{}),
                },
                ProviderID:   providerID,
                ProviderName: providerName,
        }
}</span>

// NewSystemEvent creates a new system event
func NewSystemEvent(eventType EventType, component string) *SystemEvent <span class="cov0" title="0">{
        return &amp;SystemEvent{
                BaseEvent: BaseEvent{
                        ID:        uuid.New().String(),
                        Type:      eventType,
                        Source:    "hotel-reviews-system",
                        Timestamp: time.Now(),
                        Version:   "1.0",
                        Data:      make(map[string]interface{}),
                },
                Component: component,
        }
}</span>

// KafkaEventPublisher implements the domain event publisher interface
type KafkaEventPublisher struct {
        producer *KafkaProducer
        logger   *logger.Logger
}

// NewKafkaEventPublisher creates a new Kafka event publisher
func NewKafkaEventPublisher(producer *KafkaProducer, logger *logger.Logger) *KafkaEventPublisher <span class="cov0" title="0">{
        return &amp;KafkaEventPublisher{
                producer: producer,
                logger:   logger,
        }
}</span>

// PublishDomainEvent publishes a domain event
func (p *KafkaEventPublisher) PublishDomainEvent(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        return p.producer.PublishEvent(ctx, event)
}</span>

// ProcessingEventHandler handles processing events
type ProcessingEventHandler struct {
        reviewService domain.ReviewService
        logger        *logger.Logger
}

// NewProcessingEventHandler creates a new processing event handler
func NewProcessingEventHandler(reviewService domain.ReviewService, logger *logger.Logger) *ProcessingEventHandler <span class="cov0" title="0">{
        return &amp;ProcessingEventHandler{
                reviewService: reviewService,
                logger:        logger,
        }
}</span>

// Handle handles a processing event
func (h *ProcessingEventHandler) Handle(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        processingEvent, ok := event.(*ProcessingEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ProcessingEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">h.logger.InfoContext(ctx, "Processing event received",
                "event_type", processingEvent.Type,
                "job_id", processingEvent.JobID,
                "provider_id", processingEvent.ProviderID,
                "status", processingEvent.Status,
        )

        // Update processing status in database
        switch processingEvent.Type </span>{
        case ProcessingStartedEvent:<span class="cov0" title="0">
                return h.handleProcessingStarted(ctx, processingEvent)</span>
        case ProcessingProgressEvent:<span class="cov0" title="0">
                return h.handleProcessingProgress(ctx, processingEvent)</span>
        case ProcessingCompletedEvent:<span class="cov0" title="0">
                return h.handleProcessingCompleted(ctx, processingEvent)</span>
        case ProcessingFailedEvent:<span class="cov0" title="0">
                return h.handleProcessingFailed(ctx, processingEvent)</span>
        default:<span class="cov0" title="0">
                h.logger.WarnContext(ctx, "Unknown processing event type",
                        "event_type", processingEvent.Type,
                )
                return nil</span>
        }
}

// CanHandle checks if this handler can handle the given event type
func (h *ProcessingEventHandler) CanHandle(eventType EventType) bool <span class="cov0" title="0">{
        return strings.HasPrefix(string(eventType), "processing.")
}</span>

// handleProcessingStarted handles processing started events
func (h *ProcessingEventHandler) handleProcessingStarted(ctx context.Context, event *ProcessingEvent) error <span class="cov0" title="0">{
        // Update processing status to started
        // This would typically involve updating the database
        h.logger.InfoContext(ctx, "Processing started",
                "job_id", event.JobID,
                "provider_id", event.ProviderID,
                "file_url", event.FileURL,
        )
        return nil
}</span>

// handleProcessingProgress handles processing progress events
func (h *ProcessingEventHandler) handleProcessingProgress(ctx context.Context, event *ProcessingEvent) error <span class="cov0" title="0">{
        // Update processing progress
        h.logger.InfoContext(ctx, "Processing progress",
                "job_id", event.JobID,
                "records_processed", event.RecordsProcessed,
                "records_total", event.RecordsTotal,
                "progress", fmt.Sprintf("%.2f%%", float64(event.RecordsProcessed)/float64(event.RecordsTotal)*100),
        )
        return nil
}</span>

// handleProcessingCompleted handles processing completed events
func (h *ProcessingEventHandler) handleProcessingCompleted(ctx context.Context, event *ProcessingEvent) error <span class="cov0" title="0">{
        // Update processing status to completed
        h.logger.InfoContext(ctx, "Processing completed",
                "job_id", event.JobID,
                "provider_id", event.ProviderID,
                "records_processed", event.RecordsProcessed,
                "processing_time", time.Duration(event.ProcessingTime)*time.Millisecond,
        )
        return nil
}</span>

// handleProcessingFailed handles processing failed events
func (h *ProcessingEventHandler) handleProcessingFailed(ctx context.Context, event *ProcessingEvent) error <span class="cov0" title="0">{
        // Update processing status to failed
        h.logger.ErrorContext(ctx, "Processing failed",
                "job_id", event.JobID,
                "provider_id", event.ProviderID,
                "error_message", event.ErrorMessage,
                "retry_count", event.RetryCount,
        )
        return nil
}</span>

// ReviewEventHandler handles review events
type ReviewEventHandler struct {
        reviewService domain.ReviewService
        logger        *logger.Logger
}

// NewReviewEventHandler creates a new review event handler
func NewReviewEventHandler(reviewService domain.ReviewService, logger *logger.Logger) *ReviewEventHandler <span class="cov0" title="0">{
        return &amp;ReviewEventHandler{
                reviewService: reviewService,
                logger:        logger,
        }
}</span>

// Handle handles a review event
func (h *ReviewEventHandler) Handle(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        reviewEvent, ok := event.(*ReviewEvent)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ReviewEvent, got %T", event)
        }</span>

        <span class="cov0" title="0">h.logger.InfoContext(ctx, "Review event received",
                "event_type", reviewEvent.Type,
                "review_id", reviewEvent.ReviewID,
                "hotel_id", reviewEvent.HotelID,
                "provider_id", reviewEvent.ProviderID,
        )

        // Handle different review events
        switch reviewEvent.Type </span>{
        case ReviewCreatedEvent:<span class="cov0" title="0">
                return h.handleReviewCreated(ctx, reviewEvent)</span>
        case ReviewBatchCreated:<span class="cov0" title="0">
                return h.handleReviewBatchCreated(ctx, reviewEvent)</span>
        case ReviewUpdatedEvent:<span class="cov0" title="0">
                return h.handleReviewUpdated(ctx, reviewEvent)</span>
        case ReviewDeletedEvent:<span class="cov0" title="0">
                return h.handleReviewDeleted(ctx, reviewEvent)</span>
        default:<span class="cov0" title="0">
                h.logger.WarnContext(ctx, "Unknown review event type",
                        "event_type", reviewEvent.Type,
                )
                return nil</span>
        }
}

// CanHandle checks if this handler can handle the given event type
func (h *ReviewEventHandler) CanHandle(eventType EventType) bool <span class="cov0" title="0">{
        return strings.HasPrefix(string(eventType), "review.")
}</span>

// handleReviewCreated handles review created events
func (h *ReviewEventHandler) handleReviewCreated(ctx context.Context, event *ReviewEvent) error <span class="cov0" title="0">{
        // Trigger analytics update, cache invalidation, etc.
        h.logger.InfoContext(ctx, "Review created",
                "review_id", event.ReviewID,
                "hotel_id", event.HotelID,
                "rating", event.Rating,
                "sentiment", event.Sentiment,
        )
        return nil
}</span>

// handleReviewBatchCreated handles review batch created events
func (h *ReviewEventHandler) handleReviewBatchCreated(ctx context.Context, event *ReviewEvent) error <span class="cov0" title="0">{
        // Handle batch processing completion
        h.logger.InfoContext(ctx, "Review batch created",
                "batch_id", event.BatchID,
                "batch_size", event.BatchSize,
                "hotel_id", event.HotelID,
                "provider_id", event.ProviderID,
        )
        return nil
}</span>

// handleReviewUpdated handles review updated events
func (h *ReviewEventHandler) handleReviewUpdated(ctx context.Context, event *ReviewEvent) error <span class="cov0" title="0">{
        // Handle review updates
        h.logger.InfoContext(ctx, "Review updated",
                "review_id", event.ReviewID,
                "hotel_id", event.HotelID,
        )
        return nil
}</span>

// handleReviewDeleted handles review deleted events
func (h *ReviewEventHandler) handleReviewDeleted(ctx context.Context, event *ReviewEvent) error <span class="cov0" title="0">{
        // Handle review deletion
        h.logger.InfoContext(ctx, "Review deleted",
                "review_id", event.ReviewID,
                "hotel_id", event.HotelID,
        )
        return nil
}</span>

// RetryableEventHandler wraps an event handler with retry logic
type RetryableEventHandler struct {
        handler    EventHandler
        maxRetries int
        retryDelay time.Duration
        logger     *logger.Logger
}

// NewRetryableEventHandler creates a new retryable event handler
func NewRetryableEventHandler(handler EventHandler, maxRetries int, retryDelay time.Duration, logger *logger.Logger) *RetryableEventHandler <span class="cov0" title="0">{
        return &amp;RetryableEventHandler{
                handler:    handler,
                maxRetries: maxRetries,
                retryDelay: retryDelay,
                logger:     logger,
        }
}</span>

// Handle handles an event with retry logic
func (h *RetryableEventHandler) Handle(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= h.maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        h.logger.InfoContext(ctx, "Retrying event handling",
                                "attempt", attempt,
                                "max_retries", h.maxRetries,
                                "event_type", fmt.Sprintf("%T", event),
                        )
                        time.Sleep(h.retryDelay)
                }</span>

                <span class="cov0" title="0">if err := h.handler.Handle(ctx, event); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        h.logger.WarnContext(ctx, "Event handling failed",
                                "error", err,
                                "attempt", attempt,
                                "max_retries", h.maxRetries,
                        )
                        continue</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("event handling failed after %d attempts: %w", h.maxRetries, lastErr)</span>
}

// CanHandle checks if this handler can handle the given event type
func (h *RetryableEventHandler) CanHandle(eventType EventType) bool <span class="cov0" title="0">{
        return h.handler.CanHandle(eventType)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package middleware

import (
        "context"
        "encoding/json"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
)

// AuthMiddleware handles authentication for HTTP requests
type AuthMiddleware struct {
        authService *infrastructure.AuthenticationService
        logger      *slog.Logger
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(authService *infrastructure.AuthenticationService, logger *slog.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
                logger:      logger,
        }
}</span>

// JWTAuthMiddleware validates JWT tokens for protected routes
func (m *AuthMiddleware) JWTAuthMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Extract token from Authorization header
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        m.writeErrorResponse(w, http.StatusUnauthorized, "authorization header required")
                        return
                }</span>

                // Check if it's a Bearer token
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                        m.writeErrorResponse(w, http.StatusUnauthorized, "invalid authorization header format")
                        return
                }</span>

                <span class="cov0" title="0">token := parts[1]
                if token == "" </span><span class="cov0" title="0">{
                        m.writeErrorResponse(w, http.StatusUnauthorized, "token is required")
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">user, err := m.authService.ValidateToken(r.Context(), token)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Warn("token validation failed", "error", err, "ip", m.getClientIP(r))
                        m.writeErrorResponse(w, http.StatusUnauthorized, "invalid or expired token")
                        return
                }</span>

                // Add user to context
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "user", user)
                ctx = context.WithValue(ctx, "user_id", user.ID)
                ctx = context.WithValue(ctx, "user_email", user.Email)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// APIKeyAuthMiddleware validates API keys for service-to-service calls
func (m *AuthMiddleware) APIKeyAuthMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Extract API key from X-API-Key header
                apiKey := r.Header.Get("X-API-Key")
                if apiKey == "" </span><span class="cov0" title="0">{
                        m.writeErrorResponse(w, http.StatusUnauthorized, "API key required")
                        return
                }</span>

                // Validate API key
                <span class="cov0" title="0">apiKeyData, err := m.authService.ValidateApiKey(r.Context(), apiKey)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Warn("API key validation failed", "error", err, "ip", m.getClientIP(r))
                        m.writeErrorResponse(w, http.StatusUnauthorized, "invalid API key")
                        return
                }</span>

                // Add API key data to context
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "api_key", apiKeyData)
                ctx = context.WithValue(ctx, "user_id", apiKeyData.UserID)
                ctx = context.WithValue(ctx, "scopes", apiKeyData.Scopes)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// RequirePermission creates middleware that requires specific permissions
func (m *AuthMiddleware) RequirePermission(resource, action string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get user from context (set by JWTAuthMiddleware)
                        user, ok := r.Context().Value("user").(*domain.User)
                        if !ok </span><span class="cov0" title="0">{
                                m.writeErrorResponse(w, http.StatusUnauthorized, "authentication required")
                                return
                        }</span>

                        // Check permission
                        <span class="cov0" title="0">hasPermission, err := m.authService.CheckPermission(r.Context(), user.ID, resource, action)
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Error("permission check failed", "error", err, "user_id", user.ID, "resource", resource, "action", action)
                                m.writeErrorResponse(w, http.StatusInternalServerError, "permission check failed")
                                return
                        }</span>

                        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                                m.logger.Warn("permission denied", "user_id", user.ID, "resource", resource, "action", action, "ip", m.getClientIP(r))
                                m.writeErrorResponse(w, http.StatusForbidden, "insufficient permissions")
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireRole creates middleware that requires specific roles
func (m *AuthMiddleware) RequireRole(requiredRoles ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get user from context (set by JWTAuthMiddleware)
                        user, ok := r.Context().Value("user").(*domain.User)
                        if !ok </span><span class="cov0" title="0">{
                                m.writeErrorResponse(w, http.StatusUnauthorized, "authentication required")
                                return
                        }</span>

                        // Check if user has any of the required roles
                        <span class="cov0" title="0">hasRole := false
                        userRoles := make(map[string]bool)
                        for _, role := range user.Roles </span><span class="cov0" title="0">{
                                userRoles[role.Name] = true
                        }</span>

                        <span class="cov0" title="0">for _, requiredRole := range requiredRoles </span><span class="cov0" title="0">{
                                if userRoles[requiredRole] </span><span class="cov0" title="0">{
                                        hasRole = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                                m.logger.Warn("role check failed", "user_id", user.ID, "required_roles", requiredRoles, "user_roles", userRoles, "ip", m.getClientIP(r))
                                m.writeErrorResponse(w, http.StatusForbidden, "insufficient role permissions")
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireAPIKeyScopes creates middleware that requires specific API key scopes
func (m *AuthMiddleware) RequireAPIKeyScopes(requiredScopes ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get API key scopes from context (set by APIKeyAuthMiddleware)
                        scopes, ok := r.Context().Value("scopes").([]string)
                        if !ok </span><span class="cov0" title="0">{
                                m.writeErrorResponse(w, http.StatusUnauthorized, "API key authentication required")
                                return
                        }</span>

                        // Check if API key has required scopes
                        <span class="cov0" title="0">apiKeyScopes := make(map[string]bool)
                        for _, scope := range scopes </span><span class="cov0" title="0">{
                                apiKeyScopes[scope] = true
                        }</span>

                        <span class="cov0" title="0">for _, requiredScope := range requiredScopes </span><span class="cov0" title="0">{
                                if !apiKeyScopes[requiredScope] </span><span class="cov0" title="0">{
                                        m.logger.Warn("API key scope check failed", "required_scopes", requiredScopes, "api_key_scopes", scopes, "ip", m.getClientIP(r))
                                        m.writeErrorResponse(w, http.StatusForbidden, "insufficient API key permissions")
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RateLimitMiddleware implements rate limiting for authentication endpoints
func (m *AuthMiddleware) RateLimitMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Only apply rate limiting to authentication endpoints
                if !m.isAuthEndpoint(r.URL.Path) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Extract email from request body for login attempts
                <span class="cov0" title="0">email := m.extractEmailFromRequest(r)
                if email == "" </span><span class="cov0" title="0">{
                        // If we can't extract email, skip rate limiting
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">ipAddress := m.getClientIP(r)

                // Check if rate limited
                isRateLimited, err := m.authService.IsRateLimited(r.Context(), email, ipAddress)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Error("rate limit check failed", "error", err, "email", email, "ip", ipAddress)
                        // Continue on error to avoid blocking legitimate requests
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">if isRateLimited </span><span class="cov0" title="0">{
                        m.logger.Warn("rate limit exceeded", "email", email, "ip", ipAddress)
                        m.writeErrorResponse(w, http.StatusTooManyRequests, "too many login attempts, please try again later")
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// AuditMiddleware logs authentication-related actions
func (m *AuthMiddleware) AuditMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a response writer that captures the status code
                wrappedWriter := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                // Process request
                next.ServeHTTP(wrappedWriter, r)

                // Log audit information
                go func() </span><span class="cov0" title="0">{
                        ctx := context.Background()

                        var userID *uuid.UUID
                        if user, ok := r.Context().Value("user").(*domain.User); ok </span><span class="cov0" title="0">{
                                userID = &amp;user.ID
                        }</span>

                        // Extract resource and action from URL path
                        <span class="cov0" title="0">resource, action := m.extractResourceAndAction(r.URL.Path, r.Method)

                        // Skip audit for health checks and metrics
                        if resource == "health" || resource == "metrics" </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">err := m.authService.AuditAction(
                                ctx,
                                userID,
                                action,
                                resource,
                                nil, // resourceID - could be extracted from URL params
                                nil, // oldValues
                                nil, // newValues
                                m.getClientIP(r),
                                r.Header.Get("User-Agent"),
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Error("audit logging failed", "error", err)
                        }</span>
                }()

                // Log request details
                <span class="cov0" title="0">m.logger.Info("request processed",
                        "method", r.Method,
                        "path", r.URL.Path,
                        "status", wrappedWriter.statusCode,
                        "duration", time.Since(start),
                        "ip", m.getClientIP(r),
                )</span>
        })
}

// OptionalAuthMiddleware provides optional authentication (doesn't fail if no auth)
func (m *AuthMiddleware) OptionalAuthMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Try JWT authentication first
                authHeader := r.Header.Get("Authorization")
                if authHeader != "" </span><span class="cov0" title="0">{
                        parts := strings.Split(authHeader, " ")
                        if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "bearer" </span><span class="cov0" title="0">{
                                token := parts[1]
                                if token != "" </span><span class="cov0" title="0">{
                                        user, err := m.authService.ValidateToken(r.Context(), token)
                                        if err == nil </span><span class="cov0" title="0">{
                                                ctx := context.WithValue(r.Context(), "user", user)
                                                ctx = context.WithValue(ctx, "user_id", user.ID)
                                                ctx = context.WithValue(ctx, "user_email", user.Email)
                                                r = r.WithContext(ctx)
                                        }</span>
                                }
                        }
                }

                // Try API key authentication
                <span class="cov0" title="0">apiKey := r.Header.Get("X-API-Key")
                if apiKey != "" </span><span class="cov0" title="0">{
                        apiKeyData, err := m.authService.ValidateApiKey(r.Context(), apiKey)
                        if err == nil </span><span class="cov0" title="0">{
                                ctx := context.WithValue(r.Context(), "api_key", apiKeyData)
                                ctx = context.WithValue(ctx, "user_id", apiKeyData.UserID)
                                ctx = context.WithValue(ctx, "scopes", apiKeyData.Scopes)
                                r = r.WithContext(ctx)
                        }</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// Helper methods

func (m *AuthMiddleware) writeErrorResponse(w http.ResponseWriter, statusCode int, message string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        response := map[string]interface{}{
                "error": message,
                "code":  statusCode,
                "time":  time.Now().UTC().Format(time.RFC3339),
        }

        json.NewEncoder(w).Encode(response)
}</span>

func (m *AuthMiddleware) getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                // Take the first IP in the list
                parts := strings.Split(xff, ",")
                return strings.TrimSpace(parts[0])
        }</span>

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

func (m *AuthMiddleware) isAuthEndpoint(path string) bool <span class="cov0" title="0">{
        authEndpoints := []string{
                "/api/v1/auth/login",
                "/api/v1/auth/register",
                "/api/v1/auth/refresh",
                "/api/v1/auth/forgot-password",
                "/api/v1/auth/reset-password",
        }

        for _, endpoint := range authEndpoints </span><span class="cov0" title="0">{
                if path == endpoint </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (m *AuthMiddleware) extractEmailFromRequest(r *http.Request) string <span class="cov0" title="0">{
        // This is a simplified implementation
        // In practice, you might want to parse the request body based on content type
        if r.Header.Get("Content-Type") == "application/json" </span><span class="cov0" title="0">{
                var body map[string]interface{}
                if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov0" title="0">if email, ok := body["email"].(string); ok </span><span class="cov0" title="0">{
                        return email
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (m *AuthMiddleware) extractResourceAndAction(path, method string) (string, string) <span class="cov0" title="0">{
        // Extract resource from URL path
        parts := strings.Split(strings.Trim(path, "/"), "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return "unknown", strings.ToLower(method)
        }</span>

        // Skip "api" and "v1" parts
        <span class="cov0" title="0">resource := parts[2]
        if len(parts) &gt; 3 &amp;&amp; parts[3] != "" </span><span class="cov0" title="0">{
                resource = parts[3]
        }</span>

        // Map HTTP methods to actions
        <span class="cov0" title="0">actionMap := map[string]string{
                "GET":    "read",
                "POST":   "create",
                "PUT":    "update",
                "PATCH":  "update",
                "DELETE": "delete",
        }

        action := actionMap[strings.ToUpper(method)]
        if action == "" </span><span class="cov0" title="0">{
                action = strings.ToLower(method)
        }</span>

        <span class="cov0" title="0">return resource, action</span>
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// AuthMiddlewareChain provides a convenient way to chain authentication middlewares
type AuthMiddlewareChain struct {
        middleware *AuthMiddleware
}

// NewAuthMiddlewareChain creates a new middleware chain
func NewAuthMiddlewareChain(middleware *AuthMiddleware) *AuthMiddlewareChain <span class="cov0" title="0">{
        return &amp;AuthMiddlewareChain{middleware: middleware}
}</span>

// ForPublicEndpoints applies middleware for public endpoints (audit only)
func (c *AuthMiddlewareChain) ForPublicEndpoints() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.AuditMiddleware(
                        c.middleware.OptionalAuthMiddleware(next),
                )
        }</span>
}

// ForProtectedEndpoints applies middleware for protected endpoints (requires authentication)
func (c *AuthMiddlewareChain) ForProtectedEndpoints() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.AuditMiddleware(
                        c.middleware.JWTAuthMiddleware(next),
                )
        }</span>
}

// ForServiceEndpoints applies middleware for service-to-service endpoints (requires API key)
func (c *AuthMiddlewareChain) ForServiceEndpoints() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.AuditMiddleware(
                        c.middleware.APIKeyAuthMiddleware(next),
                )
        }</span>
}

// ForAuthEndpoints applies middleware for authentication endpoints (includes rate limiting)
func (c *AuthMiddlewareChain) ForAuthEndpoints() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.AuditMiddleware(
                        c.middleware.RateLimitMiddleware(next),
                )
        }</span>
}

// ForAdminEndpoints applies middleware for admin endpoints (requires admin role)
func (c *AuthMiddlewareChain) ForAdminEndpoints() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.AuditMiddleware(
                        c.middleware.RequireRole("admin")(
                                c.middleware.JWTAuthMiddleware(next),
                        ),
                )
        }</span>
}

// WithPermission adds permission requirement to any middleware chain
func (c *AuthMiddlewareChain) WithPermission(resource, action string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.RequirePermission(resource, action)(next)
        }</span>
}

// WithRole adds role requirement to any middleware chain
func (c *AuthMiddlewareChain) WithRole(roles ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.RequireRole(roles...)(next)
        }</span>
}

// WithAPIKeyScopes adds API key scope requirement to any middleware chain
func (c *AuthMiddlewareChain) WithAPIKeyScopes(scopes ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return c.middleware.RequireAPIKeyScopes(scopes...)(next)
        }</span>
}

// SetupRoutes demonstrates how to use the middleware with different route types
func (c *AuthMiddlewareChain) SetupRoutes(router *mux.Router) <span class="cov0" title="0">{
        // Public routes (no authentication required)
        publicRouter := router.PathPrefix("/api/v1/public").Subrouter()
        publicRouter.Use(c.ForPublicEndpoints())

        // Authentication routes (with rate limiting)
        authRouter := router.PathPrefix("/api/v1/auth").Subrouter()
        authRouter.Use(c.ForAuthEndpoints())

        // Protected routes (requires authentication)
        protectedRouter := router.PathPrefix("/api/v1/protected").Subrouter()
        protectedRouter.Use(c.ForProtectedEndpoints())

        // Service routes (requires API key)
        serviceRouter := router.PathPrefix("/api/v1/service").Subrouter()
        serviceRouter.Use(c.ForServiceEndpoints())

        // Admin routes (requires admin role)
        adminRouter := router.PathPrefix("/api/v1/admin").Subrouter()
        adminRouter.Use(c.ForAdminEndpoints())

        // Routes with specific permissions
        reviewRouter := router.PathPrefix("/api/v1/reviews").Subrouter()
        reviewRouter.Use(c.ForProtectedEndpoints())
        reviewRouter.Use(c.WithPermission("reviews", "read"))
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

var (
        httpRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Total number of HTTP requests",
        }, []string{"method", "path", "status"})

        httpRequestDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Name:    "http_request_duration_seconds",
                Help:    "HTTP request duration in seconds",
                Buckets: prometheus.DefBuckets,
        }, []string{"method", "path", "status"})
)

// RequestID adds a unique request ID to each request
func RequestID() gin.HandlerFunc <span class="cov8" title="13">{
        return func(c *gin.Context) </span><span class="cov10" title="22">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov9" title="21">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov10" title="22">c.Set("request_id", requestID)
                c.Header("X-Request-ID", requestID)

                c.Next()</span>
        }
}

// Logger logs HTTP requests
func Logger(logger interface{}) gin.HandlerFunc <span class="cov5" title="5">{
        return func(c *gin.Context) </span><span class="cov7" title="9">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                // Process request
                c.Next()

                // Log request details
                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                statusCode := c.Writer.Status()
                errorMessage := c.Errors.ByType(gin.ErrorTypePrivate).String()

                if raw != "" </span><span class="cov1" title="1">{
                        path = path + "?" + raw
                }</span>

                // Log based on logger interface type
                // In production, use structured logging
                <span class="cov7" title="9">fmt.Printf("[%s] %s %s %d %v %s\n",
                        clientIP,
                        method,
                        path,
                        statusCode,
                        latency,
                        errorMessage,
                )</span>
        }
}

// ErrorHandler handles errors in a centralized way
func ErrorHandler(logger interface{}) gin.HandlerFunc <span class="cov5" title="5">{
        return func(c *gin.Context) </span><span class="cov5" title="5">{
                c.Next()

                // Handle any errors that occurred
                if len(c.Errors) &gt; 0 </span><span class="cov4" title="3">{
                        err := c.Errors.Last()

                        // Determine status code
                        status := c.Writer.Status()
                        if status == http.StatusOK </span><span class="cov1" title="1">{
                                status = http.StatusInternalServerError
                        }</span>

                        // Create error response
                        <span class="cov4" title="3">c.JSON(status, gin.H{
                                "error": gin.H{
                                        "message":    err.Error(),
                                        "request_id": c.GetString("request_id"),
                                },
                        })</span>
                }
        }
}

// Security adds security headers
func Security() gin.HandlerFunc <span class="cov5" title="5">{
        return func(c *gin.Context) </span><span class="cov8" title="14">{
                // Add security headers
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Header("X-Permitted-Cross-Domain-Policies", "none")
                c.Header("Referrer-Policy", "no-referrer")

                c.Next()
        }</span>
}

// CORS handles Cross-Origin Resource Sharing
func CORS(allowedOrigins []string) gin.HandlerFunc <span class="cov6" title="6">{
        return func(c *gin.Context) </span><span class="cov6" title="6">{
                origin := c.Request.Header.Get("Origin")

                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov6" title="6">{
                        if allowedOrigin == "*" || allowedOrigin == origin </span><span class="cov5" title="4">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov6" title="6">if allowed </span><span class="cov5" title="4">{
                        c.Header("Access-Control-Allow-Origin", origin)
                        c.Header("Access-Control-Allow-Credentials", "true")
                        c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                        c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")
                }</span>

                <span class="cov6" title="6">if c.Request.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov5" title="5">c.Next()</span>
        }
}

// Metrics collects metrics for Prometheus
func Metrics(monitoring interface{}) gin.HandlerFunc <span class="cov6" title="6">{
        return func(c *gin.Context) </span><span class="cov8" title="15">{
                start := time.Now()
                path := c.FullPath()
                if path == "" </span><span class="cov1" title="1">{
                        path = "unknown"
                }</span>

                // Process request
                <span class="cov8" title="15">c.Next()

                // Record metrics
                status := fmt.Sprintf("%d", c.Writer.Status())
                duration := time.Since(start).Seconds()

                httpRequestsTotal.WithLabelValues(c.Request.Method, path, status).Inc()
                httpRequestDuration.WithLabelValues(c.Request.Method, path, status).Observe(duration)</span>
        }
}

// Tracing adds distributed tracing
func Tracing(serviceName string) gin.HandlerFunc <span class="cov5" title="5">{
        return func(c *gin.Context) </span><span class="cov5" title="5">{
                tracer := otel.Tracer(serviceName)

                // Extract parent span context from headers
                ctx := c.Request.Context()

                // Start a new span
                ctx, span := tracer.Start(ctx, fmt.Sprintf("%s %s", c.Request.Method, c.FullPath()),
                        trace.WithAttributes(
                                attribute.String("http.method", c.Request.Method),
                                attribute.String("http.url", c.Request.URL.String()),
                                attribute.String("http.target", c.Request.RequestURI),
                                attribute.String("http.host", c.Request.Host),
                                attribute.String("http.scheme", "http"),
                                attribute.String("http.user_agent", c.Request.UserAgent()),
                                attribute.String("request.id", c.GetString("request_id")),
                        ),
                )
                defer span.End()

                // Update request context
                c.Request = c.Request.WithContext(ctx)

                // Process request
                c.Next()

                // Set span attributes based on response
                span.SetAttributes(
                        attribute.Int("http.status_code", c.Writer.Status()),
                        attribute.Int64("http.response_size", int64(c.Writer.Size())),
                )

                // Mark span as error if status code indicates error
                if c.Writer.Status() &gt;= 400 </span><span class="cov3" title="2">{
                        span.SetAttributes(attribute.Bool("error", true))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// CircuitBreakerMiddleware provides HTTP middleware for circuit breaker protection
type CircuitBreakerMiddleware struct {
        manager *infrastructure.CircuitBreakerManager
        logger  *logger.Logger
}

// NewCircuitBreakerMiddleware creates a new circuit breaker middleware
func NewCircuitBreakerMiddleware(manager *infrastructure.CircuitBreakerManager, logger *logger.Logger) *CircuitBreakerMiddleware <span class="cov0" title="0">{
        return &amp;CircuitBreakerMiddleware{
                manager: manager,
                logger:  logger,
        }
}</span>

// HTTPMiddleware returns a Gin middleware that protects HTTP handlers with circuit breaker
func (m *CircuitBreakerMiddleware) HTTPMiddleware(serviceName string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                breaker, exists := m.manager.GetCircuitBreaker(serviceName)
                if !exists </span><span class="cov0" title="0">{
                        m.logger.Warn("Circuit breaker not found for service", "service", serviceName)
                        c.Next()
                        return
                }</span>

                // Create a context with timeout
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
                defer cancel()

                // Execute the handler with circuit breaker protection
                result, err := breaker.ExecuteWithFallback(ctx, func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                        // Create a new context for the handler
                        c.Request = c.Request.WithContext(ctx)

                        // Execute the handler
                        c.Next()

                        // Check if there was an error (status &gt;= 500)
                        if c.Writer.Status() &gt;= 500 </span><span class="cov0" title="0">{
                                return nil, &amp;HTTPError{
                                        StatusCode: c.Writer.Status(),
                                        Message:    "HTTP error occurred",
                                }
                        }</span>

                        <span class="cov0" title="0">return nil, nil</span>
                }, m.createHTTPFallback(c, serviceName))

                // Handle circuit breaker errors
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if infrastructure.IsCircuitBreakerError(err) </span><span class="cov0" title="0">{
                                m.logger.Warn("Circuit breaker rejected request",
                                        "service", serviceName,
                                        "path", c.Request.URL.Path,
                                        "method", c.Request.Method,
                                        "error", err,
                                )

                                c.JSON(http.StatusServiceUnavailable, gin.H{
                                        "error":   "Service temporarily unavailable",
                                        "service": serviceName,
                                        "code":    "CIRCUIT_BREAKER_OPEN",
                                })
                                c.Abort()
                                return
                        }</span>

                        // If fallback was executed, the response might already be set
                        <span class="cov0" title="0">if result != nil </span><span class="cov0" title="0">{
                                m.logger.Info("Circuit breaker fallback executed",
                                        "service", serviceName,
                                        "path", c.Request.URL.Path,
                                        "method", c.Request.Method,
                                )
                        }</span>
                }
        }
}

// createHTTPFallback creates a fallback function for HTTP requests
func (m *CircuitBreakerMiddleware) createHTTPFallback(c *gin.Context, serviceName string) infrastructure.FallbackFunc <span class="cov0" title="0">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov0" title="0">{
                m.logger.Info("Executing HTTP fallback",
                        "service", serviceName,
                        "path", c.Request.URL.Path,
                        "method", c.Request.Method,
                        "original_error", err,
                )

                // Provide a generic fallback response
                switch c.Request.URL.Path </span>{
                case "/health":<span class="cov0" title="0">
                        c.JSON(http.StatusOK, gin.H{
                                "status":  "degraded",
                                "service": serviceName,
                                "message": "Service is experiencing issues",
                        })</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusServiceUnavailable, gin.H{
                                "error":   "Service temporarily unavailable",
                                "service": serviceName,
                                "code":    "FALLBACK_RESPONSE",
                                "message": "Please try again later",
                        })</span>
                }

                <span class="cov0" title="0">return "fallback_executed", nil</span>
        }
}

// HTTPError represents an HTTP error
type HTTPError struct {
        StatusCode int
        Message    string
}

func (e *HTTPError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// DatabaseMiddleware provides database operation protection with circuit breaker
type DatabaseMiddleware struct {
        breaker *infrastructure.CircuitBreaker
        logger  *logger.Logger
}

// NewDatabaseMiddleware creates a new database middleware
func NewDatabaseMiddleware(breaker *infrastructure.CircuitBreaker, logger *logger.Logger) *DatabaseMiddleware <span class="cov0" title="0">{
        return &amp;DatabaseMiddleware{
                breaker: breaker,
                logger:  logger,
        }
}</span>

// ExecuteQuery executes a database query with circuit breaker protection
func (m *DatabaseMiddleware) ExecuteQuery(ctx context.Context, queryFunc func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        return m.breaker.ExecuteWithFallback(ctx, queryFunc, m.createDBFallback())
}</span>

// createDBFallback creates a fallback function for database operations
func (m *DatabaseMiddleware) createDBFallback() infrastructure.FallbackFunc <span class="cov0" title="0">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov0" title="0">{
                m.logger.Warn("Database circuit breaker fallback executed", "error", err)

                // Return cached data or default values
                // This is a placeholder - in real implementation, you would
                // return cached data or appropriate fallback response
                return nil, &amp;DatabaseFallbackError{
                        OriginalError: err,
                        Message:       "Database temporarily unavailable, using fallback",
                }
        }</span>
}

// DatabaseFallbackError represents a database fallback error
type DatabaseFallbackError struct {
        OriginalError error
        Message       string
}

func (e *DatabaseFallbackError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// CacheMiddleware provides cache operation protection with circuit breaker
type CacheMiddleware struct {
        breaker *infrastructure.CircuitBreaker
        logger  *logger.Logger
}

// NewCacheMiddleware creates a new cache middleware
func NewCacheMiddleware(breaker *infrastructure.CircuitBreaker, logger *logger.Logger) *CacheMiddleware <span class="cov0" title="0">{
        return &amp;CacheMiddleware{
                breaker: breaker,
                logger:  logger,
        }
}</span>

// ExecuteCache executes a cache operation with circuit breaker protection
func (m *CacheMiddleware) ExecuteCache(ctx context.Context, cacheFunc func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        return m.breaker.ExecuteWithFallback(ctx, cacheFunc, m.createCacheFallback())
}</span>

// createCacheFallback creates a fallback function for cache operations
func (m *CacheMiddleware) createCacheFallback() infrastructure.FallbackFunc <span class="cov0" title="0">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov0" title="0">{
                m.logger.Info("Cache circuit breaker fallback executed", "error", err)

                // For cache operations, fallback usually means proceed without cache
                return nil, nil
        }</span>
}

// S3Middleware provides S3 operation protection with circuit breaker
type S3Middleware struct {
        breaker *infrastructure.CircuitBreaker
        logger  *logger.Logger
}

// NewS3Middleware creates a new S3 middleware
func NewS3Middleware(breaker *infrastructure.CircuitBreaker, logger *logger.Logger) *S3Middleware <span class="cov0" title="0">{
        return &amp;S3Middleware{
                breaker: breaker,
                logger:  logger,
        }
}</span>

// ExecuteS3Operation executes an S3 operation with circuit breaker protection
func (m *S3Middleware) ExecuteS3Operation(ctx context.Context, s3Func func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        return m.breaker.ExecuteWithFallback(ctx, s3Func, m.createS3Fallback())
}</span>

// createS3Fallback creates a fallback function for S3 operations
func (m *S3Middleware) createS3Fallback() infrastructure.FallbackFunc <span class="cov0" title="0">{
        return func(ctx context.Context, err error) (interface{}, error) </span><span class="cov0" title="0">{
                m.logger.Warn("S3 circuit breaker fallback executed", "error", err)

                // For S3 operations, fallback might mean using local storage
                // or returning an error indicating the operation failed
                return nil, &amp;S3FallbackError{
                        OriginalError: err,
                        Message:       "S3 service temporarily unavailable",
                }
        }</span>
}

// S3FallbackError represents an S3 fallback error
type S3FallbackError struct {
        OriginalError error
        Message       string
}

func (e *S3FallbackError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// CircuitBreakerHealthCheck provides health check endpoints for circuit breakers
type CircuitBreakerHealthCheck struct {
        manager *infrastructure.CircuitBreakerManager
        logger  *logger.Logger
}

// NewCircuitBreakerHealthCheck creates a new circuit breaker health check
func NewCircuitBreakerHealthCheck(manager *infrastructure.CircuitBreakerManager, logger *logger.Logger) *CircuitBreakerHealthCheck <span class="cov0" title="0">{
        return &amp;CircuitBreakerHealthCheck{
                manager: manager,
                logger:  logger,
        }
}</span>

// HealthCheckHandler returns a Gin handler for circuit breaker health checks
func (h *CircuitBreakerHealthCheck) HealthCheckHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                breakers := h.manager.GetAllCircuitBreakers()

                status := "healthy"
                statusCode := http.StatusOK
                breakerStatus := make(map[string]interface{})

                for name, breaker := range breakers </span><span class="cov0" title="0">{
                        metrics := breaker.GetMetrics()

                        breakerInfo := gin.H{
                                "state":          metrics.CurrentState.String(),
                                "total_requests": metrics.TotalRequests,
                                "success_rate":   metrics.SuccessRate,
                                "failure_rate":   metrics.FailureRate,
                                "last_failure":   metrics.LastFailure,
                                "last_success":   metrics.LastSuccess,
                        }

                        breakerStatus[name] = breakerInfo

                        // If any breaker is open, mark overall status as degraded
                        if breaker.IsOpen() </span><span class="cov0" title="0">{
                                status = "degraded"
                                statusCode = http.StatusPartialContent
                        }</span>
                }

                <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                        "status":           status,
                        "circuit_breakers": breakerStatus,
                        "timestamp":        time.Now().UTC(),
                })</span>
        }
}

// MetricsHandler returns a Gin handler for circuit breaker metrics
func (h *CircuitBreakerHealthCheck) MetricsHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                metrics := h.manager.GetMetrics()

                c.JSON(http.StatusOK, gin.H{
                        "metrics":   metrics,
                        "timestamp": time.Now().UTC(),
                })
        }</span>
}

// CircuitBreakerConfig provides configuration for circuit breaker middleware
type CircuitBreakerConfig struct {
        Enabled      bool                                            `json:"enabled"`
        Services     map[string]*infrastructure.CircuitBreakerConfig `json:"services"`
        GlobalConfig *infrastructure.CircuitBreakerConfig            `json:"global_config"`
}

// DefaultCircuitBreakerConfig returns default configuration
func DefaultCircuitBreakerConfig() *CircuitBreakerConfig <span class="cov0" title="0">{
        return &amp;CircuitBreakerConfig{
                Enabled: true,
                Services: map[string]*infrastructure.CircuitBreakerConfig{
                        "database": {
                                Name:                "database",
                                FailureThreshold:    3,
                                SuccessThreshold:    2,
                                ConsecutiveFailures: 2,
                                MinimumRequestCount: 5,
                                RequestTimeout:      10 * time.Second,
                                OpenTimeout:         30 * time.Second,
                                HalfOpenTimeout:     15 * time.Second,
                                WindowSize:          30 * time.Second,
                                WindowBuckets:       6,
                                MaxRetries:          2,
                                RetryDelay:          500 * time.Millisecond,
                                RetryBackoffFactor:  2.0,
                                FailFast:            true,
                                EnableFallback:      true,
                                EnableMetrics:       true,
                                EnableLogging:       true,
                                HealthCheckInterval: 15 * time.Second,
                                HealthCheckTimeout:  3 * time.Second,
                                EnableHealthCheck:   true,
                        },
                        "cache": {
                                Name:                "cache",
                                FailureThreshold:    10,
                                SuccessThreshold:    5,
                                ConsecutiveFailures: 5,
                                MinimumRequestCount: 20,
                                RequestTimeout:      5 * time.Second,
                                OpenTimeout:         15 * time.Second,
                                HalfOpenTimeout:     10 * time.Second,
                                WindowSize:          30 * time.Second,
                                WindowBuckets:       6,
                                MaxRetries:          1,
                                RetryDelay:          100 * time.Millisecond,
                                RetryBackoffFactor:  1.5,
                                FailFast:            false,
                                EnableFallback:      true,
                                EnableMetrics:       true,
                                EnableLogging:       true,
                                HealthCheckInterval: 10 * time.Second,
                                HealthCheckTimeout:  2 * time.Second,
                                EnableHealthCheck:   true,
                        },
                        "s3": {
                                Name:                "s3",
                                FailureThreshold:    5,
                                SuccessThreshold:    3,
                                ConsecutiveFailures: 3,
                                MinimumRequestCount: 10,
                                RequestTimeout:      30 * time.Second,
                                OpenTimeout:         60 * time.Second,
                                HalfOpenTimeout:     30 * time.Second,
                                WindowSize:          60 * time.Second,
                                WindowBuckets:       10,
                                MaxRetries:          3,
                                RetryDelay:          1 * time.Second,
                                RetryBackoffFactor:  2.0,
                                FailFast:            true,
                                EnableFallback:      true,
                                EnableMetrics:       true,
                                EnableLogging:       true,
                                HealthCheckInterval: 30 * time.Second,
                                HealthCheckTimeout:  5 * time.Second,
                                EnableHealthCheck:   false,
                        },
                },
                GlobalConfig: infrastructure.DefaultCircuitBreakerConfig(),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ErrorHandlerMiddleware provides centralized error handling for HTTP requests
type ErrorHandlerMiddleware struct {
        errorHandler *infrastructure.ErrorHandler
        logger       *logger.Logger
}

// NewErrorHandlerMiddleware creates a new error handler middleware
func NewErrorHandlerMiddleware(errorHandler *infrastructure.ErrorHandler, logger *logger.Logger) *ErrorHandlerMiddleware <span class="cov0" title="0">{
        return &amp;ErrorHandlerMiddleware{
                errorHandler: errorHandler,
                logger:       logger,
        }
}</span>

// Handle returns the middleware handler function
func (ehm *ErrorHandlerMiddleware) Handle(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Create error-aware response writer
                eww := &amp;errorAwareResponseWriter{
                        ResponseWriter: w,
                        request:        r,
                        errorHandler:   ehm.errorHandler,
                        logger:         ehm.logger,
                }

                // Set up panic recovery
                defer func() </span><span class="cov0" title="0">{
                        if recovered := recover(); recovered != nil </span><span class="cov0" title="0">{
                                ehm.handlePanic(eww, r, recovered)
                        }</span>
                }()

                // Continue with the next handler
                <span class="cov0" title="0">next.ServeHTTP(eww, r)</span>
        })
}

// errorAwareResponseWriter wraps http.ResponseWriter to provide error handling
type errorAwareResponseWriter struct {
        http.ResponseWriter
        request       *http.Request
        errorHandler  *infrastructure.ErrorHandler
        logger        *logger.Logger
        statusCode    int
        bytesWritten  int64
        headerWritten bool
}

// WriteHeader captures the status code and handles errors
func (w *errorAwareResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode

        // Check if this is an error status code
        if statusCode &gt;= 400 &amp;&amp; !w.headerWritten </span><span class="cov0" title="0">{
                // Create error from status code
                err := w.createErrorFromStatusCode(statusCode)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle the error through the error handler
                        appErr := w.errorHandler.Handle(w.request.Context(), err)
                        if appErr != nil </span><span class="cov0" title="0">{
                                // Update response based on error handling
                                w.updateResponseForError(appErr)
                        }</span>
                }
        }

        <span class="cov0" title="0">w.headerWritten = true
        w.ResponseWriter.WriteHeader(statusCode)</span>
}

// Write captures the response data
func (w *errorAwareResponseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        if !w.headerWritten </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
        }</span>

        <span class="cov0" title="0">n, err := w.ResponseWriter.Write(data)
        w.bytesWritten += int64(n)
        return n, err</span>
}

// createErrorFromStatusCode creates an error from HTTP status code
func (w *errorAwareResponseWriter) createErrorFromStatusCode(statusCode int) error <span class="cov0" title="0">{
        switch statusCode </span>{
        case http.StatusBadRequest:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeValidation,
                        Code:       "BAD_REQUEST",
                        Message:    "Bad request",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeAuthentication,
                        Code:       "UNAUTHORIZED",
                        Message:    "Unauthorized",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeAuthorization,
                        Code:       "FORBIDDEN",
                        Message:    "Forbidden",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusNotFound:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeNotFound,
                        Code:       "NOT_FOUND",
                        Message:    "Resource not found",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusConflict:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeConflict,
                        Code:       "CONFLICT",
                        Message:    "Resource conflict",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusTooManyRequests:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeRateLimit,
                        Code:       "TOO_MANY_REQUESTS",
                        Message:    "Too many requests",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeSystem,
                        Code:       "INTERNAL_SERVER_ERROR",
                        Message:    "Internal server error",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusBadGateway:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeNetwork,
                        Code:       "BAD_GATEWAY",
                        Message:    "Bad gateway",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusServiceUnavailable:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeCircuitBreaker,
                        Code:       "SERVICE_UNAVAILABLE",
                        Message:    "Service unavailable",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        case http.StatusGatewayTimeout:<span class="cov0" title="0">
                return &amp;infrastructure.AppError{
                        Type:       infrastructure.ErrorTypeTimeout,
                        Code:       "GATEWAY_TIMEOUT",
                        Message:    "Gateway timeout",
                        HTTPStatus: statusCode,
                        Timestamp:  time.Now(),
                }</span>
        default:<span class="cov0" title="0">
                if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        return &amp;infrastructure.AppError{
                                Type:       infrastructure.ErrorTypeSystem,
                                Code:       "SERVER_ERROR",
                                Message:    "Server error",
                                HTTPStatus: statusCode,
                                Timestamp:  time.Now(),
                        }
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        return &amp;infrastructure.AppError{
                                Type:       infrastructure.ErrorTypeClient,
                                Code:       "CLIENT_ERROR",
                                Message:    "Client error",
                                HTTPStatus: statusCode,
                                Timestamp:  time.Now(),
                        }
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// updateResponseForError updates the response based on error handling
func (w *errorAwareResponseWriter) updateResponseForError(appErr *infrastructure.AppError) <span class="cov0" title="0">{
        // Add error-specific headers
        w.Header().Set("X-Error-ID", appErr.ID)
        w.Header().Set("X-Error-Type", string(appErr.Type))
        w.Header().Set("X-Error-Code", appErr.Code)

        if appErr.CorrelationID != "" </span><span class="cov0" title="0">{
                w.Header().Set("X-Correlation-ID", appErr.CorrelationID)
        }</span>

        <span class="cov0" title="0">if appErr.RetryAfter != nil </span><span class="cov0" title="0">{
                w.Header().Set("Retry-After", appErr.RetryAfter.String())
        }</span>

        // Update status code if needed
        <span class="cov0" title="0">if appErr.HTTPStatus != 0 &amp;&amp; appErr.HTTPStatus != w.statusCode </span><span class="cov0" title="0">{
                w.statusCode = appErr.HTTPStatus
        }</span>
}

// handlePanic handles panics and converts them to errors
func (ehm *ErrorHandlerMiddleware) handlePanic(w *errorAwareResponseWriter, r *http.Request, recovered interface{}) <span class="cov0" title="0">{
        // Create error from panic
        panicErr := &amp;infrastructure.AppError{
                Type:     infrastructure.ErrorTypeSystem,
                Category: infrastructure.CategoryCritical,
                Severity: infrastructure.SeverityCritical,
                Code:     "PANIC",
                Message:  "Application panic occurred",
                Details: map[string]interface{}{
                        "panic_value": recovered,
                        "request_uri": r.RequestURI,
                        "method":      r.Method,
                },
                Timestamp:  time.Now(),
                HTTPStatus: http.StatusInternalServerError,
        }

        // Handle the panic error
        appErr := ehm.errorHandler.Handle(r.Context(), panicErr)

        // Write error response
        if !w.headerWritten </span><span class="cov0" title="0">{
                ehm.errorHandler.HandleHTTP(r.Context(), w, r, appErr)
        }</span>

        // Log the panic
        <span class="cov0" title="0">ehm.logger.ErrorContext(r.Context(), "Application panic recovered",
                "panic_value", recovered,
                "error_id", appErr.ID,
                "request_uri", r.RequestURI,
                "method", r.Method,
        )</span>
}

// ErrorHandlerFunc provides a function-based error handler for use in handlers
type ErrorHandlerFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request, err error)

// NewErrorHandlerFunc creates a new error handler function
func NewErrorHandlerFunc(errorHandler *infrastructure.ErrorHandler) ErrorHandlerFunc <span class="cov0" title="0">{
        return func(ctx context.Context, w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">errorHandler.HandleHTTP(ctx, w, r, err)</span>
        }
}

// ErrorHandlerService provides error handling utilities for services
type ErrorHandlerService struct {
        errorHandler *infrastructure.ErrorHandler
        logger       *logger.Logger
}

// NewErrorHandlerService creates a new error handler service
func NewErrorHandlerService(errorHandler *infrastructure.ErrorHandler, logger *logger.Logger) *ErrorHandlerService <span class="cov0" title="0">{
        return &amp;ErrorHandlerService{
                errorHandler: errorHandler,
                logger:       logger,
        }
}</span>

// WrapError wraps an error with additional context
func (ehs *ErrorHandlerService) WrapError(ctx context.Context, err error, message string, details map[string]interface{}) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create enhanced error
        <span class="cov0" title="0">wrappedErr := &amp;infrastructure.AppError{
                Type:          infrastructure.ErrorTypeSystem,
                Category:      infrastructure.CategoryTransient,
                Severity:      infrastructure.SeverityMedium,
                Code:          "WRAPPED_ERROR",
                Message:       message,
                Details:       details,
                Timestamp:     time.Now(),
                Cause:         err,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, wrappedErr)</span>
}

// HandleServiceError handles service-level errors
func (ehs *ErrorHandlerService) HandleServiceError(ctx context.Context, err error, service string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create service error
        <span class="cov0" title="0">serviceErr := &amp;infrastructure.AppError{
                Type:     infrastructure.ErrorTypeSystem,
                Category: infrastructure.CategoryTransient,
                Severity: infrastructure.SeverityMedium,
                Code:     "SERVICE_ERROR",
                Message:  err.Error(),
                Details: map[string]interface{}{
                        "service": service,
                },
                Timestamp:     time.Now(),
                Source:        service,
                Cause:         err,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, serviceErr)</span>
}

// HandleDatabaseError handles database-specific errors
func (ehs *ErrorHandlerService) HandleDatabaseError(ctx context.Context, err error, operation string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create database error
        <span class="cov0" title="0">dbErr := &amp;infrastructure.AppError{
                Type:     infrastructure.ErrorTypeDatabase,
                Category: infrastructure.CategoryTransient,
                Severity: infrastructure.SeverityHigh,
                Code:     "DATABASE_ERROR",
                Message:  err.Error(),
                Details: map[string]interface{}{
                        "operation": operation,
                },
                Timestamp:     time.Now(),
                Source:        "database",
                Cause:         err,
                Retryable:     true,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, dbErr)</span>
}

// HandleValidationError handles validation errors
func (ehs *ErrorHandlerService) HandleValidationError(ctx context.Context, err error, field string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create validation error
        <span class="cov0" title="0">validationErr := &amp;infrastructure.AppError{
                Type:        infrastructure.ErrorTypeValidation,
                Category:    infrastructure.CategoryPermanent,
                Severity:    infrastructure.SeverityLow,
                Code:        "VALIDATION_ERROR",
                Message:     err.Error(),
                UserMessage: "Please check your input and try again.",
                Details: map[string]interface{}{
                        "field": field,
                },
                Timestamp:     time.Now(),
                HTTPStatus:    http.StatusBadRequest,
                Retryable:     false,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, validationErr)</span>
}

// HandleExternalServiceError handles external service errors
func (ehs *ErrorHandlerService) HandleExternalServiceError(ctx context.Context, err error, service string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create external service error
        <span class="cov0" title="0">extErr := &amp;infrastructure.AppError{
                Type:     infrastructure.ErrorTypeExternal,
                Category: infrastructure.CategoryTransient,
                Severity: infrastructure.SeverityMedium,
                Code:     "EXTERNAL_SERVICE_ERROR",
                Message:  err.Error(),
                Details: map[string]interface{}{
                        "external_service": service,
                },
                Timestamp:     time.Now(),
                Source:        service,
                Cause:         err,
                Retryable:     true,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, extErr)</span>
}

// CreateBusinessError creates a business logic error
func (ehs *ErrorHandlerService) CreateBusinessError(ctx context.Context, code, message, userMessage string, details map[string]interface{}) error <span class="cov0" title="0">{
        businessErr := &amp;infrastructure.AppError{
                Type:          infrastructure.ErrorTypeBusiness,
                Category:      infrastructure.CategoryPermanent,
                Severity:      infrastructure.SeverityMedium,
                Code:          code,
                Message:       message,
                UserMessage:   userMessage,
                Details:       details,
                Timestamp:     time.Now(),
                HTTPStatus:    http.StatusBadRequest,
                Retryable:     false,
                CorrelationID: logger.GetCorrelationID(ctx),
                RequestID:     logger.GetRequestID(ctx),
                UserID:        logger.GetUserID(ctx),
        }

        return ehs.errorHandler.Handle(ctx, businessErr)
}</span>

// IsRetryableError checks if an error is retryable
func (ehs *ErrorHandlerService) IsRetryableError(err error) bool <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.IsRetryable()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsCriticalError checks if an error is critical
func (ehs *ErrorHandlerService) IsCriticalError(err error) bool <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.IsCritical()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsTemporaryError checks if an error is temporary
func (ehs *ErrorHandlerService) IsTemporaryError(err error) bool <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.IsTemporary()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetErrorCode gets the error code from an error
func (ehs *ErrorHandlerService) GetErrorCode(err error) string <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.Code
        }</span>
        <span class="cov0" title="0">return "UNKNOWN_ERROR"</span>
}

// GetErrorType gets the error type from an error
func (ehs *ErrorHandlerService) GetErrorType(err error) infrastructure.ErrorType <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.Type
        }</span>
        <span class="cov0" title="0">return infrastructure.ErrorTypeSystem</span>
}

// GetRetryAfter gets the retry after duration from an error
func (ehs *ErrorHandlerService) GetRetryAfter(err error) *time.Duration <span class="cov0" title="0">{
        if appErr, ok := err.(*infrastructure.AppError); ok </span><span class="cov0" title="0">{
                return appErr.RetryAfter
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package infrastructure

import (
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
)

// Migrator handles database migrations
type Migrator struct {
        pool   *pgxpool.Pool
        logger interface{}
}

// NewMigrator creates a new migrator instance
func NewMigrator(pool *pgxpool.Pool, logger interface{}) *Migrator <span class="cov0" title="0">{
        return &amp;Migrator{
                pool:   pool,
                logger: logger,
        }
}</span>

// Up runs all pending migrations
func (m *Migrator) Up() error <span class="cov0" title="0">{
        // Get standard database/sql connection from pgxpool
        db := stdlib.OpenDBFromPool(m.pool)

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migration driver: %w", err)
        }</span>

        <span class="cov0" title="0">migrator, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrator: %w", err)
        }</span>

        <span class="cov0" title="0">if err := migrator.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Down rolls back the last migration
func (m *Migrator) Down() error <span class="cov0" title="0">{
        db := stdlib.OpenDBFromPool(m.pool)

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migration driver: %w", err)
        }</span>

        <span class="cov0" title="0">migrator, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrator: %w", err)
        }</span>

        <span class="cov0" title="0">if err := migrator.Down(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rollback migration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Version returns the current migration version
func (m *Migrator) Version() (uint, bool, error) <span class="cov0" title="0">{
        db := stdlib.OpenDBFromPool(m.pool)

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to create migration driver: %w", err)
        }</span>

        <span class="cov0" title="0">migrator, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to create migrator: %w", err)
        }</span>

        <span class="cov0" title="0">version, dirty, err := migrator.Version()
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to get migration version: %w", err)
        }</span>

        <span class="cov0" title="0">return version, dirty, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ProtectedReviewRepository wraps the review repository with circuit breaker protection
type ProtectedReviewRepository struct {
        dbWrapper *DatabaseWrapper
        logger    *logger.Logger
}

// NewProtectedReviewRepository creates a new protected review repository
func NewProtectedReviewRepository(dbWrapper *DatabaseWrapper, logger *logger.Logger) *ProtectedReviewRepository <span class="cov0" title="0">{
        return &amp;ProtectedReviewRepository{
                dbWrapper: dbWrapper,
                logger:    logger,
        }
}</span>

// CreateReview creates a new review with circuit breaker protection
func (r *ProtectedReviewRepository) CreateReview(ctx context.Context, review *domain.Review) error <span class="cov0" title="0">{
        return r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Set timestamps
                now := time.Now()
                review.CreatedAt = now
                review.UpdatedAt = now

                // Generate ID if not set
                if review.ID == uuid.Nil </span><span class="cov0" title="0">{
                        review.ID = uuid.New()
                }</span>

                // Create the review
                <span class="cov0" title="0">if err := db.Create(review).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to create review", "error", err, "review_id", review.ID)
                        return err
                }</span>

                <span class="cov0" title="0">r.logger.Info("Review created successfully", "review_id", review.ID)
                return nil</span>
        })
}

// GetReviewByID retrieves a review by ID with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewByID(ctx context.Context, id uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        var review domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.First(&amp;review, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                                return domain.ErrReviewNotFound
                        }</span>
                        <span class="cov0" title="0">r.logger.Error("Failed to get review by ID", "error", err, "review_id", id)
                        return err</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;review, nil</span>
}

// GetReviewsByHotelID retrieves reviews for a specific hotel with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewsByHotelID(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("hotel_id = ?", hotelID).
                        Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews by hotel ID", "error", err, "hotel_id", hotelID)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetReviewsByProviderID retrieves reviews for a specific provider with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewsByProviderID(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("provider_id = ?", providerID).
                        Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews by provider ID", "error", err, "provider_id", providerID)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetReviews retrieves reviews with pagination and circuit breaker protection
func (r *ProtectedReviewRepository) GetReviews(ctx context.Context, limit, offset int) ([]*domain.Review, int64, error) <span class="cov0" title="0">{
        var reviews []*domain.Review
        var total int64

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Get total count
                if err := db.Model(&amp;domain.Review{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to count reviews", "error", err)
                        return err
                }</span>

                // Get reviews with pagination
                <span class="cov0" title="0">if err := db.Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return reviews, total, nil</span>
}

// UpdateReview updates an existing review with circuit breaker protection
func (r *ProtectedReviewRepository) UpdateReview(ctx context.Context, review *domain.Review) error <span class="cov0" title="0">{
        return r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Update timestamp
                review.UpdatedAt = time.Now()

                // Update the review
                if err := db.Save(review).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to update review", "error", err, "review_id", review.ID)
                        return err
                }</span>

                <span class="cov0" title="0">r.logger.Info("Review updated successfully", "review_id", review.ID)
                return nil</span>
        })
}

// DeleteReview deletes a review with circuit breaker protection
func (r *ProtectedReviewRepository) DeleteReview(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                result := db.Delete(&amp;domain.Review{}, "id = ?", id)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to delete review", "error", result.Error, "review_id", id)
                        return result.Error
                }</span>

                <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return domain.ErrReviewNotFound
                }</span>

                <span class="cov0" title="0">r.logger.Info("Review deleted successfully", "review_id", id)
                return nil</span>
        })
}

// GetReviewsByExternalID retrieves reviews by external ID with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewsByExternalID(ctx context.Context, providerID uuid.UUID, externalID string) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("provider_id = ? AND external_id = ?", providerID, externalID).
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews by external ID",
                                "error", err,
                                "provider_id", providerID,
                                "external_id", externalID)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetReviewCount returns the total number of reviews with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var count int64

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Model(&amp;domain.Review{}).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to count reviews", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetReviewStatistics returns review statistics with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewStatistics(ctx context.Context) (*domain.ReviewStatistics, error) <span class="cov0" title="0">{
        var stats domain.ReviewStatistics

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Get total count
                if err := db.Model(&amp;domain.Review{}).Count(&amp;stats.TotalReviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to count total reviews", "error", err)
                        return err
                }</span>

                // Get average rating
                <span class="cov0" title="0">var avgRating float64
                if err := db.Model(&amp;domain.Review{}).
                        Select("AVG(rating)").
                        Scan(&amp;avgRating).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to calculate average rating", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">stats.AverageRating = avgRating

                // Get rating distribution
                var ratingDistribution []struct {
                        Rating float64
                        Count  int64
                }
                if err := db.Model(&amp;domain.Review{}).
                        Select("rating, COUNT(*) as count").
                        Group("rating").
                        Scan(&amp;ratingDistribution).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get rating distribution", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">stats.RatingDistribution = make(map[int]int)
                for _, rd := range ratingDistribution </span><span class="cov0" title="0">{
                        stats.RatingDistribution[int(rd.Rating)] = int(rd.Count)
                }</span>

                // Get reviews by provider
                <span class="cov0" title="0">var providerStats []struct {
                        ProviderID uuid.UUID
                        Count      int64
                }
                if err := db.Model(&amp;domain.Review{}).
                        Select("provider_id, COUNT(*) as count").
                        Group("provider_id").
                        Scan(&amp;providerStats).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get provider statistics", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">stats.ReviewsByProvider = make(map[string]int)
                for _, ps := range providerStats </span><span class="cov0" title="0">{
                        stats.ReviewsByProvider[ps.ProviderID.String()] = int(ps.Count)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// BatchCreateReviews creates multiple reviews in a transaction with circuit breaker protection
func (r *ProtectedReviewRepository) BatchCreateReviews(ctx context.Context, reviews []*domain.Review) error <span class="cov0" title="0">{
        return r.dbWrapper.ExecuteTransaction(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                now := time.Now()

                for _, review := range reviews </span><span class="cov0" title="0">{
                        // Set timestamps
                        review.CreatedAt = now
                        review.UpdatedAt = now

                        // Generate ID if not set
                        if review.ID == uuid.Nil </span><span class="cov0" title="0">{
                                review.ID = uuid.New()
                        }</span>
                }

                // Batch create reviews
                <span class="cov0" title="0">if err := db.CreateInBatches(reviews, 100).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to batch create reviews", "error", err, "count", len(reviews))
                        return err
                }</span>

                <span class="cov0" title="0">r.logger.Info("Reviews batch created successfully", "count", len(reviews))
                return nil</span>
        })
}

// FindReviewsByDateRange finds reviews within a date range with circuit breaker protection
func (r *ProtectedReviewRepository) FindReviewsByDateRange(ctx context.Context, startDate, endDate time.Time, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("review_date BETWEEN ? AND ?", startDate, endDate).
                        Limit(limit).Offset(offset).
                        Order("review_date DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to find reviews by date range",
                                "error", err,
                                "start_date", startDate,
                                "end_date", endDate)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// FindReviewsByRating finds reviews with a specific rating with circuit breaker protection
func (r *ProtectedReviewRepository) FindReviewsByRating(ctx context.Context, rating float64, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("rating = ?", rating).
                        Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to find reviews by rating", "error", err, "rating", rating)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// SearchReviews searches reviews by text with circuit breaker protection
func (r *ProtectedReviewRepository) SearchReviews(ctx context.Context, query string, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                searchPattern := fmt.Sprintf("%%%s%%", query)
                if err := db.Where("title ILIKE ? OR comment ILIKE ?", searchPattern, searchPattern).
                        Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to search reviews", "error", err, "query", query)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetReviewsByLanguage retrieves reviews by language with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewsByLanguage(ctx context.Context, language string, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("language = ?", language).
                        Limit(limit).Offset(offset).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews by language", "error", err, "language", language)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetLatestReviews retrieves the most recent reviews with circuit breaker protection
func (r *ProtectedReviewRepository) GetLatestReviews(ctx context.Context, limit int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Limit(limit).
                        Order("created_at DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get latest reviews", "error", err, "limit", limit)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// GetReviewsWithRatings retrieves reviews with specific rating criteria with circuit breaker protection
func (r *ProtectedReviewRepository) GetReviewsWithRatings(ctx context.Context, minRating, maxRating float64, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        var reviews []*domain.Review

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                if err := db.Where("rating BETWEEN ? AND ?", minRating, maxRating).
                        Limit(limit).Offset(offset).
                        Order("rating DESC").
                        Find(&amp;reviews).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get reviews with ratings",
                                "error", err,
                                "min_rating", minRating,
                                "max_rating", maxRating)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

// Health check method for the repository
func (r *ProtectedReviewRepository) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Simple health check query
                var count int64
                if err := db.Model(&amp;domain.Review{}).Limit(1).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Repository health check failed", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

// GetRepositoryMetrics returns repository performance metrics
func (r *ProtectedReviewRepository) GetRepositoryMetrics(ctx context.Context) (*RepositoryMetrics, error) <span class="cov0" title="0">{
        var metrics RepositoryMetrics

        err := r.dbWrapper.ExecuteQuery(ctx, func(db *gorm.DB) error </span><span class="cov0" title="0">{
                // Get total reviews
                if err := db.Model(&amp;domain.Review{}).Count(&amp;metrics.TotalReviews).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get reviews created today
                <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour)
                if err := db.Model(&amp;domain.Review{}).
                        Where("created_at &gt;= ?", today).
                        Count(&amp;metrics.ReviewsToday).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get reviews created this week
                <span class="cov0" title="0">weekAgo := time.Now().AddDate(0, 0, -7)
                if err := db.Model(&amp;domain.Review{}).
                        Where("created_at &gt;= ?", weekAgo).
                        Count(&amp;metrics.ReviewsThisWeek).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get reviews created this month
                <span class="cov0" title="0">monthAgo := time.Now().AddDate(0, -1, 0)
                if err := db.Model(&amp;domain.Review{}).
                        Where("created_at &gt;= ?", monthAgo).
                        Count(&amp;metrics.ReviewsThisMonth).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get average rating
                <span class="cov0" title="0">if err := db.Model(&amp;domain.Review{}).
                        Select("AVG(rating)").
                        Scan(&amp;metrics.AverageRating).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metrics.LastUpdated = time.Now()
        return &amp;metrics, nil</span>
}

// RepositoryMetrics represents repository performance metrics
type RepositoryMetrics struct {
        TotalReviews     int64     `json:"total_reviews"`
        ReviewsToday     int64     `json:"reviews_today"`
        ReviewsThisWeek  int64     `json:"reviews_this_week"`
        ReviewsThisMonth int64     `json:"reviews_this_month"`
        AverageRating    float64   `json:"average_rating"`
        LastUpdated      time.Time `json:"last_updated"`
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package infrastructure

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "golang.org/x/time/rate"
)

// RateLimiter provides rate limiting functionality
type RateLimiter struct {
        localLimiter *rate.Limiter
        redisClient  *redis.Client
        maxRequests  int
        window       time.Duration
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(maxRequests int, window time.Duration, redisClient *redis.Client) *RateLimiter <span class="cov7" title="20">{
        // Create local rate limiter as fallback
        localLimiter := rate.NewLimiter(rate.Limit(float64(maxRequests)/window.Seconds()), maxRequests)

        return &amp;RateLimiter{
                localLimiter: localLimiter,
                redisClient:  redisClient,
                maxRequests:  maxRequests,
                window:       window,
        }
}</span>

// Allow checks if a request is allowed for the given key
func (r *RateLimiter) Allow(ctx context.Context, key string) (bool, error) <span class="cov10" title="58">{
        // If Redis is not available, use local limiter
        if r.redisClient == nil </span><span class="cov5" title="7">{
                return r.localLimiter.Allow(), nil
        }</span>

        // Use Redis for distributed rate limiting
        <span class="cov9" title="51">redisKey := fmt.Sprintf("rate_limit:%s", key)

        // Get current count
        count, err := r.redisClient.Get(ctx, redisKey).Int()
        if err == redis.Nil </span><span class="cov6" title="14">{
                // Key doesn't exist, create it
                pipe := r.redisClient.Pipeline()
                pipe.Incr(ctx, redisKey)
                pipe.Expire(ctx, redisKey, r.window)
                _, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to local limiter
                        return r.localLimiter.Allow(), nil
                }</span>
                <span class="cov6" title="14">return true, nil</span>
        } else<span class="cov9" title="37"> if err != nil </span><span class="cov2" title="2">{
                // Error occurred, fallback to local limiter
                return r.localLimiter.Allow(), nil
        }</span>

        // Check if limit exceeded
        <span class="cov8" title="35">if count &gt;= r.maxRequests </span><span class="cov7" title="18">{
                return false, nil
        }</span>

        // Increment counter
        <span class="cov7" title="17">_, err = r.redisClient.Incr(ctx, redisKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to local limiter
                return r.localLimiter.Allow(), nil
        }</span>

        <span class="cov7" title="17">return true, nil</span>
}

// Reset resets the rate limit for a key
func (r *RateLimiter) Reset(ctx context.Context, key string) error <span class="cov3" title="3">{
        if r.redisClient == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="2">redisKey := fmt.Sprintf("rate_limit:%s", key)
        return r.redisClient.Del(ctx, redisKey).Err()</span>
}

// GetLimit returns the current limit and remaining requests for a key
func (r *RateLimiter) GetLimit(ctx context.Context, key string) (limit, remaining int, resetAt time.Time, err error) <span class="cov4" title="6">{
        limit = r.maxRequests

        if r.redisClient == nil </span><span class="cov1" title="1">{
                // For local limiter, we can't get exact remaining
                if r.localLimiter.Allow() </span><span class="cov1" title="1">{
                        remaining = 1
                }</span> else<span class="cov0" title="0"> {
                        remaining = 0
                }</span>
                <span class="cov1" title="1">resetAt = time.Now().Add(r.window)
                return</span>
        }

        <span class="cov4" title="5">redisKey := fmt.Sprintf("rate_limit:%s", key)

        // Get current count
        count, err := r.redisClient.Get(ctx, redisKey).Int()
        if err == redis.Nil </span><span class="cov1" title="1">{
                remaining = limit
                resetAt = time.Now().Add(r.window)
                return limit, remaining, resetAt, nil
        }</span> else<span class="cov4" title="4"> if err != nil </span><span class="cov2" title="2">{
                return 0, 0, time.Time{}, err
        }</span>

        <span class="cov2" title="2">remaining = limit - count
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        // Get TTL for reset time
        <span class="cov2" title="2">ttl, err := r.redisClient.TTL(ctx, redisKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, time.Time{}, err
        }</span>

        <span class="cov2" title="2">resetAt = time.Now().Add(ttl)
        return limit, remaining, resetAt, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package infrastructure

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/go-redis/redis/v8"
        "github.com/google/uuid"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Host               string        `mapstructure:"host" json:"host"`
        Port               int           `mapstructure:"port" json:"port"`
        Password           string        `mapstructure:"password" json:"password"`
        Database           int           `mapstructure:"database" json:"database"`
        PoolSize           int           `mapstructure:"pool_size" json:"pool_size"`
        MinIdleConns       int           `mapstructure:"min_idle_conns" json:"min_idle_conns"`
        MaxConnAge         time.Duration `mapstructure:"max_conn_age" json:"max_conn_age"`
        PoolTimeout        time.Duration `mapstructure:"pool_timeout" json:"pool_timeout"`
        IdleTimeout        time.Duration `mapstructure:"idle_timeout" json:"idle_timeout"`
        IdleCheckFrequency time.Duration `mapstructure:"idle_check_frequency" json:"idle_check_frequency"`
        ReadTimeout        time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
        WriteTimeout       time.Duration `mapstructure:"write_timeout" json:"write_timeout"`
        DialTimeout        time.Duration `mapstructure:"dial_timeout" json:"dial_timeout"`
        MaxRetries         int           `mapstructure:"max_retries" json:"max_retries"`
        MinRetryBackoff    time.Duration `mapstructure:"min_retry_backoff" json:"min_retry_backoff"`
        MaxRetryBackoff    time.Duration `mapstructure:"max_retry_backoff" json:"max_retry_backoff"`
        EnableMetrics      bool          `mapstructure:"enable_metrics" json:"enable_metrics"`
        KeyPrefix          string        `mapstructure:"key_prefix" json:"key_prefix"`
}

// CacheConfig holds cache-specific configuration
type CacheConfig struct {
        ReviewTTL         time.Duration `mapstructure:"review_ttl" json:"review_ttl"`
        HotelTTL          time.Duration `mapstructure:"hotel_ttl" json:"hotel_ttl"`
        ProviderTTL       time.Duration `mapstructure:"provider_ttl" json:"provider_ttl"`
        StatisticsTTL     time.Duration `mapstructure:"statistics_ttl" json:"statistics_ttl"`
        SearchTTL         time.Duration `mapstructure:"search_ttl" json:"search_ttl"`
        ProcessingTTL     time.Duration `mapstructure:"processing_ttl" json:"processing_ttl"`
        AnalyticsTTL      time.Duration `mapstructure:"analytics_ttl" json:"analytics_ttl"`
        DefaultTTL        time.Duration `mapstructure:"default_ttl" json:"default_ttl"`
        MaxKeyLength      int           `mapstructure:"max_key_length" json:"max_key_length"`
        EnableCompression bool          `mapstructure:"enable_compression" json:"enable_compression"`
        CompressionLevel  int           `mapstructure:"compression_level" json:"compression_level"`
        PrefixSeparator   string        `mapstructure:"prefix_separator" json:"prefix_separator"`
        InvalidationBatch int           `mapstructure:"invalidation_batch" json:"invalidation_batch"`
        WarmupConcurrency int           `mapstructure:"warmup_concurrency" json:"warmup_concurrency"`
}

// CacheOperation represents different cache operations
type CacheOperation string

const (
        CacheOperationGet     CacheOperation = "get"
        CacheOperationSet     CacheOperation = "set"
        CacheOperationDelete  CacheOperation = "delete"
        CacheOperationExists  CacheOperation = "exists"
        CacheOperationExpire  CacheOperation = "expire"
        CacheOperationHGet    CacheOperation = "hget"
        CacheOperationHSet    CacheOperation = "hset"
        CacheOperationHDel    CacheOperation = "hdel"
        CacheOperationHKeys   CacheOperation = "hkeys"
        CacheOperationHVals   CacheOperation = "hvals"
        CacheOperationHGetAll CacheOperation = "hgetall"
)

// CacheMetrics holds cache operation metrics
type CacheMetrics struct {
        TotalHits           int64                    `json:"total_hits"`
        TotalMisses         int64                    `json:"total_misses"`
        TotalSets           int64                    `json:"total_sets"`
        TotalDeletes        int64                    `json:"total_deletes"`
        TotalErrors         int64                    `json:"total_errors"`
        HitRate             float64                  `json:"hit_rate"`
        AverageLatency      time.Duration            `json:"average_latency"`
        OperationCounts     map[CacheOperation]int64 `json:"operation_counts"`
        KeyspaceCounts      map[string]int64         `json:"keyspace_counts"`
        LastUpdated         time.Time                `json:"last_updated"`
        ConnectionPoolStats redis.PoolStats          `json:"connection_pool_stats"`
}

// RedisClient wraps Redis client with additional functionality
type RedisClient struct {
        client        redis.UniversalClient
        config        *RedisConfig
        cacheConfig   *CacheConfig
        logger        *logger.Logger
        metrics       *CacheMetrics
        mu            sync.RWMutex
        invalidations chan InvalidationRequest
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
}

// InvalidationRequest represents a cache invalidation request
type InvalidationRequest struct {
        Pattern   string
        Keys      []string
        Immediate bool
        Callback  func(int, error)
}

// NewRedisClient creates a new Redis client with connection pooling
func NewRedisClient(redisConfig *RedisConfig, cacheConfig *CacheConfig, logger *logger.Logger) (*RedisClient, error) <span class="cov0" title="0">{
        // Create Redis client options
        opts := &amp;redis.Options{
                Addr:               fmt.Sprintf("%s:%d", redisConfig.Host, redisConfig.Port),
                Password:           redisConfig.Password,
                DB:                 redisConfig.Database,
                PoolSize:           redisConfig.PoolSize,
                MinIdleConns:       redisConfig.MinIdleConns,
                MaxConnAge:         redisConfig.MaxConnAge,
                PoolTimeout:        redisConfig.PoolTimeout,
                IdleTimeout:        redisConfig.IdleTimeout,
                IdleCheckFrequency: redisConfig.IdleCheckFrequency,
                ReadTimeout:        redisConfig.ReadTimeout,
                WriteTimeout:       redisConfig.WriteTimeout,
                DialTimeout:        redisConfig.DialTimeout,
                MaxRetries:         redisConfig.MaxRetries,
                MinRetryBackoff:    redisConfig.MinRetryBackoff,
                MaxRetryBackoff:    redisConfig.MaxRetryBackoff,
        }

        // Create Redis client
        client := redis.NewClient(opts)

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        // Create context for background operations
        <span class="cov0" title="0">bgCtx, bgCancel := context.WithCancel(context.Background())

        redisClient := &amp;RedisClient{
                client:      client,
                config:      redisConfig,
                cacheConfig: cacheConfig,
                logger:      logger,
                metrics: &amp;CacheMetrics{
                        OperationCounts: make(map[CacheOperation]int64),
                        KeyspaceCounts:  make(map[string]int64),
                },
                invalidations: make(chan InvalidationRequest, 1000),
                ctx:           bgCtx,
                cancel:        bgCancel,
        }

        // Start background processes
        redisClient.wg.Add(1)
        go redisClient.invalidationWorker()

        if redisConfig.EnableMetrics </span><span class="cov0" title="0">{
                redisClient.wg.Add(1)
                go redisClient.metricsCollector()
        }</span>

        <span class="cov0" title="0">logger.Info("Redis client initialized successfully",
                "host", redisConfig.Host,
                "port", redisConfig.Port,
                "database", redisConfig.Database,
                "pool_size", redisConfig.PoolSize,
        )

        return redisClient, nil</span>
}

// Close closes the Redis client and background processes
func (r *RedisClient) Close() error <span class="cov0" title="0">{
        r.logger.Info("Closing Redis client...")

        // Cancel background processes
        r.cancel()

        // Wait for background processes to finish
        r.wg.Wait()

        // Close Redis client
        if err := r.client.Close(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error closing Redis client", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Info("Redis client closed successfully")
        return nil</span>
}

// buildKey builds a cache key with prefix and namespace
func (r *RedisClient) buildKey(keyspace, key string) string <span class="cov1" title="2">{
        if r.config.KeyPrefix != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s:%s:%s", r.config.KeyPrefix, keyspace, key)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s:%s", keyspace, key)</span>
}

// hashKey creates a hash of the key if it exceeds max length
func (r *RedisClient) hashKey(key string) string <span class="cov1" title="2">{
        if len(key) &lt;= r.cacheConfig.MaxKeyLength </span><span class="cov1" title="1">{
                return key
        }</span>

        <span class="cov1" title="1">hash := sha256.Sum256([]byte(key))
        return hex.EncodeToString(hash[:])</span>
}

// recordMetric records a cache operation metric
func (r *RedisClient) recordMetric(operation CacheOperation, keyspace string, hit bool, latency time.Duration) <span class="cov10" title="1007">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.metrics.OperationCounts[operation]++
        r.metrics.KeyspaceCounts[keyspace]++

        if operation == CacheOperationGet </span><span class="cov9" title="1004">{
                if hit </span><span class="cov9" title="503">{
                        r.metrics.TotalHits++
                }</span> else<span class="cov9" title="501"> {
                        r.metrics.TotalMisses++
                }</span>
        } else<span class="cov2" title="3"> if operation == CacheOperationSet </span><span class="cov1" title="2">{
                r.metrics.TotalSets++
        }</span> else<span class="cov1" title="1"> if operation == CacheOperationDelete </span><span class="cov1" title="1">{
                r.metrics.TotalDeletes++
        }</span>

        // Update hit rate
        <span class="cov10" title="1007">total := r.metrics.TotalHits + r.metrics.TotalMisses
        if total &gt; 0 </span><span class="cov10" title="1007">{
                r.metrics.HitRate = float64(r.metrics.TotalHits) / float64(total) * 100
        }</span>

        // Update average latency (simple moving average)
        <span class="cov10" title="1007">if r.metrics.AverageLatency == 0 </span><span class="cov2" title="3">{
                r.metrics.AverageLatency = latency
        }</span> else<span class="cov9" title="1004"> {
                r.metrics.AverageLatency = (r.metrics.AverageLatency + latency) / 2
        }</span>

        <span class="cov10" title="1007">r.metrics.LastUpdated = time.Now()</span>
}

// recordError records a cache operation error
func (r *RedisClient) recordError(operation CacheOperation, keyspace string, err error) <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.metrics.TotalErrors++
        r.logger.Error("Cache operation failed",
                "operation", operation,
                "keyspace", keyspace,
                "error", err,
        )
}</span>

// String Cache Operations

// Get retrieves a value from cache
func (r *RedisClient) Get(ctx context.Context, keyspace, key string) (string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        val, err := r.client.Get(ctx, cacheKey).Result()
        latency := time.Since(startTime)

        if err == redis.Nil </span><span class="cov0" title="0">{
                r.recordMetric(CacheOperationGet, keyspace, false, latency)
                return "", nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationGet, keyspace, err)
                return "", err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationGet, keyspace, true, latency)
        return val, nil</span>
}

// Set stores a value in cache with TTL
func (r *RedisClient) Set(ctx context.Context, keyspace, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = r.cacheConfig.DefaultTTL
        }</span>

        <span class="cov0" title="0">err := r.client.Set(ctx, cacheKey, value, ttl).Err()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationSet, keyspace, err)
                return err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationSet, keyspace, false, latency)
        return nil</span>
}

// Delete removes a key from cache
func (r *RedisClient) Delete(ctx context.Context, keyspace, key string) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        err := r.client.Del(ctx, cacheKey).Err()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationDelete, keyspace, err)
                return err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationDelete, keyspace, false, latency)
        return nil</span>
}

// Exists checks if a key exists in cache
func (r *RedisClient) Exists(ctx context.Context, keyspace, key string) (bool, error) <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        count, err := r.client.Exists(ctx, cacheKey).Result()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationExists, keyspace, err)
                return false, err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationExists, keyspace, count &gt; 0, latency)
        return count &gt; 0, nil</span>
}

// Expire sets a TTL on a key
func (r *RedisClient) Expire(ctx context.Context, keyspace, key string, ttl time.Duration) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        err := r.client.Expire(ctx, cacheKey, ttl).Err()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationExpire, keyspace, err)
                return err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationExpire, keyspace, false, latency)
        return nil</span>
}

// Hash Cache Operations

// HGet retrieves a field from a hash
func (r *RedisClient) HGet(ctx context.Context, keyspace, key, field string) (string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        val, err := r.client.HGet(ctx, cacheKey, field).Result()
        latency := time.Since(startTime)

        if err == redis.Nil </span><span class="cov0" title="0">{
                r.recordMetric(CacheOperationHGet, keyspace, false, latency)
                return "", nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHGet, keyspace, err)
                return "", err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationHGet, keyspace, true, latency)
        return val, nil</span>
}

// HSet sets a field in a hash
func (r *RedisClient) HSet(ctx context.Context, keyspace, key, field, value string, ttl time.Duration) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        err := r.client.HSet(ctx, cacheKey, field, value).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHSet, keyspace, err)
                return err
        }</span>

        // Set TTL if specified
        <span class="cov0" title="0">if ttl &gt; 0 </span><span class="cov0" title="0">{
                err = r.client.Expire(ctx, cacheKey, ttl).Err()
                if err != nil </span><span class="cov0" title="0">{
                        r.recordError(CacheOperationHSet, keyspace, err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">latency := time.Since(startTime)
        r.recordMetric(CacheOperationHSet, keyspace, false, latency)
        return nil</span>
}

// HGetAll retrieves all fields from a hash
func (r *RedisClient) HGetAll(ctx context.Context, keyspace, key string) (map[string]string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        vals, err := r.client.HGetAll(ctx, cacheKey).Result()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHGetAll, keyspace, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationHGetAll, keyspace, len(vals) &gt; 0, latency)
        return vals, nil</span>
}

// HSetMap sets multiple fields in a hash
func (r *RedisClient) HSetMap(ctx context.Context, keyspace, key string, fields map[string]string, ttl time.Duration) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        err := r.client.HMSet(ctx, cacheKey, fields).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHSet, keyspace, err)
                return err
        }</span>

        // Set TTL if specified
        <span class="cov0" title="0">if ttl &gt; 0 </span><span class="cov0" title="0">{
                err = r.client.Expire(ctx, cacheKey, ttl).Err()
                if err != nil </span><span class="cov0" title="0">{
                        r.recordError(CacheOperationHSet, keyspace, err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">latency := time.Since(startTime)
        r.recordMetric(CacheOperationHSet, keyspace, false, latency)
        return nil</span>
}

// HDel removes fields from a hash
func (r *RedisClient) HDel(ctx context.Context, keyspace, key string, fields ...string) error <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        err := r.client.HDel(ctx, cacheKey, fields...).Err()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHDel, keyspace, err)
                return err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationHDel, keyspace, false, latency)
        return nil</span>
}

// HKeys retrieves all field names from a hash
func (r *RedisClient) HKeys(ctx context.Context, keyspace, key string) ([]string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        cacheKey := r.buildKey(keyspace, r.hashKey(key))

        keys, err := r.client.HKeys(ctx, cacheKey).Result()
        latency := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                r.recordError(CacheOperationHKeys, keyspace, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">r.recordMetric(CacheOperationHKeys, keyspace, len(keys) &gt; 0, latency)
        return keys, nil</span>
}

// Cache-Aside Pattern Implementations

// ReviewCache implements cache-aside pattern for review data
type ReviewCache struct {
        client        *RedisClient
        reviewService domain.ReviewService
        logger        *logger.Logger
}

// NewReviewCache creates a new review cache
func NewReviewCache(client *RedisClient, reviewService domain.ReviewService, logger *logger.Logger) *ReviewCache <span class="cov1" title="1">{
        return &amp;ReviewCache{
                client:        client,
                reviewService: reviewService,
                logger:        logger,
        }
}</span>

// GetReview retrieves a review using cache-aside pattern
func (c *ReviewCache) GetReview(ctx context.Context, reviewID uuid.UUID) (*domain.Review, error) <span class="cov0" title="0">{
        key := reviewID.String()
        keyspace := "reviews"

        // Try to get from cache first
        cached, err := c.client.Get(ctx, keyspace, key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get review from cache", "review_id", reviewID, "error", err)
                // Fall through to database
        }</span>

        <span class="cov0" title="0">if cached != "" </span><span class="cov0" title="0">{
                var review domain.Review
                if err := json.Unmarshal([]byte(cached), &amp;review); err == nil </span><span class="cov0" title="0">{
                        return &amp;review, nil
                }</span>
                <span class="cov0" title="0">c.logger.Error("Failed to unmarshal cached review", "review_id", reviewID, "error", err)</span>
        }

        // Get from database
        <span class="cov0" title="0">review, err := c.reviewService.GetReviewByID(ctx, reviewID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache the result
        <span class="cov0" title="0">if reviewData, err := json.Marshal(review); err == nil </span><span class="cov0" title="0">{
                if err := c.client.Set(ctx, keyspace, key, string(reviewData), c.client.cacheConfig.ReviewTTL); err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to cache review", "review_id", reviewID, "error", err)
                }</span>
        }

        <span class="cov0" title="0">return review, nil</span>
}

// GetReviewsByHotel retrieves reviews for a hotel using cache-aside pattern
func (c *ReviewCache) GetReviewsByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]*domain.Review, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("hotel:%s:reviews:%d:%d", hotelID.String(), limit, offset)
        keyspace := "hotel_reviews"

        // Try to get from cache first
        cached, err := c.client.Get(ctx, keyspace, key)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get hotel reviews from cache", "hotel_id", hotelID, "error", err)
                // Fall through to database
        }</span>

        <span class="cov0" title="0">if cached != "" </span><span class="cov0" title="0">{
                var reviews []*domain.Review
                if err := json.Unmarshal([]byte(cached), &amp;reviews); err == nil </span><span class="cov0" title="0">{
                        return reviews, nil
                }</span>
                <span class="cov0" title="0">c.logger.Error("Failed to unmarshal cached hotel reviews", "hotel_id", hotelID, "error", err)</span>
        }

        // Get from database
        <span class="cov0" title="0">reviews, err := c.reviewService.GetReviewsByHotel(ctx, hotelID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache the result
        <span class="cov0" title="0">if reviewsData, err := json.Marshal(reviews); err == nil </span><span class="cov0" title="0">{
                if err := c.client.Set(ctx, keyspace, key, string(reviewsData), c.client.cacheConfig.ReviewTTL); err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to cache hotel reviews", "hotel_id", hotelID, "error", err)
                }</span>
        }

        // Convert []domain.Review to []*domain.Review
        <span class="cov0" title="0">reviewPtrs := make([]*domain.Review, len(reviews))
        for i := range reviews </span><span class="cov0" title="0">{
                reviewPtrs[i] = &amp;reviews[i]
        }</span>

        <span class="cov0" title="0">return reviewPtrs, nil</span>
}

// InvalidateReview removes a review from cache
func (c *ReviewCache) InvalidateReview(ctx context.Context, reviewID uuid.UUID) error <span class="cov0" title="0">{
        key := reviewID.String()
        keyspace := "reviews"

        return c.client.Delete(ctx, keyspace, key)
}</span>

// InvalidateHotelReviews removes all cached reviews for a hotel
func (c *ReviewCache) InvalidateHotelReviews(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        pattern := fmt.Sprintf("hotel:%s:reviews:*", hotelID.String())

        req := InvalidationRequest{
                Pattern:   pattern,
                Immediate: false,
                Callback: func(count int, err error) </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Failed to invalidate hotel reviews", "hotel_id", hotelID, "error", err)
                        }</span> else<span class="cov0" title="0"> {
                                c.logger.Info("Invalidated hotel reviews", "hotel_id", hotelID, "count", count)
                        }</span>
                },
        }

        <span class="cov0" title="0">select </span>{
        case c.client.invalidations &lt;- req:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalidation queue full")</span>
        }
}

// HotelCache implements cache-aside pattern for hotel data
type HotelCache struct {
        client *RedisClient
        logger *logger.Logger
}

// NewHotelCache creates a new hotel cache
func NewHotelCache(client *RedisClient, logger *logger.Logger) *HotelCache <span class="cov1" title="1">{
        return &amp;HotelCache{
                client: client,
                logger: logger,
        }
}</span>

// GetHotel retrieves a hotel using cache-aside pattern
func (c *HotelCache) GetHotel(ctx context.Context, hotelID uuid.UUID) (map[string]string, error) <span class="cov0" title="0">{
        key := hotelID.String()
        keyspace := "hotels"

        return c.client.HGetAll(ctx, keyspace, key)
}</span>

// SetHotel stores hotel data in cache
func (c *HotelCache) SetHotel(ctx context.Context, hotelID uuid.UUID, hotel map[string]string) error <span class="cov0" title="0">{
        key := hotelID.String()
        keyspace := "hotels"

        return c.client.HSetMap(ctx, keyspace, key, hotel, c.client.cacheConfig.HotelTTL)
}</span>

// UpdateHotelField updates a specific field in hotel cache
func (c *HotelCache) UpdateHotelField(ctx context.Context, hotelID uuid.UUID, field, value string) error <span class="cov0" title="0">{
        key := hotelID.String()
        keyspace := "hotels"

        return c.client.HSet(ctx, keyspace, key, field, value, c.client.cacheConfig.HotelTTL)
}</span>

// GetHotelField retrieves a specific field from hotel cache
func (c *HotelCache) GetHotelField(ctx context.Context, hotelID uuid.UUID, field string) (string, error) <span class="cov0" title="0">{
        key := hotelID.String()
        keyspace := "hotels"

        return c.client.HGet(ctx, keyspace, key, field)
}</span>

// InvalidateHotel removes a hotel from cache
func (c *HotelCache) InvalidateHotel(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        key := hotelID.String()
        keyspace := "hotels"

        return c.client.Delete(ctx, keyspace, key)
}</span>

// ProcessingStatusCache implements cache for processing status
type ProcessingStatusCache struct {
        client *RedisClient
        logger *logger.Logger
}

// NewProcessingStatusCache creates a new processing status cache
func NewProcessingStatusCache(client *RedisClient, logger *logger.Logger) *ProcessingStatusCache <span class="cov1" title="1">{
        return &amp;ProcessingStatusCache{
                client: client,
                logger: logger,
        }
}</span>

// GetProcessingStatus retrieves processing status
func (c *ProcessingStatusCache) GetProcessingStatus(ctx context.Context, jobID uuid.UUID) (map[string]string, error) <span class="cov0" title="0">{
        key := jobID.String()
        keyspace := "processing_status"

        return c.client.HGetAll(ctx, keyspace, key)
}</span>

// SetProcessingStatus stores processing status
func (c *ProcessingStatusCache) SetProcessingStatus(ctx context.Context, jobID uuid.UUID, status map[string]string) error <span class="cov0" title="0">{
        key := jobID.String()
        keyspace := "processing_status"

        return c.client.HSetMap(ctx, keyspace, key, status, c.client.cacheConfig.ProcessingTTL)
}</span>

// UpdateProcessingProgress updates processing progress
func (c *ProcessingStatusCache) UpdateProcessingProgress(ctx context.Context, jobID uuid.UUID, progress float64) error <span class="cov0" title="0">{
        key := jobID.String()
        keyspace := "processing_status"

        return c.client.HSet(ctx, keyspace, key, "progress", fmt.Sprintf("%.2f", progress), c.client.cacheConfig.ProcessingTTL)
}</span>

// UpdateProcessingStatus updates processing status
func (c *ProcessingStatusCache) UpdateProcessingStatus(ctx context.Context, jobID uuid.UUID, status string) error <span class="cov0" title="0">{
        key := jobID.String()
        keyspace := "processing_status"

        return c.client.HSet(ctx, keyspace, key, "status", status, c.client.cacheConfig.ProcessingTTL)
}</span>

// InvalidateProcessingStatus removes processing status from cache
func (c *ProcessingStatusCache) InvalidateProcessingStatus(ctx context.Context, jobID uuid.UUID) error <span class="cov0" title="0">{
        key := jobID.String()
        keyspace := "processing_status"

        return c.client.Delete(ctx, keyspace, key)
}</span>

// Cache Invalidation Worker

// invalidationWorker processes cache invalidation requests
func (r *RedisClient) invalidationWorker() <span class="cov0" title="0">{
        defer r.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-r.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case req := &lt;-r.invalidations:<span class="cov0" title="0">
                        r.processInvalidationRequest(req)</span>
                }
        }
}

// processInvalidationRequest processes a single invalidation request
func (r *RedisClient) processInvalidationRequest(req InvalidationRequest) <span class="cov0" title="0">{
        if req.Pattern != "" </span><span class="cov0" title="0">{
                // Pattern-based invalidation
                count, err := r.invalidateByPattern(req.Pattern)
                if req.Callback != nil </span><span class="cov0" title="0">{
                        req.Callback(count, err)
                }</span>
        } else<span class="cov0" title="0"> if len(req.Keys) &gt; 0 </span><span class="cov0" title="0">{
                // Key-based invalidation
                count, err := r.invalidateByKeys(req.Keys)
                if req.Callback != nil </span><span class="cov0" title="0">{
                        req.Callback(count, err)
                }</span>
        }
}

// invalidateByPattern invalidates keys matching a pattern
func (r *RedisClient) invalidateByPattern(pattern string) (int, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Get all keys matching the pattern
        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(keys) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Delete keys in batches
        <span class="cov0" title="0">batchSize := r.cacheConfig.InvalidationBatch
        if batchSize == 0 </span><span class="cov0" title="0">{
                batchSize = 100
        }</span>

        <span class="cov0" title="0">totalDeleted := 0
        for i := 0; i &lt; len(keys); i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; len(keys) </span><span class="cov0" title="0">{
                        end = len(keys)
                }</span>

                <span class="cov0" title="0">batch := keys[i:end]
                deleted, err := r.client.Del(ctx, batch...).Result()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to delete batch of keys", "error", err, "batch_size", len(batch))
                        continue</span>
                }

                <span class="cov0" title="0">totalDeleted += int(deleted)</span>
        }

        <span class="cov0" title="0">return totalDeleted, nil</span>
}

// invalidateByKeys invalidates specific keys
func (r *RedisClient) invalidateByKeys(keys []string) (int, error) <span class="cov0" title="0">{
        ctx := context.Background()

        deleted, err := r.client.Del(ctx, keys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(deleted), nil</span>
}

// Metrics Collection

// metricsCollector collects cache metrics periodically
func (r *RedisClient) metricsCollector() <span class="cov0" title="0">{
        defer r.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-r.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        r.collectMetrics()</span>
                }
        }
}

// collectMetrics collects and logs cache metrics
func (r *RedisClient) collectMetrics() <span class="cov0" title="0">{
        // Get connection pool stats
        poolStats := r.client.PoolStats()

        r.mu.Lock()
        r.metrics.ConnectionPoolStats = *poolStats
        r.mu.Unlock()

        r.logger.Info("Cache metrics",
                "total_hits", r.metrics.TotalHits,
                "total_misses", r.metrics.TotalMisses,
                "hit_rate", fmt.Sprintf("%.2f%%", r.metrics.HitRate),
                "total_sets", r.metrics.TotalSets,
                "total_deletes", r.metrics.TotalDeletes,
                "total_errors", r.metrics.TotalErrors,
                "average_latency", r.metrics.AverageLatency,
                "pool_hits", poolStats.Hits,
                "pool_misses", poolStats.Misses,
                "pool_timeouts", poolStats.Timeouts,
                "pool_total_conns", poolStats.TotalConns,
                "pool_idle_conns", poolStats.IdleConns,
                "pool_stale_conns", poolStats.StaleConns,
        )
}</span>

// GetMetrics returns current cache metrics
func (r *RedisClient) GetMetrics() *CacheMetrics <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := &amp;CacheMetrics{
                TotalHits:           r.metrics.TotalHits,
                TotalMisses:         r.metrics.TotalMisses,
                TotalSets:           r.metrics.TotalSets,
                TotalDeletes:        r.metrics.TotalDeletes,
                TotalErrors:         r.metrics.TotalErrors,
                HitRate:             r.metrics.HitRate,
                AverageLatency:      r.metrics.AverageLatency,
                OperationCounts:     make(map[CacheOperation]int64),
                KeyspaceCounts:      make(map[string]int64),
                LastUpdated:         r.metrics.LastUpdated,
                ConnectionPoolStats: r.metrics.ConnectionPoolStats,
        }

        // Copy maps
        for k, v := range r.metrics.OperationCounts </span><span class="cov1" title="2">{
                metrics.OperationCounts[k] = v
        }</span>
        <span class="cov1" title="1">for k, v := range r.metrics.KeyspaceCounts </span><span class="cov1" title="2">{
                metrics.KeyspaceCounts[k] = v
        }</span>

        <span class="cov1" title="1">return metrics</span>
}

// Cache Warming

// WarmupCache warms up the cache with frequently accessed data
func (r *RedisClient) WarmupCache(ctx context.Context, warmupData map[string]interface{}) error <span class="cov0" title="0">{
        r.logger.Info("Starting cache warmup", "data_sets", len(warmupData))

        // Use semaphore to limit concurrent operations
        sem := make(chan struct{}, r.cacheConfig.WarmupConcurrency)
        var wg sync.WaitGroup
        var mu sync.Mutex
        var errors []error

        for keyspace, data := range warmupData </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(ks string, d interface{}) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore
                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-sem }</span>()

                        <span class="cov0" title="0">if err := r.warmupKeyspace(ctx, ks, d); err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                errors = append(errors, fmt.Errorf("warmup failed for keyspace %s: %w", ks, err))
                                mu.Unlock()
                        }</span>
                }(keyspace, data)
        }

        <span class="cov0" title="0">wg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                r.logger.Error("Cache warmup completed with errors", "errors", errors)
                return fmt.Errorf("cache warmup failed: %v", errors)
        }</span>

        <span class="cov0" title="0">r.logger.Info("Cache warmup completed successfully")
        return nil</span>
}

// warmupKeyspace warms up a specific keyspace
func (r *RedisClient) warmupKeyspace(ctx context.Context, keyspace string, data interface{}) error <span class="cov0" title="0">{
        switch keyspace </span>{
        case "hotels":<span class="cov0" title="0">
                return r.warmupHotels(ctx, data)</span>
        case "reviews":<span class="cov0" title="0">
                return r.warmupReviews(ctx, data)</span>
        case "processing_status":<span class="cov0" title="0">
                return r.warmupProcessingStatus(ctx, data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown keyspace: %s", keyspace)</span>
        }
}

// warmupHotels warms up hotel data
func (r *RedisClient) warmupHotels(ctx context.Context, data interface{}) error <span class="cov0" title="0">{
        hotels, ok := data.(map[string]map[string]string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid hotel data format")
        }</span>

        <span class="cov0" title="0">for hotelID, hotelData := range hotels </span><span class="cov0" title="0">{
                if err := r.HSetMap(ctx, "hotels", hotelID, hotelData, r.cacheConfig.HotelTTL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// warmupReviews warms up review data
func (r *RedisClient) warmupReviews(ctx context.Context, data interface{}) error <span class="cov0" title="0">{
        reviews, ok := data.(map[string]string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid review data format")
        }</span>

        <span class="cov0" title="0">for reviewID, reviewData := range reviews </span><span class="cov0" title="0">{
                if err := r.Set(ctx, "reviews", reviewID, reviewData, r.cacheConfig.ReviewTTL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// warmupProcessingStatus warms up processing status data
func (r *RedisClient) warmupProcessingStatus(ctx context.Context, data interface{}) error <span class="cov0" title="0">{
        statuses, ok := data.(map[string]map[string]string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid processing status data format")
        }</span>

        <span class="cov0" title="0">for jobID, statusData := range statuses </span><span class="cov0" title="0">{
                if err := r.HSetMap(ctx, "processing_status", jobID, statusData, r.cacheConfig.ProcessingTTL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Health Check

// HealthCheck performs a health check on the Redis connection
func (r *RedisClient) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Test basic connectivity
        if err := r.client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis ping failed: %w", err)
        }</span>

        // Test basic operations
        <span class="cov0" title="0">testKey := "health_check"
        testValue := "ok"

        if err := r.Set(ctx, "health", testKey, testValue, time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis set operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if value, err := r.Get(ctx, "health", testKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis get operation failed: %w", err)
        }</span> else<span class="cov0" title="0"> if value != testValue </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis value mismatch: expected %s, got %s", testValue, value)
        }</span>

        <span class="cov0" title="0">if err := r.Delete(ctx, "health", testKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis delete operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConnectionStats returns connection pool statistics
func (r *RedisClient) GetConnectionStats() *redis.PoolStats <span class="cov0" title="0">{
        return r.client.PoolStats()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package infrastructure

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// RedisCacheService implements domain.CacheService using Redis
type RedisCacheService struct {
        client *redis.Client
        logger *logger.Logger
        ttl    time.Duration
}

// NewRedisCacheService creates a new Redis cache service
func NewRedisCacheService(client *redis.Client, logger *logger.Logger) *RedisCacheService <span class="cov10" title="4">{
        return &amp;RedisCacheService{
                client: client,
                logger: logger,
                ttl:    5 * time.Minute, // Default TTL
        }
}</span>

// Get retrieves a value from cache
func (r *RedisCacheService) Get(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        val, err := r.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get from cache: %w", err)
        }</span>
        <span class="cov0" title="0">return []byte(val), nil</span>
}

// Set stores a value in cache
func (r *RedisCacheService) Set(ctx context.Context, key string, value []byte, expiration time.Duration) error <span class="cov0" title="0">{
        if expiration == 0 </span><span class="cov0" title="0">{
                expiration = r.ttl
        }</span>

        <span class="cov0" title="0">err := r.client.Set(ctx, key, value, expiration).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set cache: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete removes a key from cache
func (r *RedisCacheService) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete from cache: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in cache
func (r *RedisCacheService) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        n, err := r.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check cache existence: %w", err)
        }</span>
        <span class="cov0" title="0">return n &gt; 0, nil</span>
}

// FlushAll clears all cache
func (r *RedisCacheService) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        err := r.client.FlushAll(ctx).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush cache: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetReviewSummary retrieves a review summary from cache
func (r *RedisCacheService) GetReviewSummary(ctx context.Context, hotelID uuid.UUID) (*domain.ReviewSummary, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("hotel:summary:%s", hotelID.String())

        data, err := r.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                return nil, nil // Cache miss
        }</span>

        <span class="cov0" title="0">var summary domain.ReviewSummary
        if err := json.Unmarshal(data, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal review summary: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;summary, nil</span>
}

// SetReviewSummary stores a review summary in cache
func (r *RedisCacheService) SetReviewSummary(ctx context.Context, hotelID uuid.UUID, summary *domain.ReviewSummary, expiration time.Duration) error <span class="cov0" title="0">{
        key := fmt.Sprintf("hotel:summary:%s", hotelID.String())

        data, err := json.Marshal(summary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal review summary: %w", err)
        }</span>

        <span class="cov0" title="0">return r.Set(ctx, key, data, expiration)</span>
}

// InvalidateReviewSummary removes a review summary from cache
func (r *RedisCacheService) InvalidateReviewSummary(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        key := fmt.Sprintf("hotel:summary:%s", hotelID.String())
        return r.Delete(ctx, key)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package infrastructure

import (
        "context"
        "crypto/md5"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ReviewRepository implements the domain.ReviewRepository interface
type ReviewRepository struct {
        db     *Database
        logger *logger.Logger
}

// NewReviewRepository creates a new ReviewRepository instance
func NewReviewRepository(db *Database, logger *logger.Logger) domain.ReviewRepository <span class="cov10" title="13">{
        return &amp;ReviewRepository{
                db:     db,
                logger: logger,
        }
}</span>

// Review operations
func (r *ReviewRepository) CreateBatch(ctx context.Context, reviews []domain.Review) error <span class="cov0" title="0">{
        if len(reviews) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">start := time.Now()

        // Use transaction for batch operations
        err := r.db.Transaction(ctx, func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Process in batches to avoid memory issues
                batchSize := 1000
                for i := 0; i &lt; len(reviews); i += batchSize </span><span class="cov0" title="0">{
                        end := i + batchSize
                        if end &gt; len(reviews) </span><span class="cov0" title="0">{
                                end = len(reviews)
                        }</span>

                        <span class="cov0" title="0">batch := reviews[i:end]

                        // Use upsert to handle duplicates
                        if err := tx.Clauses(clause.OnConflict{
                                Columns:   []clause.Column{{Name: "external_id"}, {Name: "provider_id"}},
                                DoUpdates: clause.AssignmentColumns([]string{"rating", "comment", "review_date", "updated_at"}),
                        }).Create(&amp;batch).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create batch %d-%d: %w", i, end, err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "Failed to create review batch",
                        "count", len(reviews),
                        "error", err,
                )
                return fmt.Errorf("failed to create review batch: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        r.logger.InfoContext(ctx, "Review batch created successfully",
                "count", len(reviews),
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

func (r *ReviewRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Review, error) <span class="cov4" title="3">{
        var review domain.Review

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                First(&amp;review, "id = ?", id).Error

        if err != nil </span><span class="cov3" title="2">{
                if err == gorm.ErrRecordNotFound </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("review not found: %w", err)
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get review by ID: %w", err)</span>
        }

        <span class="cov1" title="1">return &amp;review, nil</span>
}

func (r *ReviewRepository) GetByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]domain.Review, error) <span class="cov3" title="2">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("provider_id = ?", providerID).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by provider: %w", err)
        }</span>

        <span class="cov3" title="2">return reviews, nil</span>
}

func (r *ReviewRepository) GetByHotel(ctx context.Context, hotelID uuid.UUID, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("hotel_id = ?", hotelID).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by hotel: %w", err)
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetByDateRange(ctx context.Context, startDate, endDate time.Time, limit, offset int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Where("review_date BETWEEN ? AND ?", startDate, endDate).
                Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews by date range: %w", err)
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error <span class="cov4" title="3">{
        result := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("id = ?", id).
                Update("status", status)

        if result.Error != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update review status: %w", result.Error)
        }</span>

        <span class="cov3" title="2">if result.RowsAffected == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("review not found for status update")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *ReviewRepository) DeleteByID(ctx context.Context, id uuid.UUID) error <span class="cov4" title="3">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Review{}, "id = ?", id)

        if result.Error != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete review: %w", result.Error)
        }</span>

        <span class="cov3" title="2">if result.RowsAffected == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("review not found for deletion")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *ReviewRepository) Search(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]domain.Review, error) <span class="cov3" title="2">{
        var reviews []domain.Review

        db := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo")

        // Apply text search if query is provided
        if query != "" </span><span class="cov1" title="1">{
                db = db.Where("comment ILIKE ? OR title ILIKE ?", "%"+query+"%", "%"+query+"%")
        }</span>

        // Apply filters
        <span class="cov3" title="2">for key, value := range filters </span><span class="cov6" title="5">{
                switch key </span>{
                case "rating":<span class="cov1" title="1">
                        db = db.Where("rating = ?", value)</span>
                case "min_rating":<span class="cov1" title="1">
                        db = db.Where("rating &gt;= ?", value)</span>
                case "max_rating":<span class="cov0" title="0">
                        db = db.Where("rating &lt;= ?", value)</span>
                case "provider_id":<span class="cov1" title="1">
                        db = db.Where("provider_id = ?", value)</span>
                case "hotel_id":<span class="cov1" title="1">
                        db = db.Where("hotel_id = ?", value)</span>
                case "language":<span class="cov0" title="0">
                        db = db.Where("language = ?", value)</span>
                case "sentiment":<span class="cov0" title="0">
                        db = db.Where("sentiment = ?", value)</span>
                case "is_verified":<span class="cov1" title="1">
                        db = db.Where("is_verified = ?", value)</span>
                case "start_date":<span class="cov0" title="0">
                        db = db.Where("review_date &gt;= ?", value)</span>
                case "end_date":<span class="cov0" title="0">
                        db = db.Where("review_date &lt;= ?", value)</span>
                }
        }

        <span class="cov3" title="2">err := db.Order("review_date DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search reviews: %w", err)
        }</span>

        <span class="cov3" title="2">return reviews, nil</span>
}

func (r *ReviewRepository) GetTotalCount(ctx context.Context, filters map[string]interface{}) (int64, error) <span class="cov3" title="2">{
        var count int64

        db := r.db.WithContext(ctx).Model(&amp;domain.Review{})

        // Apply filters
        for key, value := range filters </span><span class="cov1" title="1">{
                switch key </span>{
                case "rating":<span class="cov0" title="0">
                        db = db.Where("rating = ?", value)</span>
                case "min_rating":<span class="cov1" title="1">
                        db = db.Where("rating &gt;= ?", value)</span>
                case "max_rating":<span class="cov0" title="0">
                        db = db.Where("rating &lt;= ?", value)</span>
                case "provider_id":<span class="cov0" title="0">
                        db = db.Where("provider_id = ?", value)</span>
                case "hotel_id":<span class="cov0" title="0">
                        db = db.Where("hotel_id = ?", value)</span>
                case "language":<span class="cov0" title="0">
                        db = db.Where("language = ?", value)</span>
                case "sentiment":<span class="cov0" title="0">
                        db = db.Where("sentiment = ?", value)</span>
                case "is_verified":<span class="cov0" title="0">
                        db = db.Where("is_verified = ?", value)</span>
                case "start_date":<span class="cov0" title="0">
                        db = db.Where("review_date &gt;= ?", value)</span>
                case "end_date":<span class="cov0" title="0">
                        db = db.Where("review_date &lt;= ?", value)</span>
                }
        }

        <span class="cov3" title="2">err := db.Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get total count: %w", err)
        }</span>

        <span class="cov3" title="2">return count, nil</span>
}

// Hotel operations
func (r *ReviewRepository) CreateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov3" title="2">{
        err := r.db.WithContext(ctx).Create(hotel).Error
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create hotel: %w", err)
        }</span>

        <span class="cov1" title="1">r.logger.InfoContext(ctx, "Hotel created successfully", "hotel_id", hotel.ID, "name", hotel.Name)
        return nil</span>
}

func (r *ReviewRepository) GetHotelByID(ctx context.Context, id uuid.UUID) (*domain.Hotel, error) <span class="cov3" title="2">{
        var hotel domain.Hotel

        err := r.db.WithContext(ctx).First(&amp;hotel, "id = ?", id).Error
        if err != nil </span><span class="cov1" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("hotel not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get hotel by ID: %w", err)</span>
        }

        <span class="cov1" title="1">return &amp;hotel, nil</span>
}

func (r *ReviewRepository) GetHotelByName(ctx context.Context, name string) (*domain.Hotel, error) <span class="cov0" title="0">{
        var hotel domain.Hotel

        err := r.db.WithContext(ctx).Where("name = ?", name).First(&amp;hotel).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("hotel not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get hotel by name: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;hotel, nil</span>
}

func (r *ReviewRepository) UpdateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(hotel).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update hotel: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Hotel updated successfully", "hotel_id", hotel.ID, "name", hotel.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteHotel(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Hotel{}, "id = ?", id)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete hotel: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("hotel not found for deletion")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) ListHotels(ctx context.Context, limit, offset int) ([]domain.Hotel, error) <span class="cov0" title="0">{
        var hotels []domain.Hotel

        err := r.db.WithContext(ctx).
                Order("name").
                Limit(limit).
                Offset(offset).
                Find(&amp;hotels).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list hotels: %w", err)
        }</span>

        <span class="cov0" title="0">return hotels, nil</span>
}

// Provider operations
func (r *ReviewRepository) CreateProvider(ctx context.Context, provider *domain.Provider) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(provider).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create provider: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Provider created successfully", "provider_id", provider.ID, "name", provider.Name)
        return nil</span>
}

func (r *ReviewRepository) GetProviderByID(ctx context.Context, id uuid.UUID) (*domain.Provider, error) <span class="cov0" title="0">{
        var provider domain.Provider

        err := r.db.WithContext(ctx).First(&amp;provider, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("provider not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get provider by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;provider, nil</span>
}

func (r *ReviewRepository) GetProviderByName(ctx context.Context, name string) (*domain.Provider, error) <span class="cov0" title="0">{
        var provider domain.Provider

        err := r.db.WithContext(ctx).Where("name = ?", name).First(&amp;provider).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("provider not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get provider by name: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;provider, nil</span>
}

func (r *ReviewRepository) UpdateProvider(ctx context.Context, provider *domain.Provider) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(provider).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update provider: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Provider updated successfully", "provider_id", provider.ID, "name", provider.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteProvider(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.Provider{}, "id = ?", id)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete provider: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provider not found for deletion")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) ListProviders(ctx context.Context, limit, offset int) ([]domain.Provider, error) <span class="cov0" title="0">{
        var providers []domain.Provider

        err := r.db.WithContext(ctx).
                Order("name").
                Limit(limit).
                Offset(offset).
                Find(&amp;providers).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list providers: %w", err)
        }</span>

        <span class="cov0" title="0">return providers, nil</span>
}

// ReviewerInfo operations
func (r *ReviewRepository) CreateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create reviewer info: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Reviewer info created successfully", "reviewer_id", reviewerInfo.ID, "name", reviewerInfo.Name)
        return nil</span>
}

func (r *ReviewRepository) GetReviewerInfoByID(ctx context.Context, id uuid.UUID) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewerInfo domain.ReviewerInfo

        err := r.db.WithContext(ctx).First(&amp;reviewerInfo, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reviewer info not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get reviewer info by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;reviewerInfo, nil</span>
}

func (r *ReviewRepository) GetReviewerInfoByEmail(ctx context.Context, email string) (*domain.ReviewerInfo, error) <span class="cov0" title="0">{
        var reviewerInfo domain.ReviewerInfo

        err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reviewer info not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get reviewer info by email: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;reviewerInfo, nil</span>
}

func (r *ReviewRepository) UpdateReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Save(reviewerInfo).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update reviewer info: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Reviewer info updated successfully", "reviewer_id", reviewerInfo.ID, "name", reviewerInfo.Name)
        return nil</span>
}

func (r *ReviewRepository) DeleteReviewerInfo(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.ReviewerInfo{}, "id = ?", id)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete reviewer info: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("reviewer info not found for deletion")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Review summary operations
func (r *ReviewRepository) CreateOrUpdateReviewSummary(ctx context.Context, summary *domain.ReviewSummary) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "hotel_id"}},
                DoUpdates: clause.AssignmentColumns([]string{"total_reviews", "average_rating", "rating_distribution", "avg_service_rating", "avg_cleanliness_rating", "avg_location_rating", "avg_value_rating", "avg_comfort_rating", "avg_facilities_rating", "last_review_date", "updated_at"}),
        }).Create(summary).Error

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create or update review summary: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Review summary created/updated successfully", "hotel_id", summary.HotelID)
        return nil</span>
}

func (r *ReviewRepository) GetReviewSummaryByHotelID(ctx context.Context, hotelID uuid.UUID) (*domain.ReviewSummary, error) <span class="cov0" title="0">{
        var summary domain.ReviewSummary

        err := r.db.WithContext(ctx).
                Preload("Hotel").
                First(&amp;summary, "hotel_id = ?", hotelID).Error

        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("review summary not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get review summary by hotel ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;summary, nil</span>
}

func (r *ReviewRepository) UpdateReviewSummary(ctx context.Context, hotelID uuid.UUID) error <span class="cov0" title="0">{
        // Calculate aggregated statistics
        var stats struct {
                TotalReviews         int64
                AverageRating        float64
                AvgServiceRating     float64
                AvgCleanlinessRating float64
                AvgLocationRating    float64
                AvgValueRating       float64
                AvgComfortRating     float64
                AvgFacilitiesRating  float64
                LastReviewDate       time.Time
        }

        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select(`
                        COUNT(*) as total_reviews,
                        AVG(rating) as average_rating,
                        AVG(service_rating) as avg_service_rating,
                        AVG(cleanliness_rating) as avg_cleanliness_rating,
                        AVG(location_rating) as avg_location_rating,
                        AVG(value_rating) as avg_value_rating,
                        AVG(comfort_rating) as avg_comfort_rating,
                        AVG(facilities_rating) as avg_facilities_rating,
                        MAX(review_date) as last_review_date
                `).
                Scan(&amp;stats).Error

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate review statistics: %w", err)
        }</span>

        // Get rating distribution
        <span class="cov0" title="0">var ratingDist []struct {
                Rating int
                Count  int64
        }

        err = r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select("FLOOR(rating) as rating, COUNT(*) as count").
                Group("FLOOR(rating)").
                Scan(&amp;ratingDist).Error

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rating distribution: %w", err)
        }</span>

        // Build rating distribution map
        <span class="cov0" title="0">ratingDistribution := make(map[string]int)
        for _, dist := range ratingDist </span><span class="cov0" title="0">{
                ratingDistribution[fmt.Sprintf("%.0f", float64(dist.Rating))] = int(dist.Count)
        }</span>

        // Update or create summary
        <span class="cov0" title="0">summary := &amp;domain.ReviewSummary{
                HotelID:              hotelID,
                TotalReviews:         int(stats.TotalReviews),
                AverageRating:        stats.AverageRating,
                RatingDistribution:   ratingDistribution,
                AvgServiceRating:     stats.AvgServiceRating,
                AvgCleanlinessRating: stats.AvgCleanlinessRating,
                AvgLocationRating:    stats.AvgLocationRating,
                AvgValueRating:       stats.AvgValueRating,
                AvgComfortRating:     stats.AvgComfortRating,
                AvgFacilitiesRating:  stats.AvgFacilitiesRating,
                LastReviewDate:       stats.LastReviewDate,
        }

        return r.CreateOrUpdateReviewSummary(ctx, summary)</span>
}

// Review processing status operations
func (r *ReviewRepository) CreateProcessingStatus(ctx context.Context, status *domain.ReviewProcessingStatus) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Create(status).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create processing status: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.InfoContext(ctx, "Processing status created successfully", "processing_id", status.ID, "provider_id", status.ProviderID)
        return nil</span>
}

func (r *ReviewRepository) GetProcessingStatusByID(ctx context.Context, id uuid.UUID) (*domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        var status domain.ReviewProcessingStatus

        err := r.db.WithContext(ctx).
                Preload("Provider").
                First(&amp;status, "id = ?", id).Error

        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("processing status not found: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get processing status by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;status, nil</span>
}

func (r *ReviewRepository) GetProcessingStatusByProvider(ctx context.Context, providerID uuid.UUID, limit, offset int) ([]domain.ReviewProcessingStatus, error) <span class="cov0" title="0">{
        var statuses []domain.ReviewProcessingStatus

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Where("provider_id = ?", providerID).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;statuses).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get processing status by provider: %w", err)
        }</span>

        <span class="cov0" title="0">return statuses, nil</span>
}

func (r *ReviewRepository) UpdateProcessingStatus(ctx context.Context, id uuid.UUID, status string, recordsProcessed int, errorMsg string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":            status,
                "records_processed": recordsProcessed,
                "error_msg":         errorMsg,
                "updated_at":        time.Now(),
        }

        if status == "processing" </span><span class="cov0" title="0">{
                updates["started_at"] = time.Now()
        }</span> else<span class="cov0" title="0"> if status == "completed" || status == "failed" </span><span class="cov0" title="0">{
                updates["completed_at"] = time.Now()
        }</span>

        <span class="cov0" title="0">result := r.db.WithContext(ctx).
                Model(&amp;domain.ReviewProcessingStatus{}).
                Where("id = ?", id).
                Updates(updates)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update processing status: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("processing status not found for update")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) DeleteProcessingStatus(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.WithContext(ctx).Delete(&amp;domain.ReviewProcessingStatus{}, "id = ?", id)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete processing status: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("processing status not found for deletion")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Duplicate prevention methods
func (r *ReviewRepository) FindDuplicateReviews(ctx context.Context, review *domain.Review) ([]domain.Review, error) <span class="cov0" title="0">{
        var duplicates []domain.Review

        // Generate content hash for duplicate detection
        contentHash := r.generateContentHash(review)

        err := r.db.WithContext(ctx).
                Where("hotel_id = ? AND provider_id = ? AND processing_hash = ?",
                        review.HotelID, review.ProviderID, contentHash).
                Find(&amp;duplicates).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find duplicate reviews: %w", err)
        }</span>

        <span class="cov0" title="0">return duplicates, nil</span>
}

func (r *ReviewRepository) CheckProcessingHashExists(ctx context.Context, hash string) (bool, error) <span class="cov4" title="3">{
        var count int64

        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("processing_hash = ?", hash).
                Count(&amp;count).Error

        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to check processing hash existence: %w", err)
        }</span>

        <span class="cov3" title="2">return count &gt; 0, nil</span>
}

func (r *ReviewRepository) UpsertReviewerInfo(ctx context.Context, reviewerInfo *domain.ReviewerInfo) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "email"}},
                DoUpdates: clause.AssignmentColumns([]string{"name", "country", "is_verified", "total_reviews", "average_rating", "member_since", "profile_image_url", "bio", "updated_at"}),
        }).Create(reviewerInfo).Error

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert reviewer info: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReviewRepository) UpsertHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov0" title="0">{
        err := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "name"}, {Name: "city"}, {Name: "country"}},
                DoUpdates: clause.AssignmentColumns([]string{"address", "postal_code", "phone", "email", "star_rating", "description", "amenities", "latitude", "longitude", "updated_at"}),
        }).Create(hotel).Error

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert hotel: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods
func (r *ReviewRepository) generateContentHash(review *domain.Review) string <span class="cov3" title="2">{
        content := fmt.Sprintf("%s|%s|%f|%s|%s",
                review.HotelID.String(),
                review.ProviderID.String(),
                review.Rating,
                review.Comment,
                review.ReviewDate.Format("2006-01-02"),
        )

        hash := md5.Sum([]byte(content))
        return fmt.Sprintf("%x", hash)
}</span>

func (r *ReviewRepository) GetBatchInsertSize() int <span class="cov0" title="0">{
        return 1000
}</span>

func (r *ReviewRepository) GetReviewsForSummaryUpdate(ctx context.Context, hotelID uuid.UUID, limit int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Where("hotel_id = ?", hotelID).
                Order("review_date DESC").
                Limit(limit).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviews for summary update: %w", err)
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetReviewCountByProvider(ctx context.Context, providerID uuid.UUID, startDate, endDate time.Time) (int64, error) <span class="cov0" title="0">{
        var count int64

        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("provider_id = ? AND review_date BETWEEN ? AND ?", providerID, startDate, endDate).
                Count(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get review count by provider: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ReviewRepository) GetReviewCountByHotel(ctx context.Context, hotelID uuid.UUID, startDate, endDate time.Time) (int64, error) <span class="cov0" title="0">{
        var count int64

        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ? AND review_date BETWEEN ? AND ?", hotelID, startDate, endDate).
                Count(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get review count by hotel: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ReviewRepository) GetAverageRatingByHotel(ctx context.Context, hotelID uuid.UUID) (float64, error) <span class="cov0" title="0">{
        var avgRating float64

        err := r.db.WithContext(ctx).
                Model(&amp;domain.Review{}).
                Where("hotel_id = ?", hotelID).
                Select("AVG(rating)").
                Scan(&amp;avgRating).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get average rating by hotel: %w", err)
        }</span>

        <span class="cov0" title="0">return avgRating, nil</span>
}

func (r *ReviewRepository) GetTopRatedHotels(ctx context.Context, limit int) ([]domain.Hotel, error) <span class="cov0" title="0">{
        var hotels []domain.Hotel

        err := r.db.WithContext(ctx).
                Table("hotels").
                Select("hotels.*, AVG(reviews.rating) as avg_rating").
                Joins("LEFT JOIN reviews ON hotels.id = reviews.hotel_id").
                Group("hotels.id").
                Order("avg_rating DESC").
                Limit(limit).
                Find(&amp;hotels).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top rated hotels: %w", err)
        }</span>

        <span class="cov0" title="0">return hotels, nil</span>
}

func (r *ReviewRepository) GetRecentReviews(ctx context.Context, limit int) ([]domain.Review, error) <span class="cov0" title="0">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Preload("Provider").
                Preload("Hotel").
                Preload("ReviewerInfo").
                Order("review_date DESC").
                Limit(limit).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent reviews: %w", err)
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) BulkUpdateReviewSentiment(ctx context.Context, updates map[uuid.UUID]string) error <span class="cov3" title="2">{
        return r.db.Transaction(ctx, func(tx *gorm.DB) error </span><span class="cov3" title="2">{
                for reviewID, sentiment := range updates </span><span class="cov5" title="4">{
                        if err := tx.Model(&amp;domain.Review{}).
                                Where("id = ?", reviewID).
                                Update("sentiment", sentiment).Error; err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to update sentiment for review %s: %w", reviewID, err)
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })
}

func (r *ReviewRepository) GetReviewsWithoutSentiment(ctx context.Context, limit int) ([]domain.Review, error) <span class="cov4" title="3">{
        var reviews []domain.Review

        err := r.db.WithContext(ctx).
                Where("sentiment IS NULL OR sentiment = ''").
                Limit(limit).
                Find(&amp;reviews).Error

        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get reviews without sentiment: %w", err)
        }</span>

        <span class="cov3" title="2">return reviews, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package infrastructure

import (
        "context"
        "crypto/rand"
        "fmt"
        "math"
        "math/big"
        "net"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// ErrorType represents the type of error for retry classification
// Note: Using ErrorType from error_handler.go for consistency

// Retry error mappings to ErrorType constants from error_handler.go
const (
        // Common retryable error types
        RetryableNetworkError  = ErrorTypeNetwork
        RetryableTimeoutError  = ErrorTypeTimeout
        RetryableSystemError   = ErrorTypeSystem
        RetryableExternalError = ErrorTypeExternal

        // Common permanent error types
        PermanentValidationError = ErrorTypeValidation
        PermanentClientError     = ErrorTypeClient
        PermanentAuthError       = ErrorTypeAuthentication
)

// Note: Using ErrorType.String() method from error_handler.go

// RetryStrategy represents different retry strategies
type RetryStrategy int

const (
        // StrategyFixedDelay uses fixed delay between retries
        StrategyFixedDelay RetryStrategy = iota
        // StrategyExponentialBackoff uses exponential backoff
        StrategyExponentialBackoff
        // StrategyLinearBackoff uses linear backoff
        StrategyLinearBackoff
        // StrategyFibonacciBackoff uses Fibonacci sequence for backoff
        StrategyFibonacciBackoff
        // StrategyCustom allows custom backoff calculation
        StrategyCustom
)

// String returns the string representation of the retry strategy
func (rs RetryStrategy) String() string <span class="cov0" title="0">{
        switch rs </span>{
        case StrategyFixedDelay:<span class="cov0" title="0">
                return "FIXED_DELAY"</span>
        case StrategyExponentialBackoff:<span class="cov0" title="0">
                return "EXPONENTIAL_BACKOFF"</span>
        case StrategyLinearBackoff:<span class="cov0" title="0">
                return "LINEAR_BACKOFF"</span>
        case StrategyFibonacciBackoff:<span class="cov0" title="0">
                return "FIBONACCI_BACKOFF"</span>
        case StrategyCustom:<span class="cov0" title="0">
                return "CUSTOM"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// JitterType represents different jitter types
type JitterType int

const (
        // JitterTypeNone uses no jitter
        JitterTypeNone JitterType = iota
        // JitterTypeFull uses full jitter
        JitterTypeFull
        // JitterTypeEqual uses equal jitter
        JitterTypeEqual
        // JitterTypeDecorrelated uses decorrelated jitter
        JitterTypeDecorrelated
)

// String returns the string representation of the jitter type
func (jt JitterType) String() string <span class="cov0" title="0">{
        switch jt </span>{
        case JitterTypeNone:<span class="cov0" title="0">
                return "NONE"</span>
        case JitterTypeFull:<span class="cov0" title="0">
                return "FULL"</span>
        case JitterTypeEqual:<span class="cov0" title="0">
                return "EQUAL"</span>
        case JitterTypeDecorrelated:<span class="cov0" title="0">
                return "DECORRELATED"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// RetryableFunc represents a function that can be retried
type RetryableFunc func(ctx context.Context, attempt int) (interface{}, error)

// RetryCondition represents a condition for retry
type RetryCondition func(err error, attempt int) bool

// BackoffFunc represents a custom backoff function
type BackoffFunc func(attempt int, baseDelay time.Duration) time.Duration

// DeadLetterHandler handles failed operations
type DeadLetterHandler func(ctx context.Context, operation string, err error, attempts int, metadata map[string]interface{})

// RetryConfig represents retry configuration
type RetryConfig struct {
        // Basic retry configuration
        MaxAttempts int           `json:"max_attempts" validate:"min=1"`
        BaseDelay   time.Duration `json:"base_delay" validate:"required"`
        MaxDelay    time.Duration `json:"max_delay"`
        Timeout     time.Duration `json:"timeout"`

        // Strategy configuration
        Strategy   RetryStrategy `json:"strategy"`
        Multiplier float64       `json:"multiplier" validate:"min=1"`

        // Jitter configuration
        JitterType         JitterType `json:"jitter_type"`
        JitterMaxDeviation float64    `json:"jitter_max_deviation" validate:"min=0,max=1"`

        // Circuit breaker integration
        EnableCircuitBreaker bool   `json:"enable_circuit_breaker"`
        CircuitBreakerName   string `json:"circuit_breaker_name"`

        // Error handling
        RetryableErrors  []ErrorType      `json:"retryable_errors"`
        PermanentErrors  []ErrorType      `json:"permanent_errors"`
        CustomConditions []RetryCondition `json:"-"`

        // Dead letter queue
        EnableDeadLetter  bool              `json:"enable_dead_letter"`
        DeadLetterHandler DeadLetterHandler `json:"-"`

        // Custom backoff
        CustomBackoff BackoffFunc `json:"-"`

        // Metrics and logging
        EnableMetrics bool   `json:"enable_metrics"`
        EnableLogging bool   `json:"enable_logging"`
        LogLevel      string `json:"log_level"`

        // Operation metadata
        OperationName string            `json:"operation_name"`
        OperationType string            `json:"operation_type"`
        Tags          map[string]string `json:"tags"`
}

// DefaultRetryConfig returns default retry configuration
func DefaultRetryConfig() *RetryConfig <span class="cov5" title="18">{
        return &amp;RetryConfig{
                MaxAttempts:          3,
                BaseDelay:            100 * time.Millisecond,
                MaxDelay:             30 * time.Second,
                Timeout:              5 * time.Minute,
                Strategy:             StrategyExponentialBackoff,
                Multiplier:           2.0,
                JitterType:           JitterTypeFull,
                JitterMaxDeviation:   0.1,
                EnableCircuitBreaker: true,
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout, ErrorTypeExternal},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     true,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "info",
                OperationName:        "default",
                OperationType:        "unknown",
                Tags:                 make(map[string]string),
        }
}</span>

// RetryMetrics represents retry metrics
type RetryMetrics struct {
        // Attempt statistics
        TotalAttempts        uint64 `json:"total_attempts"`
        TotalOperations      uint64 `json:"total_operations"`
        SuccessfulOperations uint64 `json:"successful_operations"`
        FailedOperations     uint64 `json:"failed_operations"`

        // Retry statistics
        TotalRetries       uint64               `json:"total_retries"`
        RetriesByErrorType map[ErrorType]uint64 `json:"retries_by_error_type"`
        RetriesByAttempt   map[int]uint64       `json:"retries_by_attempt"`

        // Timing statistics
        TotalDuration   time.Duration `json:"total_duration"`
        AverageDuration time.Duration `json:"average_duration"`
        MaxDuration     time.Duration `json:"max_duration"`
        MinDuration     time.Duration `json:"min_duration"`

        // Backoff statistics
        TotalBackoffTime   time.Duration `json:"total_backoff_time"`
        AverageBackoffTime time.Duration `json:"average_backoff_time"`
        MaxBackoffTime     time.Duration `json:"max_backoff_time"`
        MinBackoffTime     time.Duration `json:"min_backoff_time"`

        // Dead letter statistics
        DeadLetterCount uint64 `json:"dead_letter_count"`

        // Circuit breaker statistics
        CircuitBreakerRejects uint64 `json:"circuit_breaker_rejects"`

        // Current state
        LastAttemptTime time.Time `json:"last_attempt_time"`
        LastSuccessTime time.Time `json:"last_success_time"`
        LastFailureTime time.Time `json:"last_failure_time"`

        // Rates
        SuccessRate                float64 `json:"success_rate"`
        FailureRate                float64 `json:"failure_rate"`
        AverageRetriesPerOperation float64 `json:"average_retries_per_operation"`

        // Per-operation metrics
        OperationMetrics map[string]*OperationMetrics `json:"operation_metrics"`
}

// OperationMetrics represents metrics for a specific operation
type OperationMetrics struct {
        OperationName        string            `json:"operation_name"`
        OperationType        string            `json:"operation_type"`
        TotalAttempts        uint64            `json:"total_attempts"`
        TotalOperations      uint64            `json:"total_operations"`
        SuccessfulOperations uint64            `json:"successful_operations"`
        FailedOperations     uint64            `json:"failed_operations"`
        TotalRetries         uint64            `json:"total_retries"`
        AverageDuration      time.Duration     `json:"average_duration"`
        SuccessRate          float64           `json:"success_rate"`
        LastAttemptTime      time.Time         `json:"last_attempt_time"`
        Tags                 map[string]string `json:"tags"`
}

// RetryContext represents the context for a retry operation
type RetryContext struct {
        OperationName   string
        OperationType   string
        Attempt         int
        MaxAttempts     int
        StartTime       time.Time
        LastAttemptTime time.Time
        LastError       error
        LastErrorType   ErrorType
        TotalDuration   time.Duration
        BackoffDuration time.Duration
        Metadata        map[string]interface{}
        Tags            map[string]string
}

// RetryManager manages retry operations
type RetryManager struct {
        config         *RetryConfig
        metrics        *RetryMetrics
        circuitBreaker *CircuitBreaker
        logger         *logger.Logger

        // Internal state
        mu                sync.RWMutex
        lastBackoffTime   time.Duration
        fibonacciSequence []int

        // Background processes
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup
}

// NewRetryManager creates a new retry manager
func NewRetryManager(config *RetryConfig, circuitBreaker *CircuitBreaker, logger *logger.Logger) *RetryManager <span class="cov6" title="29">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRetryConfig()
        }</span>

        <span class="cov6" title="29">ctx, cancel := context.WithCancel(context.Background())

        rm := &amp;RetryManager{
                config: config,
                metrics: &amp;RetryMetrics{
                        RetriesByErrorType: make(map[ErrorType]uint64),
                        RetriesByAttempt:   make(map[int]uint64),
                        MinDuration:        time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
                        MinBackoffTime:     time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
                        OperationMetrics:   make(map[string]*OperationMetrics),
                },
                circuitBreaker:    circuitBreaker,
                logger:            logger,
                ctx:               ctx,
                cancel:            cancel,
                fibonacciSequence: []int{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765},
        }

        // Start background processes
        if config.EnableMetrics </span><span class="cov6" title="29">{
                rm.wg.Add(1)
                go rm.metricsLoop()
        }</span>

        <span class="cov6" title="29">return rm</span>
}

// Close closes the retry manager
func (rm *RetryManager) Close() <span class="cov6" title="29">{
        rm.cancel()
        rm.wg.Wait()
}</span>

// Execute executes a function with retry logic
func (rm *RetryManager) Execute(ctx context.Context, fn RetryableFunc) (interface{}, error) <span class="cov6" title="30">{
        return rm.ExecuteWithConfig(ctx, fn, rm.config)
}</span>

// ExecuteWithConfig executes a function with custom retry configuration
func (rm *RetryManager) ExecuteWithConfig(ctx context.Context, fn RetryableFunc, config *RetryConfig) (interface{}, error) <span class="cov6" title="30">{
        if config == nil </span><span class="cov0" title="0">{
                config = rm.config
        }</span>

        // Create retry context
        <span class="cov6" title="30">retryCtx := &amp;RetryContext{
                OperationName: config.OperationName,
                OperationType: config.OperationType,
                MaxAttempts:   config.MaxAttempts,
                StartTime:     time.Now(),
                Metadata:      make(map[string]interface{}),
                Tags:          config.Tags,
        }

        // Create timeout context if specified
        operationCtx := ctx
        if config.Timeout &gt; 0 </span><span class="cov6" title="30">{
                var cancel context.CancelFunc
                operationCtx, cancel = context.WithTimeout(ctx, config.Timeout)
                defer cancel()
        }</span>

        // Execute with retry logic
        <span class="cov6" title="30">result, err := rm.executeWithRetry(operationCtx, fn, config, retryCtx)

        // Update metrics
        rm.updateMetrics(retryCtx, err)

        // Handle dead letter queue
        if err != nil &amp;&amp; config.EnableDeadLetter &amp;&amp; config.DeadLetterHandler != nil </span><span class="cov1" title="1">{
                rm.handleDeadLetter(ctx, config, retryCtx, err)
        }</span>

        <span class="cov6" title="30">return result, err</span>
}

// executeWithRetry executes a function with retry logic
func (rm *RetryManager) executeWithRetry(ctx context.Context, fn RetryableFunc, config *RetryConfig, retryCtx *RetryContext) (interface{}, error) <span class="cov6" title="30">{
        var lastErr error
        var result interface{}

        for attempt := 1; attempt &lt;= config.MaxAttempts; attempt++ </span><span class="cov7" title="70">{
                retryCtx.Attempt = attempt
                retryCtx.LastAttemptTime = time.Now()

                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov7" title="70"></span>
                }

                // Check circuit breaker
                <span class="cov7" title="70">if config.EnableCircuitBreaker &amp;&amp; rm.circuitBreaker != nil </span><span class="cov4" title="7">{
                        if err := rm.checkCircuitBreaker(ctx, config); err != nil </span><span class="cov2" title="3">{
                                rm.recordCircuitBreakerReject()
                                rm.circuitBreaker.recordRejection()
                                return nil, err
                        }</span>
                }

                // Execute the function
                <span class="cov7" title="67">executeStart := time.Now()
                result, lastErr = fn(ctx, attempt)
                executeDuration := time.Since(executeStart)

                // Update retry context
                retryCtx.LastError = lastErr
                retryCtx.TotalDuration += executeDuration

                // If successful, return immediately
                if lastErr == nil </span><span class="cov5" title="18">{
                        // Record successful attempt metrics
                        rm.recordAttempt(config, attempt, executeDuration, lastErr)

                        // Record success with circuit breaker
                        if config.EnableCircuitBreaker &amp;&amp; rm.circuitBreaker != nil </span><span class="cov2" title="2">{
                                rm.circuitBreaker.recordSuccess()
                        }</span>

                        <span class="cov5" title="18">if config.EnableLogging </span><span class="cov2" title="2">{
                                rm.logSuccess(config, retryCtx)
                        }</span>
                        <span class="cov5" title="18">return result, nil</span>
                }

                // Classify error
                <span class="cov7" title="49">errorType := rm.classifyError(lastErr)
                retryCtx.LastErrorType = errorType

                // Record attempt metrics
                rm.recordAttempt(config, attempt, executeDuration, lastErr)

                // Record failure with circuit breaker
                if config.EnableCircuitBreaker &amp;&amp; rm.circuitBreaker != nil </span><span class="cov2" title="2">{
                        rm.circuitBreaker.recordFailure()
                }</span>

                // Check if error is retryable
                <span class="cov7" title="49">if !rm.isRetryable(lastErr, attempt, config) </span><span class="cov2" title="2">{
                        if config.EnableLogging </span><span class="cov0" title="0">{
                                rm.logNonRetryableError(config, retryCtx, lastErr)
                        }</span>
                        <span class="cov2" title="2">break</span>
                }

                // Don't sleep after the last attempt
                <span class="cov7" title="47">if attempt == config.MaxAttempts </span><span class="cov3" title="5">{
                        break</span>
                }

                // We are going to retry, so count this as a retry
                <span class="cov6" title="42">rm.recordRetry(config, attempt, lastErr)

                // Calculate backoff delay
                backoffDelay := rm.calculateBackoff(attempt, config)
                retryCtx.BackoffDuration = backoffDelay

                // Log retry attempt
                if config.EnableLogging </span><span class="cov0" title="0">{
                        rm.logRetryAttempt(config, retryCtx, lastErr, backoffDelay)
                }</span>

                // Wait before retry
                <span class="cov6" title="42">if backoffDelay &gt; 0 </span><span class="cov6" title="42">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov2" title="2">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(backoffDelay):<span class="cov6" title="40"></span>
                        }
                }
        }

        <span class="cov4" title="7">if config.EnableLogging </span><span class="cov0" title="0">{
                rm.logAllAttemptsFailed(config, retryCtx, lastErr)
        }</span>

        <span class="cov4" title="7">return result, lastErr</span>
}

// checkCircuitBreaker checks if the circuit breaker allows the operation
func (rm *RetryManager) checkCircuitBreaker(ctx context.Context, config *RetryConfig) error <span class="cov4" title="7">{
        if rm.circuitBreaker == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check circuit breaker state
        <span class="cov4" title="7">if rm.circuitBreaker.IsOpen() </span><span class="cov2" title="3">{
                return &amp;CircuitBreakerError{
                        State:   StateOpen,
                        Message: "circuit breaker is open",
                }
        }</span>

        <span class="cov3" title="4">return nil</span>
}

// isRetryable determines if an error is retryable
func (rm *RetryManager) isRetryable(err error, attempt int, config *RetryConfig) bool <span class="cov8" title="92">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check custom conditions first
        <span class="cov8" title="92">for _, condition := range config.CustomConditions </span><span class="cov3" title="5">{
                if condition != nil &amp;&amp; !condition(err, attempt) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Classify error
        <span class="cov8" title="91">errorType := rm.classifyError(err)

        // Check if error type is in permanent errors list
        for _, permanentError := range config.PermanentErrors </span><span class="cov9" title="182">{
                if errorType == permanentError </span><span class="cov2" title="2">{
                        return false
                }</span>
        }

        // Check if error type is in retryable errors list
        <span class="cov7" title="89">for _, retryableError := range config.RetryableErrors </span><span class="cov10" title="321">{
                if errorType == retryableError </span><span class="cov7" title="89">{
                        return true
                }</span>
        }

        // Default behavior: retry transient and network errors
        <span class="cov0" title="0">return errorType == ErrorTypeNetwork || errorType == ErrorTypeTimeout</span>
}

// classifyError classifies an error into a specific error type
func (rm *RetryManager) classifyError(err error) ErrorType <span class="cov9" title="190">{
        if err == nil </span><span class="cov0" title="0">{
                return ErrorTypeSystem
        }</span>

        <span class="cov9" title="190">errorStr := err.Error()
        errorStrLower := strings.ToLower(errorStr)

        // Check for circuit breaker errors
        if IsCircuitBreakerError(err) </span><span class="cov0" title="0">{
                return ErrorTypeCircuitBreaker
        }</span>

        // Check for context errors
        <span class="cov9" title="190">if err == context.Canceled || err == context.DeadlineExceeded </span><span class="cov4" title="10">{
                return ErrorTypeTimeout
        }</span>

        // Check for network errors
        <span class="cov9" title="180">if netErr, ok := err.(net.Error); ok </span><span class="cov5" title="19">{
                if netErr.Timeout() </span><span class="cov0" title="0">{
                        return ErrorTypeTimeout
                }</span>
                <span class="cov5" title="19">return ErrorTypeNetwork</span>
        }

        // Check for common error patterns
        <span class="cov8" title="161">if strings.Contains(errorStrLower, "timeout") || strings.Contains(errorStrLower, "deadline") </span><span class="cov0" title="0">{
                return ErrorTypeTimeout
        }</span>

        <span class="cov8" title="161">if strings.Contains(errorStrLower, "rate limit") || strings.Contains(errorStrLower, "too many requests") </span><span class="cov1" title="1">{
                return ErrorTypeRateLimit
        }</span>

        <span class="cov8" title="160">if strings.Contains(errorStrLower, "connection refused") ||
                strings.Contains(errorStrLower, "connection reset") ||
                strings.Contains(errorStrLower, "network") ||
                strings.Contains(errorStrLower, "dns") </span><span class="cov0" title="0">{
                return ErrorTypeNetwork
        }</span>

        // Check for HTTP status codes (if available in error message)
        <span class="cov8" title="160">if strings.Contains(errorStrLower, "500") || strings.Contains(errorStrLower, "502") ||
                strings.Contains(errorStrLower, "503") || strings.Contains(errorStrLower, "504") </span><span class="cov1" title="1">{
                return ErrorTypeExternal
        }</span>

        <span class="cov8" title="159">if strings.Contains(errorStrLower, "400") || strings.Contains(errorStrLower, "401") ||
                strings.Contains(errorStrLower, "403") || strings.Contains(errorStrLower, "404") </span><span class="cov3" title="4">{
                return ErrorTypeClient
        }</span>

        // Check for permanent error patterns
        <span class="cov8" title="155">if strings.Contains(errorStrLower, "invalid") || strings.Contains(errorStrLower, "bad request") ||
                strings.Contains(errorStrLower, "unauthorized") || strings.Contains(errorStrLower, "forbidden") </span><span class="cov1" title="1">{
                return ErrorTypeValidation
        }</span>

        // Default to system error for unknown errors
        <span class="cov8" title="154">return ErrorTypeSystem</span>
}

// calculateBackoff calculates the backoff delay for a retry attempt
func (rm *RetryManager) calculateBackoff(attempt int, config *RetryConfig) time.Duration <span class="cov6" title="42">{
        var delay time.Duration

        switch config.Strategy </span>{
        case StrategyFixedDelay:<span class="cov4" title="12">
                delay = config.BaseDelay</span>
        case StrategyExponentialBackoff:<span class="cov5" title="23">
                delay = rm.calculateExponentialBackoff(attempt, config)</span>
        case StrategyLinearBackoff:<span class="cov2" title="2">
                delay = rm.calculateLinearBackoff(attempt, config)</span>
        case StrategyFibonacciBackoff:<span class="cov2" title="3">
                delay = rm.calculateFibonacciBackoff(attempt, config)</span>
        case StrategyCustom:<span class="cov2" title="2">
                if config.CustomBackoff != nil </span><span class="cov2" title="2">{
                        delay = config.CustomBackoff(attempt, config.BaseDelay)
                }</span> else<span class="cov0" title="0"> {
                        delay = config.BaseDelay
                }</span>
        default:<span class="cov0" title="0">
                delay = config.BaseDelay</span>
        }

        // Apply maximum delay limit
        <span class="cov6" title="42">if config.MaxDelay &gt; 0 &amp;&amp; delay &gt; config.MaxDelay </span><span class="cov2" title="3">{
                delay = config.MaxDelay
        }</span>

        // Apply jitter
        <span class="cov6" title="42">delay = rm.applyJitter(delay, config, attempt)

        return delay</span>
}

// calculateExponentialBackoff calculates exponential backoff delay
func (rm *RetryManager) calculateExponentialBackoff(attempt int, config *RetryConfig) time.Duration <span class="cov5" title="23">{
        multiplier := config.Multiplier
        if multiplier &lt;= 0 </span><span class="cov0" title="0">{
                multiplier = 2.0
        }</span>

        <span class="cov5" title="23">delay := float64(config.BaseDelay) * math.Pow(multiplier, float64(attempt-1))
        return time.Duration(delay)</span>
}

// calculateLinearBackoff calculates linear backoff delay
func (rm *RetryManager) calculateLinearBackoff(attempt int, config *RetryConfig) time.Duration <span class="cov2" title="2">{
        multiplier := config.Multiplier
        if multiplier &lt;= 0 </span><span class="cov0" title="0">{
                multiplier = 1.0
        }</span>

        <span class="cov2" title="2">delay := float64(config.BaseDelay) * multiplier * float64(attempt)
        return time.Duration(delay)</span>
}

// calculateFibonacciBackoff calculates Fibonacci backoff delay
func (rm *RetryManager) calculateFibonacciBackoff(attempt int, config *RetryConfig) time.Duration <span class="cov2" title="3">{
        fibIndex := attempt - 1
        if fibIndex &gt;= len(rm.fibonacciSequence) </span><span class="cov0" title="0">{
                fibIndex = len(rm.fibonacciSequence) - 1
        }</span>

        <span class="cov2" title="3">delay := float64(config.BaseDelay) * float64(rm.fibonacciSequence[fibIndex])
        return time.Duration(delay)</span>
}

// applyJitter applies jitter to the delay
func (rm *RetryManager) applyJitter(delay time.Duration, config *RetryConfig, attempt int) time.Duration <span class="cov6" title="42">{
        if config.JitterType == JitterTypeNone </span><span class="cov5" title="16">{
                return delay
        }</span>

        <span class="cov6" title="26">jitteredDelay := delay
        maxDeviation := config.JitterMaxDeviation
        if maxDeviation &lt;= 0 </span><span class="cov0" title="0">{
                maxDeviation = 0.1
        }</span>

        <span class="cov6" title="26">switch config.JitterType </span>{
        case JitterTypeFull:<span class="cov6" title="26">
                // Full jitter: random delay between 0 and calculated delay
                jitteredDelay = rm.randomDuration(0, delay)</span>
        case JitterTypeEqual:<span class="cov0" title="0">
                // Equal jitter: delay/2 + random(0, delay/2)
                halfDelay := delay / 2
                jitteredDelay = halfDelay + rm.randomDuration(0, halfDelay)</span>
        case JitterTypeDecorrelated:<span class="cov0" title="0">
                // Decorrelated jitter: random delay between baseDelay and previous delay * 3
                rm.mu.Lock()
                minDelay := config.BaseDelay
                maxDelay := time.Duration(float64(delay) * 3)
                if rm.lastBackoffTime &gt; 0 </span><span class="cov0" title="0">{
                        maxDelay = time.Duration(float64(rm.lastBackoffTime) * 3)
                }</span>
                <span class="cov0" title="0">jitteredDelay = rm.randomDuration(minDelay, maxDelay)
                rm.lastBackoffTime = jitteredDelay
                rm.mu.Unlock()</span>
        }

        <span class="cov6" title="26">return jitteredDelay</span>
}

// randomDuration generates a random duration between min and max
func (rm *RetryManager) randomDuration(min, max time.Duration) time.Duration <span class="cov6" title="26">{
        if min &gt;= max </span><span class="cov0" title="0">{
                return min
        }</span>

        <span class="cov6" title="26">diff := max - min
        nBig, err := rand.Int(rand.Reader, big.NewInt(int64(diff)))
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to fixed duration if random generation fails
                return min
        }</span>

        <span class="cov6" title="26">return min + time.Duration(nBig.Int64())</span>
}

// recordAttempt records metrics for an attempt
func (rm *RetryManager) recordAttempt(config *RetryConfig, attempt int, duration time.Duration, err error) <span class="cov7" title="67">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Update global metrics
        atomic.AddUint64(&amp;rm.metrics.TotalAttempts, 1)

        if attempt == 1 </span><span class="cov6" title="27">{
                atomic.AddUint64(&amp;rm.metrics.TotalOperations, 1)
        }</span>

        <span class="cov7" title="67">if err == nil </span><span class="cov5" title="18">{
                atomic.AddUint64(&amp;rm.metrics.SuccessfulOperations, 1)
                rm.metrics.LastSuccessTime = time.Now()
        }</span> else<span class="cov7" title="49"> {
                // Check if this error will be retried
                if attempt == config.MaxAttempts || !rm.isRetryable(err, attempt, config) </span><span class="cov4" title="7">{
                        atomic.AddUint64(&amp;rm.metrics.FailedOperations, 1)
                }</span>
                <span class="cov7" title="49">rm.metrics.LastFailureTime = time.Now()</span>
        }

        // Update per-operation metrics
        <span class="cov7" title="67">rm.updateOperationMetrics(config, attempt, duration, err)</span>
}

// recordRetry records that we're about to retry
func (rm *RetryManager) recordRetry(config *RetryConfig, attempt int, err error) <span class="cov6" title="42">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        atomic.AddUint64(&amp;rm.metrics.TotalRetries, 1)
        errorType := rm.classifyError(err)
        rm.metrics.RetriesByErrorType[errorType]++
        rm.metrics.RetriesByAttempt[attempt+1]++ // +1 because next attempt will be attempt+1
}</span>

// updateOperationMetrics updates metrics for a specific operation
func (rm *RetryManager) updateOperationMetrics(config *RetryConfig, attempt int, duration time.Duration, err error) <span class="cov7" title="67">{
        operationKey := fmt.Sprintf("%s:%s", config.OperationName, config.OperationType)

        opMetrics, exists := rm.metrics.OperationMetrics[operationKey]
        if !exists </span><span class="cov5" title="19">{
                opMetrics = &amp;OperationMetrics{
                        OperationName: config.OperationName,
                        OperationType: config.OperationType,
                        Tags:          config.Tags,
                }
                rm.metrics.OperationMetrics[operationKey] = opMetrics
        }</span>

        <span class="cov7" title="67">opMetrics.TotalAttempts++

        if attempt == 1 </span><span class="cov6" title="27">{
                opMetrics.TotalOperations++
        }</span>

        <span class="cov7" title="67">if err == nil </span><span class="cov5" title="18">{
                opMetrics.SuccessfulOperations++
        }</span> else<span class="cov7" title="49"> if attempt == config.MaxAttempts </span><span class="cov3" title="6">{
                opMetrics.FailedOperations++
        }</span>

        <span class="cov7" title="67">if attempt &gt; 1 </span><span class="cov6" title="40">{
                opMetrics.TotalRetries++
        }</span>

        // Update average duration
        <span class="cov7" title="67">if opMetrics.TotalOperations &gt; 0 </span><span class="cov7" title="67">{
                opMetrics.AverageDuration = time.Duration(
                        (int64(opMetrics.AverageDuration)*int64(opMetrics.TotalOperations-1) + int64(duration)) / int64(opMetrics.TotalOperations),
                )
        }</span>

        // Update success rate
        <span class="cov7" title="67">if opMetrics.TotalOperations &gt; 0 </span><span class="cov7" title="67">{
                opMetrics.SuccessRate = float64(opMetrics.SuccessfulOperations) / float64(opMetrics.TotalOperations) * 100
        }</span>

        <span class="cov7" title="67">opMetrics.LastAttemptTime = time.Now()</span>
}

// recordCircuitBreakerReject records a circuit breaker rejection
func (rm *RetryManager) recordCircuitBreakerReject() <span class="cov2" title="3">{
        atomic.AddUint64(&amp;rm.metrics.CircuitBreakerRejects, 1)
}</span>

// updateMetrics updates final metrics after operation completion
func (rm *RetryManager) updateMetrics(retryCtx *RetryContext, finalErr error) <span class="cov6" title="30">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        // Update average retries per operation
        totalOps := atomic.LoadUint64(&amp;rm.metrics.TotalOperations)
        totalRetries := atomic.LoadUint64(&amp;rm.metrics.TotalRetries)
        if totalOps &gt; 0 </span><span class="cov6" title="30">{
                rm.metrics.AverageRetriesPerOperation = float64(totalRetries) / float64(totalOps)
        }</span>

        // Update backoff statistics
        <span class="cov6" title="30">if retryCtx.BackoffDuration &gt; 0 </span><span class="cov5" title="21">{
                rm.metrics.TotalBackoffTime += retryCtx.BackoffDuration

                if retryCtx.BackoffDuration &gt; rm.metrics.MaxBackoffTime </span><span class="cov5" title="16">{
                        rm.metrics.MaxBackoffTime = retryCtx.BackoffDuration
                }</span>
                <span class="cov5" title="21">if retryCtx.BackoffDuration &lt; rm.metrics.MinBackoffTime </span><span class="cov5" title="18">{
                        rm.metrics.MinBackoffTime = retryCtx.BackoffDuration
                }</span>

                // Update average backoff time
                <span class="cov5" title="21">if totalRetries &gt; 0 </span><span class="cov5" title="21">{
                        rm.metrics.AverageBackoffTime = time.Duration(int64(rm.metrics.TotalBackoffTime) / int64(totalRetries))
                }</span>
        }
}

// handleDeadLetter handles dead letter queue operations
func (rm *RetryManager) handleDeadLetter(ctx context.Context, config *RetryConfig, retryCtx *RetryContext, err error) <span class="cov1" title="1">{
        atomic.AddUint64(&amp;rm.metrics.DeadLetterCount, 1)

        if config.DeadLetterHandler != nil </span><span class="cov1" title="1">{
                metadata := map[string]interface{}{
                        "operation_name":    retryCtx.OperationName,
                        "operation_type":    retryCtx.OperationType,
                        "total_attempts":    retryCtx.Attempt,
                        "total_duration":    retryCtx.TotalDuration,
                        "last_error_type":   string(retryCtx.LastErrorType),
                        "backoff_duration":  retryCtx.BackoffDuration,
                        "tags":              retryCtx.Tags,
                        "start_time":        retryCtx.StartTime,
                        "last_attempt_time": retryCtx.LastAttemptTime,
                }

                // Copy custom metadata
                for k, v := range retryCtx.Metadata </span><span class="cov0" title="0">{
                        metadata[k] = v
                }</span>

                <span class="cov1" title="1">config.DeadLetterHandler(ctx, retryCtx.OperationName, err, retryCtx.Attempt, metadata)</span>
        }
}

// GetMetrics returns current retry metrics
func (rm *RetryManager) GetMetrics() *RetryMetrics <span class="cov4" title="11">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := &amp;RetryMetrics{
                TotalAttempts:              atomic.LoadUint64(&amp;rm.metrics.TotalAttempts),
                TotalOperations:            atomic.LoadUint64(&amp;rm.metrics.TotalOperations),
                SuccessfulOperations:       atomic.LoadUint64(&amp;rm.metrics.SuccessfulOperations),
                FailedOperations:           atomic.LoadUint64(&amp;rm.metrics.FailedOperations),
                TotalRetries:               atomic.LoadUint64(&amp;rm.metrics.TotalRetries),
                RetriesByErrorType:         make(map[ErrorType]uint64),
                RetriesByAttempt:           make(map[int]uint64),
                TotalDuration:              rm.metrics.TotalDuration,
                AverageDuration:            rm.metrics.AverageDuration,
                MaxDuration:                rm.metrics.MaxDuration,
                MinDuration:                rm.metrics.MinDuration,
                TotalBackoffTime:           rm.metrics.TotalBackoffTime,
                AverageBackoffTime:         rm.metrics.AverageBackoffTime,
                MaxBackoffTime:             rm.metrics.MaxBackoffTime,
                MinBackoffTime:             rm.metrics.MinBackoffTime,
                DeadLetterCount:            atomic.LoadUint64(&amp;rm.metrics.DeadLetterCount),
                CircuitBreakerRejects:      atomic.LoadUint64(&amp;rm.metrics.CircuitBreakerRejects),
                LastAttemptTime:            rm.metrics.LastAttemptTime,
                LastSuccessTime:            rm.metrics.LastSuccessTime,
                LastFailureTime:            rm.metrics.LastFailureTime,
                SuccessRate:                0,
                FailureRate:                0,
                AverageRetriesPerOperation: rm.metrics.AverageRetriesPerOperation,
                OperationMetrics:           make(map[string]*OperationMetrics),
        }

        // Copy maps
        for k, v := range rm.metrics.RetriesByErrorType </span><span class="cov4" title="7">{
                metrics.RetriesByErrorType[k] = v
        }</span>
        <span class="cov4" title="11">for k, v := range rm.metrics.RetriesByAttempt </span><span class="cov4" title="13">{
                metrics.RetriesByAttempt[k] = v
        }</span>
        <span class="cov4" title="11">for k, v := range rm.metrics.OperationMetrics </span><span class="cov4" title="11">{
                metrics.OperationMetrics[k] = &amp;(*v) // Deep copy
        }</span>

        // Calculate success and failure rates
        <span class="cov4" title="11">if metrics.TotalOperations &gt; 0 </span><span class="cov4" title="11">{
                metrics.SuccessRate = float64(metrics.SuccessfulOperations) / float64(metrics.TotalOperations) * 100
                metrics.FailureRate = float64(metrics.FailedOperations) / float64(metrics.TotalOperations) * 100
        }</span>

        <span class="cov4" title="11">return metrics</span>
}

// GetOperationMetrics returns metrics for a specific operation
func (rm *RetryManager) GetOperationMetrics(operationName, operationType string) *OperationMetrics <span class="cov1" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        operationKey := fmt.Sprintf("%s:%s", operationName, operationType)
        opMetrics, exists := rm.metrics.OperationMetrics[operationKey]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy
        <span class="cov1" title="1">return &amp;(*opMetrics)</span>
}

// ResetMetrics resets all metrics
func (rm *RetryManager) ResetMetrics() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        rm.metrics = &amp;RetryMetrics{
                RetriesByErrorType: make(map[ErrorType]uint64),
                RetriesByAttempt:   make(map[int]uint64),
                MinDuration:        time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
                MinBackoffTime:     time.Duration(^uint64(0) &gt;&gt; 1), // Max duration
                OperationMetrics:   make(map[string]*OperationMetrics),
        }
}</span>

// Background processes

// metricsLoop runs periodic metrics collection and logging
func (rm *RetryManager) metricsLoop() <span class="cov6" title="29">{
        defer rm.wg.Done()

        ticker := time.NewTicker(60 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov6" title="29">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov6" title="29">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rm.logMetrics()</span>
                }
        }
}

// logMetrics logs current metrics
func (rm *RetryManager) logMetrics() <span class="cov0" title="0">{
        if !rm.config.EnableLogging </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">metrics := rm.GetMetrics()

        rm.logger.Info("Retry manager metrics",
                "total_operations", metrics.TotalOperations,
                "successful_operations", metrics.SuccessfulOperations,
                "failed_operations", metrics.FailedOperations,
                "total_retries", metrics.TotalRetries,
                "success_rate", fmt.Sprintf("%.2f%%", metrics.SuccessRate),
                "failure_rate", fmt.Sprintf("%.2f%%", metrics.FailureRate),
                "average_retries_per_operation", fmt.Sprintf("%.2f", metrics.AverageRetriesPerOperation),
                "average_duration", metrics.AverageDuration,
                "average_backoff_time", metrics.AverageBackoffTime,
                "dead_letter_count", metrics.DeadLetterCount,
                "circuit_breaker_rejects", metrics.CircuitBreakerRejects,
        )</span>
}

// Logging methods

// logSuccess logs a successful operation
func (rm *RetryManager) logSuccess(config *RetryConfig, retryCtx *RetryContext) <span class="cov2" title="2">{
        if config.LogLevel == "debug" || config.LogLevel == "info" </span><span class="cov2" title="2">{
                rm.logger.Info("Operation completed successfully",
                        "operation_name", retryCtx.OperationName,
                        "operation_type", retryCtx.OperationType,
                        "attempts", retryCtx.Attempt,
                        "duration", retryCtx.TotalDuration,
                        "tags", retryCtx.Tags,
                )
        }</span>
}

// logRetryAttempt logs a retry attempt
func (rm *RetryManager) logRetryAttempt(config *RetryConfig, retryCtx *RetryContext, err error, backoffDelay time.Duration) <span class="cov0" title="0">{
        if config.LogLevel == "debug" || config.LogLevel == "info" </span><span class="cov0" title="0">{
                rm.logger.Warn("Retrying operation",
                        "operation_name", retryCtx.OperationName,
                        "operation_type", retryCtx.OperationType,
                        "attempt", retryCtx.Attempt,
                        "max_attempts", retryCtx.MaxAttempts,
                        "error", err.Error(),
                        "error_type", string(retryCtx.LastErrorType),
                        "backoff_delay", backoffDelay,
                        "strategy", config.Strategy.String(),
                        "tags", retryCtx.Tags,
                )
        }</span>
}

// logNonRetryableError logs a non-retryable error
func (rm *RetryManager) logNonRetryableError(config *RetryConfig, retryCtx *RetryContext, err error) <span class="cov0" title="0">{
        rm.logger.Error("Operation failed with non-retryable error",
                "operation_name", retryCtx.OperationName,
                "operation_type", retryCtx.OperationType,
                "attempt", retryCtx.Attempt,
                "error", err.Error(),
                "error_type", string(retryCtx.LastErrorType),
                "duration", retryCtx.TotalDuration,
                "tags", retryCtx.Tags,
        )
}</span>

// logAllAttemptsFailed logs when all retry attempts have failed
func (rm *RetryManager) logAllAttemptsFailed(config *RetryConfig, retryCtx *RetryContext, err error) <span class="cov0" title="0">{
        rm.logger.Error("Operation failed after all retry attempts",
                "operation_name", retryCtx.OperationName,
                "operation_type", retryCtx.OperationType,
                "total_attempts", retryCtx.Attempt,
                "max_attempts", retryCtx.MaxAttempts,
                "final_error", err.Error(),
                "error_type", string(retryCtx.LastErrorType),
                "total_duration", retryCtx.TotalDuration,
                "backoff_duration", retryCtx.BackoffDuration,
                "tags", retryCtx.Tags,
        )
}</span>

// Predefined retry configurations for different operation types

// DatabaseRetryConfig returns retry configuration for database operations
func DatabaseRetryConfig() *RetryConfig <span class="cov2" title="3">{
        return &amp;RetryConfig{
                MaxAttempts:          3,
                BaseDelay:            100 * time.Millisecond,
                MaxDelay:             5 * time.Second,
                Timeout:              30 * time.Second,
                Strategy:             StrategyExponentialBackoff,
                Multiplier:           2.0,
                JitterType:           JitterTypeFull,
                JitterMaxDeviation:   0.1,
                EnableCircuitBreaker: true,
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     true,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "info",
                OperationName:        "database",
                OperationType:        "query",
                Tags:                 map[string]string{"component": "database"},
        }
}</span>

// HTTPRetryConfig returns retry configuration for HTTP operations
func HTTPRetryConfig() *RetryConfig <span class="cov2" title="3">{
        return &amp;RetryConfig{
                MaxAttempts:          5,
                BaseDelay:            200 * time.Millisecond,
                MaxDelay:             10 * time.Second,
                Timeout:              60 * time.Second,
                Strategy:             StrategyExponentialBackoff,
                Multiplier:           2.0,
                JitterType:           JitterTypeEqual,
                JitterMaxDeviation:   0.1,
                EnableCircuitBreaker: true,
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout, ErrorTypeExternal, ErrorTypeRateLimit},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     true,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "info",
                OperationName:        "http",
                OperationType:        "request",
                Tags:                 map[string]string{"component": "http"},
        }
}</span>

// S3RetryConfig returns retry configuration for S3 operations
func S3RetryConfig() *RetryConfig <span class="cov2" title="2">{
        return &amp;RetryConfig{
                MaxAttempts:          4,
                BaseDelay:            500 * time.Millisecond,
                MaxDelay:             30 * time.Second,
                Timeout:              5 * time.Minute,
                Strategy:             StrategyExponentialBackoff,
                Multiplier:           2.0,
                JitterType:           JitterTypeFull,
                JitterMaxDeviation:   0.1,
                EnableCircuitBreaker: true,
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout, ErrorTypeExternal, ErrorTypeRateLimit},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     true,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "info",
                OperationName:        "s3",
                OperationType:        "upload",
                Tags:                 map[string]string{"component": "s3"},
        }
}</span>

// CacheRetryConfig returns retry configuration for cache operations
func CacheRetryConfig() *RetryConfig <span class="cov1" title="1">{
        return &amp;RetryConfig{
                MaxAttempts:          2,
                BaseDelay:            50 * time.Millisecond,
                MaxDelay:             1 * time.Second,
                Timeout:              5 * time.Second,
                Strategy:             StrategyFixedDelay,
                Multiplier:           1.0,
                JitterType:           JitterTypeNone,
                JitterMaxDeviation:   0.0,
                EnableCircuitBreaker: false, // Cache failures are less critical
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     false,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "warn",
                OperationName:        "cache",
                OperationType:        "get",
                Tags:                 map[string]string{"component": "cache"},
        }
}</span>

// KafkaRetryConfig returns retry configuration for Kafka operations
func KafkaRetryConfig() *RetryConfig <span class="cov1" title="1">{
        return &amp;RetryConfig{
                MaxAttempts:          5,
                BaseDelay:            1 * time.Second,
                MaxDelay:             30 * time.Second,
                Timeout:              2 * time.Minute,
                Strategy:             StrategyExponentialBackoff,
                Multiplier:           1.5,
                JitterType:           JitterTypeDecorrelated,
                JitterMaxDeviation:   0.1,
                EnableCircuitBreaker: true,
                RetryableErrors:      []ErrorType{ErrorTypeNetwork, ErrorTypeTimeout, ErrorTypeExternal},
                PermanentErrors:      []ErrorType{ErrorTypeValidation, ErrorTypeClient},
                EnableDeadLetter:     true,
                EnableMetrics:        true,
                EnableLogging:        true,
                LogLevel:             "info",
                OperationName:        "kafka",
                OperationType:        "produce",
                Tags:                 map[string]string{"component": "kafka"},
        }
}</span>

// RetryManagerPool manages multiple retry managers
type RetryManagerPool struct {
        managers map[string]*RetryManager
        mu       sync.RWMutex
        logger   *logger.Logger
}

// NewRetryManagerPool creates a new retry manager pool
func NewRetryManagerPool(logger *logger.Logger) *RetryManagerPool <span class="cov2" title="3">{
        return &amp;RetryManagerPool{
                managers: make(map[string]*RetryManager),
                logger:   logger,
        }
}</span>

// GetManager returns a retry manager for a specific operation type
func (pool *RetryManagerPool) GetManager(operationType string) *RetryManager <span class="cov4" title="7">{
        pool.mu.RLock()
        manager, exists := pool.managers[operationType]
        pool.mu.RUnlock()

        if exists </span><span class="cov2" title="2">{
                return manager
        }</span>

        <span class="cov3" title="5">pool.mu.Lock()
        defer pool.mu.Unlock()

        // Double-check pattern
        if manager, exists = pool.managers[operationType]; exists </span><span class="cov0" title="0">{
                return manager
        }</span>

        // Create new manager based on operation type
        <span class="cov3" title="5">var config *RetryConfig
        var circuitBreaker *CircuitBreaker

        switch operationType </span>{
        case "database":<span class="cov2" title="2">
                config = DatabaseRetryConfig()
                circuitBreaker = NewDatabaseCircuitBreaker(pool.logger)</span>
        case "http":<span class="cov2" title="2">
                config = HTTPRetryConfig()
                circuitBreaker = NewCircuitBreaker(DefaultCircuitBreakerConfig(), pool.logger)</span>
        case "s3":<span class="cov1" title="1">
                config = S3RetryConfig()
                circuitBreaker = NewS3CircuitBreaker(pool.logger)</span>
        case "cache":<span class="cov0" title="0">
                config = CacheRetryConfig()
                circuitBreaker = NewCacheCircuitBreaker(pool.logger)</span>
        case "kafka":<span class="cov0" title="0">
                config = KafkaRetryConfig()
                circuitBreaker = NewCircuitBreaker(DefaultCircuitBreakerConfig(), pool.logger)</span>
        default:<span class="cov0" title="0">
                config = DefaultRetryConfig()
                circuitBreaker = NewCircuitBreaker(DefaultCircuitBreakerConfig(), pool.logger)</span>
        }

        <span class="cov3" title="5">manager = NewRetryManager(config, circuitBreaker, pool.logger)
        pool.managers[operationType] = manager

        return manager</span>
}

// AddManager adds a custom retry manager to the pool
func (pool *RetryManagerPool) AddManager(operationType string, manager *RetryManager) <span class="cov1" title="1">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        pool.managers[operationType] = manager
}</span>

// GetAllManagers returns all retry managers
func (pool *RetryManagerPool) GetAllManagers() map[string]*RetryManager <span class="cov1" title="1">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        result := make(map[string]*RetryManager)
        for k, v := range pool.managers </span><span class="cov2" title="3">{
                result[k] = v
        }</span>

        <span class="cov1" title="1">return result</span>
}

// Close closes all retry managers
func (pool *RetryManagerPool) Close() <span class="cov2" title="3">{
        pool.mu.Lock()
        defer pool.mu.Unlock()

        for _, manager := range pool.managers </span><span class="cov3" title="6">{
                manager.Close()
        }</span>
}

// GetAggregatedMetrics returns aggregated metrics from all managers
func (pool *RetryManagerPool) GetAggregatedMetrics() map[string]*RetryMetrics <span class="cov1" title="1">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()

        metrics := make(map[string]*RetryMetrics)
        for operationType, manager := range pool.managers </span><span class="cov2" title="2">{
                metrics[operationType] = manager.GetMetrics()
        }</span>

        <span class="cov1" title="1">return metrics</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package infrastructure

import (
        "context"
        "io"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/domain"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// S3ClientWrapper implements domain.S3Client using AWS SDK v2
type S3ClientWrapper struct {
        client *s3.Client
        logger *logger.Logger
}

// NewS3ClientWrapper creates a new S3 client wrapper
func NewS3ClientWrapper(client *s3.Client, logger *logger.Logger) domain.S3Client <span class="cov0" title="0">{
        return &amp;S3ClientWrapper{
                client: client,
                logger: logger,
        }
}</span>

// UploadFile uploads a file to S3
func (s *S3ClientWrapper) UploadFile(ctx context.Context, bucket, key string, body io.Reader, contentType string) error <span class="cov0" title="0">{
        _, err := s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:      aws.String(bucket),
                Key:         aws.String(key),
                Body:        body,
                ContentType: aws.String(contentType),
        })
        return err
}</span>

// DownloadFile downloads a file from S3
func (s *S3ClientWrapper) DownloadFile(ctx context.Context, bucket, key string) (io.ReadCloser, error) <span class="cov0" title="0">{
        output, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return output.Body, nil</span>
}

// GetFileURL generates a presigned URL for a file
func (s *S3ClientWrapper) GetFileURL(ctx context.Context, bucket, key string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        // For simplicity, return a direct URL - in real implementation this would be presigned
        return "s3://" + bucket + "/" + key, nil
}</span>

// DeleteFile deletes a file from S3
func (s *S3ClientWrapper) DeleteFile(ctx context.Context, bucket, key string) error <span class="cov0" title="0">{
        _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        return err
}</span>

// ListFiles lists files in S3
func (s *S3ClientWrapper) ListFiles(ctx context.Context, bucket, prefix string, limit int) ([]string, error) <span class="cov0" title="0">{
        input := &amp;s3.ListObjectsV2Input{
                Bucket:  aws.String(bucket),
                Prefix:  aws.String(prefix),
                MaxKeys: aws.Int32(int32(limit)),
        }

        output, err := s.client.ListObjectsV2(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []string
        for _, object := range output.Contents </span><span class="cov0" title="0">{
                files = append(files, *object.Key)
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// GetFileMetadata gets metadata for a file
func (s *S3ClientWrapper) GetFileMetadata(ctx context.Context, bucket, key string) (map[string]string, error) <span class="cov0" title="0">{
        output, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := make(map[string]string)
        for k, v := range output.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

// UpdateFileMetadata updates metadata for a file
func (s *S3ClientWrapper) UpdateFileMetadata(ctx context.Context, bucket, key string, metadata map[string]string) error <span class="cov0" title="0">{
        // Copy object with new metadata
        copySource := bucket + "/" + key
        _, err := s.client.CopyObject(ctx, &amp;s3.CopyObjectInput{
                Bucket:     aws.String(bucket),
                Key:        aws.String(key),
                CopySource: aws.String(copySource),
                Metadata:   metadata,
        })
        return err
}</span>

// CreateBucket creates a new S3 bucket
func (s *S3ClientWrapper) CreateBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        _, err := s.client.CreateBucket(ctx, &amp;s3.CreateBucketInput{
                Bucket: aws.String(bucket),
        })
        return err
}</span>

// DeleteBucket deletes an S3 bucket
func (s *S3ClientWrapper) DeleteBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        _, err := s.client.DeleteBucket(ctx, &amp;s3.DeleteBucketInput{
                Bucket: aws.String(bucket),
        })
        return err
}</span>

// BucketExists checks if a bucket exists
func (s *S3ClientWrapper) BucketExists(ctx context.Context, bucket string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadBucket(ctx, &amp;s3.HeadBucketInput{
                Bucket: aws.String(bucket),
        })
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "NotFound") </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// FileExists checks if a file exists
func (s *S3ClientWrapper) FileExists(ctx context.Context, bucket, key string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "NotFound") </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// GetFileSize gets the size of a file
func (s *S3ClientWrapper) GetFileSize(ctx context.Context, bucket, key string) (int64, error) <span class="cov0" title="0">{
        output, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if output.ContentLength != nil </span><span class="cov0" title="0">{
                return *output.ContentLength, nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package infrastructure

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/feature/s3/manager"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        "github.com/aws/smithy-go"

        pkgConfig "github.com/gkbiswas/hotel-reviews-microservice/pkg/config"
        "github.com/gkbiswas/hotel-reviews-microservice/pkg/logger"
)

// S3Client represents the S3 client wrapper
type S3Client struct {
        client     *s3.Client
        uploader   *manager.Uploader
        downloader *manager.Downloader
        config     *pkgConfig.S3Config
        logger     *logger.Logger
}

// ObjectInfo represents S3 object information
type ObjectInfo struct {
        Key          string
        Size         int64
        LastModified time.Time
        ETag         string
        StorageClass string
        ContentType  string
}

// ListObjectsResult represents the result of listing objects
type ListObjectsResult struct {
        Objects        []ObjectInfo
        NextToken      *string
        IsTruncated    bool
        CommonPrefixes []string
}

// DownloadResult represents the result of downloading an object
type DownloadResult struct {
        Body          io.ReadCloser
        ContentLength int64
        ContentType   string
        LastModified  time.Time
        ETag          string
        Metadata      map[string]string
}

// NewS3Client creates a new S3 client
func NewS3Client(cfg *pkgConfig.S3Config, log *logger.Logger) (*S3Client, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Create AWS config
        awsConfig, err := createAWSConfig(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AWS config: %w", err)
        }</span>

        // Create S3 client
        <span class="cov0" title="0">s3Client := s3.NewFromConfig(awsConfig, func(o *s3.Options) </span><span class="cov0" title="0">{
                if cfg.Endpoint != "" </span><span class="cov0" title="0">{
                        o.BaseEndpoint = aws.String(cfg.Endpoint)
                }</span>
                <span class="cov0" title="0">o.UsePathStyle = cfg.ForcePathStyle</span>
        })

        // Create uploader and downloader with custom configurations
        <span class="cov0" title="0">uploader := manager.NewUploader(s3Client, func(u *manager.Uploader) </span><span class="cov0" title="0">{
                u.PartSize = cfg.UploadPartSize
                u.Concurrency = 5
        }</span>)

        <span class="cov0" title="0">downloader := manager.NewDownloader(s3Client, func(d *manager.Downloader) </span><span class="cov0" title="0">{
                d.PartSize = cfg.DownloadPartSize
                d.Concurrency = 5
        }</span>)

        <span class="cov0" title="0">client := &amp;S3Client{
                client:     s3Client,
                uploader:   uploader,
                downloader: downloader,
                config:     cfg,
                logger:     log,
        }

        // Test connection
        if err := client.testConnection(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("S3 connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("S3 client initialized successfully",
                "region", cfg.Region,
                "bucket", cfg.Bucket,
                "endpoint", cfg.Endpoint,
        )

        return client, nil</span>
}

// createAWSConfig creates AWS configuration
func createAWSConfig(ctx context.Context, cfg *pkgConfig.S3Config) (aws.Config, error) <span class="cov0" title="0">{
        var awsConfig aws.Config
        var err error

        if cfg.AccessKeyID != "" &amp;&amp; cfg.SecretAccessKey != "" </span><span class="cov0" title="0">{
                // Use static credentials
                credProvider := credentials.NewStaticCredentialsProvider(
                        cfg.AccessKeyID,
                        cfg.SecretAccessKey,
                        cfg.SessionToken,
                )

                awsConfig, err = config.LoadDefaultConfig(ctx,
                        config.WithRegion(cfg.Region),
                        config.WithCredentialsProvider(credProvider),
                )
        }</span> else<span class="cov0" title="0"> {
                // Use default credential chain (IAM roles, environment variables, etc.)
                awsConfig, err = config.LoadDefaultConfig(ctx,
                        config.WithRegion(cfg.Region),
                )
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return aws.Config{}, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        <span class="cov0" title="0">return awsConfig, nil</span>
}

// testConnection tests the S3 connection
func (s *S3Client) testConnection(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, s.config.Timeout)
        defer cancel()

        // Try to get bucket location
        _, err := s.client.GetBucketLocation(ctx, &amp;s3.GetBucketLocationInput{
                Bucket: aws.String(s.config.Bucket),
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get bucket location: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UploadFile uploads a file to S3
func (s *S3Client) UploadFile(ctx context.Context, bucket, key string, body io.Reader, contentType string) error <span class="cov0" title="0">{
        start := time.Now()

        input := &amp;s3.PutObjectInput{
                Bucket:      aws.String(bucket),
                Key:         aws.String(key),
                Body:        body,
                ContentType: aws.String(contentType),
        }

        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.uploader.Upload(ctx, input)
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to upload file to S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File uploaded to S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// DownloadFile downloads a file from S3
func (s *S3Client) DownloadFile(ctx context.Context, bucket, key string) (io.ReadCloser, error) <span class="cov0" title="0">{
        start := time.Now()

        // Get object metadata first
        headOutput, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object metadata: %w", err)
        }</span>

        // Create a streaming downloader
        <span class="cov0" title="0">getOutput, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File download from S3 started",
                "bucket", bucket,
                "key", key,
                "size", headOutput.ContentLength,
                "duration_ms", duration.Milliseconds(),
        )

        return getOutput.Body, nil</span>
}

// GetFileURL generates a presigned URL for file access
func (s *S3Client) GetFileURL(ctx context.Context, bucket, key string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        presignClient := s3.NewPresignClient(s.client)

        request, err := presignClient.PresignGetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        }, func(opts *s3.PresignOptions) </span><span class="cov0" title="0">{
                opts.Expires = expiration
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.DebugContext(ctx, "Generated presigned URL",
                "bucket", bucket,
                "key", key,
                "expiration", expiration,
        )

        return request.URL, nil</span>
}

// DeleteFile deletes a file from S3
func (s *S3Client) DeleteFile(ctx context.Context, bucket, key string) error <span class="cov0" title="0">{
        start := time.Now()

        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to delete file from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File deleted from S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// ListFiles lists files in S3 bucket with pagination support
func (s *S3Client) ListFiles(ctx context.Context, bucket, prefix string, limit int) ([]string, error) <span class="cov0" title="0">{
        result, err := s.ListObjects(ctx, bucket, prefix, "", limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">files := make([]string, len(result.Objects))
        for i, obj := range result.Objects </span><span class="cov0" title="0">{
                files[i] = obj.Key
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// ListObjects lists objects in S3 bucket with detailed information and pagination
func (s *S3Client) ListObjects(ctx context.Context, bucket, prefix, continuationToken string, maxKeys int) (*ListObjectsResult, error) <span class="cov0" title="0">{
        start := time.Now()

        input := &amp;s3.ListObjectsV2Input{
                Bucket:  aws.String(bucket),
                Prefix:  aws.String(prefix),
                MaxKeys: aws.Int32(int32(maxKeys)),
        }

        if continuationToken != "" </span><span class="cov0" title="0">{
                input.ContinuationToken = aws.String(continuationToken)
        }</span>

        <span class="cov0" title="0">var output *s3.ListObjectsV2Output
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                output, err = s.client.ListObjectsV2(ctx, input)
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to list objects in S3",
                        "bucket", bucket,
                        "prefix", prefix,
                        "error", err,
                )
                return nil, fmt.Errorf("failed to list objects: %w", err)
        }</span>

        // Convert to ObjectInfo slice
        <span class="cov0" title="0">objects := make([]ObjectInfo, len(output.Contents))
        for i, obj := range output.Contents </span><span class="cov0" title="0">{
                objects[i] = ObjectInfo{
                        Key:          aws.ToString(obj.Key),
                        Size:         aws.ToInt64(obj.Size),
                        LastModified: aws.ToTime(obj.LastModified),
                        ETag:         aws.ToString(obj.ETag),
                        StorageClass: string(obj.StorageClass),
                }
        }</span>

        // Extract common prefixes
        <span class="cov0" title="0">commonPrefixes := make([]string, len(output.CommonPrefixes))
        for i, cp := range output.CommonPrefixes </span><span class="cov0" title="0">{
                commonPrefixes[i] = aws.ToString(cp.Prefix)
        }</span>

        <span class="cov0" title="0">result := &amp;ListObjectsResult{
                Objects:        objects,
                IsTruncated:    aws.ToBool(output.IsTruncated),
                CommonPrefixes: commonPrefixes,
        }

        if output.NextContinuationToken != nil </span><span class="cov0" title="0">{
                result.NextToken = output.NextContinuationToken
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "Objects listed successfully",
                "bucket", bucket,
                "prefix", prefix,
                "count", len(objects),
                "is_truncated", result.IsTruncated,
                "duration_ms", duration.Milliseconds(),
        )

        return result, nil</span>
}

// GetFileMetadata gets file metadata from S3
func (s *S3Client) GetFileMetadata(ctx context.Context, bucket, key string) (map[string]string, error) <span class="cov0" title="0">{
        start := time.Now()

        var output *s3.HeadObjectOutput
        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                output, err = s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to get file metadata from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return nil, fmt.Errorf("failed to get file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">metadata := make(map[string]string)

        // Add standard metadata
        metadata["content-type"] = aws.ToString(output.ContentType)
        metadata["content-length"] = fmt.Sprintf("%d", output.ContentLength)
        metadata["last-modified"] = aws.ToTime(output.LastModified).Format(time.RFC3339)
        metadata["etag"] = aws.ToString(output.ETag)

        if output.StorageClass != "" </span><span class="cov0" title="0">{
                metadata["storage-class"] = string(output.StorageClass)
        }</span>

        // Add custom metadata
        <span class="cov0" title="0">for k, v := range output.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.DebugContext(ctx, "File metadata retrieved successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return metadata, nil</span>
}

// UpdateFileMetadata updates file metadata in S3
func (s *S3Client) UpdateFileMetadata(ctx context.Context, bucket, key string, metadata map[string]string) error <span class="cov0" title="0">{
        start := time.Now()

        // First get the current object
        getOutput, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get object for metadata update: %w", err)
        }</span>
        <span class="cov0" title="0">defer getOutput.Body.Close()

        // Prepare metadata for update
        s3Metadata := make(map[string]string)
        var contentType string

        for k, v := range metadata </span><span class="cov0" title="0">{
                if k == "content-type" </span><span class="cov0" title="0">{
                        contentType = v
                }</span> else<span class="cov0" title="0"> {
                        s3Metadata[k] = v
                }</span>
        }

        // Copy object with new metadata
        <span class="cov0" title="0">err = s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.CopyObject(ctx, &amp;s3.CopyObjectInput{
                        Bucket:            aws.String(bucket),
                        Key:               aws.String(key),
                        CopySource:        aws.String(fmt.Sprintf("%s/%s", bucket, key)),
                        Metadata:          s3Metadata,
                        MetadataDirective: types.MetadataDirectiveReplace,
                        ContentType:       aws.String(contentType),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to update file metadata in S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to update file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File metadata updated successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// CreateBucket creates a new S3 bucket
func (s *S3Client) CreateBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        start := time.Now()

        input := &amp;s3.CreateBucketInput{
                Bucket: aws.String(bucket),
        }

        // Add location constraint if not in us-east-1
        if s.config.Region != "us-east-1" </span><span class="cov0" title="0">{
                input.CreateBucketConfiguration = &amp;types.CreateBucketConfiguration{
                        LocationConstraint: types.BucketLocationConstraint(s.config.Region),
                }
        }</span>

        <span class="cov0" title="0">err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.CreateBucket(ctx, input)
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to create S3 bucket",
                        "bucket", bucket,
                        "error", err,
                )
                return fmt.Errorf("failed to create bucket: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "S3 bucket created successfully",
                "bucket", bucket,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// DeleteBucket deletes an S3 bucket
func (s *S3Client) DeleteBucket(ctx context.Context, bucket string) error <span class="cov0" title="0">{
        start := time.Now()

        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.client.DeleteBucket(ctx, &amp;s3.DeleteBucketInput{
                        Bucket: aws.String(bucket),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to delete S3 bucket",
                        "bucket", bucket,
                        "error", err,
                )
                return fmt.Errorf("failed to delete bucket: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "S3 bucket deleted successfully",
                "bucket", bucket,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// BucketExists checks if a bucket exists
func (s *S3Client) BucketExists(ctx context.Context, bucket string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadBucket(ctx, &amp;s3.HeadBucketInput{
                Bucket: aws.String(bucket),
        })

        if err != nil </span><span class="cov0" title="0">{
                var apiErr smithy.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        if apiErr.ErrorCode() == "NotFound" </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check bucket existence: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// FileExists checks if a file exists in S3
func (s *S3Client) FileExists(ctx context.Context, bucket, key string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })

        if err != nil </span><span class="cov0" title="0">{
                var apiErr smithy.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        if apiErr.ErrorCode() == "NotFound" </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check file existence: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// GetFileSize gets the size of a file in S3
func (s *S3Client) GetFileSize(ctx context.Context, bucket, key string) (int64, error) <span class="cov0" title="0">{
        output, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get file size: %w", err)
        }</span>

        <span class="cov0" title="0">return aws.ToInt64(output.ContentLength), nil</span>
}

// retryOperation performs an operation with retry logic
func (s *S3Client) retryOperation(ctx context.Context, operation func() error) error <span class="cov9" title="105">{
        var lastErr error

        for attempt := 0; attempt &lt;= s.config.RetryCount; attempt++ </span><span class="cov10" title="112">{
                if attempt &gt; 0 </span><span class="cov4" title="7">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return ctx.Err()</span>
                        case &lt;-time.After(s.config.RetryDelay * time.Duration(attempt)):<span class="cov4" title="6"></span>
                                // Exponential backoff
                        }
                }

                <span class="cov9" title="111">err := operation()
                if err == nil </span><span class="cov9" title="102">{
                        return nil
                }</span>

                <span class="cov5" title="9">lastErr = err

                // Check if error is retryable
                if !s.isRetryableError(err) </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov4" title="8">s.logger.WarnContext(ctx, "S3 operation failed, retrying...",
                        "attempt", attempt+1,
                        "max_retries", s.config.RetryCount,
                        "error", err,
                )</span>
        }

        <span class="cov2" title="2">return lastErr</span>
}

// isRetryableError checks if an error is retryable
func (s *S3Client) isRetryableError(err error) bool <span class="cov7" title="27">{
        if err == nil </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov7" title="25">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov6" title="23">{
                errorCode := apiErr.ErrorCode()

                // Common retryable errors
                retryableErrors := []string{
                        "InternalError",
                        "ServiceUnavailable",
                        "SlowDown",
                        "RequestTimeout",
                        "ThrottlingException",
                }

                for _, retryable := range retryableErrors </span><span class="cov9" title="85">{
                        if errorCode == retryable </span><span class="cov5" title="13">{
                                return true
                        }</span>
                }

                // HTTP 5xx errors are generally retryable
                <span class="cov5" title="10">if strings.HasPrefix(errorCode, "5") </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov5" title="10">return false</span>
}

// DownloadToWriter downloads a file from S3 to a writer (streaming)
func (s *S3Client) DownloadToWriter(ctx context.Context, bucket, key string, writer io.WriterAt) error <span class="cov0" title="0">{
        start := time.Now()

        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.downloader.Download(ctx, writer, &amp;s3.GetObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to download file from S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to download file: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File downloaded from S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}

// UploadFromReader uploads a file to S3 from a reader (streaming)
func (s *S3Client) UploadFromReader(ctx context.Context, bucket, key string, reader io.Reader, contentType string) error <span class="cov0" title="0">{
        start := time.Now()

        err := s.retryOperation(ctx, func() error </span><span class="cov0" title="0">{
                _, err := s.uploader.Upload(ctx, &amp;s3.PutObjectInput{
                        Bucket:      aws.String(bucket),
                        Key:         aws.String(key),
                        Body:        reader,
                        ContentType: aws.String(contentType),
                })
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Failed to upload file to S3",
                        "bucket", bucket,
                        "key", key,
                        "error", err,
                )
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        s.logger.InfoContext(ctx, "File uploaded to S3 successfully",
                "bucket", bucket,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package monitoring

import (
        "context"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/sirupsen/logrus"
)

// BusinessMetrics tracks hotel reviews specific business metrics
type BusinessMetrics struct {
        // Review processing metrics
        ReviewsIngested          *prometheus.CounterVec
        ReviewsValidated         *prometheus.CounterVec
        ReviewsStored            *prometheus.CounterVec
        ReviewsRejected          *prometheus.CounterVec
        ReviewsDeduplicationHits *prometheus.CounterVec

        // File processing metrics
        FilesProcessed     *prometheus.CounterVec
        FileProcessingTime *prometheus.HistogramVec
        FileSize           *prometheus.HistogramVec
        RecordsPerFile     *prometheus.HistogramVec

        // Provider metrics
        ProviderRequestsTotal *prometheus.CounterVec
        ProviderResponseTime  *prometheus.HistogramVec
        ProviderErrors        *prometheus.CounterVec
        ProviderDataQuality   *prometheus.GaugeVec

        // Hotel metrics
        HotelsTotal          *prometheus.GaugeVec
        HotelsWithReviews    *prometheus.GaugeVec
        AverageRatingByHotel *prometheus.GaugeVec
        ReviewCountByHotel   *prometheus.GaugeVec

        // Data quality metrics
        DataQualityScore   *prometheus.GaugeVec
        MissingFieldsCount *prometheus.CounterVec
        InvalidDataCount   *prometheus.CounterVec
        DataCompleteness   *prometheus.GaugeVec

        // User engagement metrics
        ReviewsPerUser              *prometheus.HistogramVec
        UserActivityPattern         *prometheus.CounterVec
        ReviewSentimentDistribution *prometheus.CounterVec

        // Business KPIs
        ReviewVelocity            *prometheus.GaugeVec
        ReviewBacklog             *prometheus.GaugeVec
        DataFreshness             *prometheus.GaugeVec
        CustomerSatisfactionScore *prometheus.GaugeVec

        // Operational metrics
        ProcessingCapacity    *prometheus.GaugeVec
        ProcessingUtilization *prometheus.GaugeVec
        QueueDepth            *prometheus.GaugeVec
        ErrorRate             *prometheus.GaugeVec

        logger *logrus.Logger
}

// NewBusinessMetrics creates a new business metrics collector
func NewBusinessMetrics(logger *logrus.Logger, registry *prometheus.Registry) *BusinessMetrics <span class="cov4" title="6">{
        factory := promauto.With(registry)
        return &amp;BusinessMetrics{
                // Review processing metrics
                ReviewsIngested: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_ingested_total",
                                Help: "Total number of reviews ingested",
                        },
                        []string{"provider", "hotel_id", "source"},
                ),
                ReviewsValidated: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_validated_total",
                                Help: "Total number of reviews validated",
                        },
                        []string{"provider", "validation_status"},
                ),
                ReviewsStored: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_stored_total",
                                Help: "Total number of reviews stored successfully",
                        },
                        []string{"provider", "hotel_id"},
                ),
                ReviewsRejected: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_rejected_total",
                                Help: "Total number of reviews rejected",
                        },
                        []string{"provider", "rejection_reason"},
                ),
                ReviewsDeduplicationHits: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_deduplication_hits_total",
                                Help: "Total number of duplicate reviews detected",
                        },
                        []string{"provider", "deduplication_type"},
                ),

                // File processing metrics
                FilesProcessed: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_files_processed_total",
                                Help: "Total number of files processed",
                        },
                        []string{"provider", "file_type", "status"},
                ),
                FileProcessingTime: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_file_processing_duration_seconds",
                                Help:    "Time taken to process a file",
                                Buckets: prometheus.ExponentialBuckets(1, 2, 12), // 1s to ~1h
                        },
                        []string{"provider", "file_type"},
                ),
                FileSize: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_file_size_bytes",
                                Help:    "Size of processed files in bytes",
                                Buckets: prometheus.ExponentialBuckets(1024, 10, 8), // 1KB to ~1GB
                        },
                        []string{"provider", "file_type"},
                ),
                RecordsPerFile: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_records_per_file",
                                Help:    "Number of records in each processed file",
                                Buckets: prometheus.ExponentialBuckets(100, 10, 6), // 100 to 100M
                        },
                        []string{"provider", "file_type"},
                ),

                // Provider metrics
                ProviderRequestsTotal: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_provider_requests_total",
                                Help: "Total number of requests to providers",
                        },
                        []string{"provider", "operation", "status"},
                ),
                ProviderResponseTime: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_provider_response_time_seconds",
                                Help:    "Response time for provider requests",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"provider", "operation"},
                ),
                ProviderErrors: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_provider_errors_total",
                                Help: "Total number of provider errors",
                        },
                        []string{"provider", "error_type"},
                ),
                ProviderDataQuality: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_provider_data_quality_score",
                                Help: "Data quality score for each provider (0-1)",
                        },
                        []string{"provider", "metric_type"},
                ),

                // Hotel metrics
                HotelsTotal: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_hotels_total",
                                Help: "Total number of hotels in the system",
                        },
                        []string{"provider", "location"},
                ),
                HotelsWithReviews: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_hotels_with_reviews",
                                Help: "Number of hotels that have reviews",
                        },
                        []string{"provider", "location"},
                ),
                AverageRatingByHotel: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_average_rating_by_hotel",
                                Help: "Average rating for each hotel",
                        },
                        []string{"provider", "hotel_id"},
                ),
                ReviewCountByHotel: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_count_by_hotel",
                                Help: "Number of reviews for each hotel",
                        },
                        []string{"provider", "hotel_id"},
                ),

                // Data quality metrics
                DataQualityScore: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_data_quality_score",
                                Help: "Overall data quality score (0-1)",
                        },
                        []string{"provider", "dimension"},
                ),
                MissingFieldsCount: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_missing_fields_total",
                                Help: "Total number of missing fields in reviews",
                        },
                        []string{"provider", "field_name"},
                ),
                InvalidDataCount: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_invalid_data_total",
                                Help: "Total number of invalid data entries",
                        },
                        []string{"provider", "field_name", "validation_rule"},
                ),
                DataCompleteness: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_data_completeness",
                                Help: "Data completeness percentage for each field",
                        },
                        []string{"provider", "field_name"},
                ),

                // User engagement metrics
                ReviewsPerUser: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_per_user",
                                Help:    "Number of reviews per user",
                                Buckets: prometheus.ExponentialBuckets(1, 2, 10),
                        },
                        []string{"provider"},
                ),
                UserActivityPattern: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_user_activity_pattern",
                                Help: "User activity patterns",
                        },
                        []string{"provider", "time_period", "activity_type"},
                ),
                ReviewSentimentDistribution: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_sentiment_distribution",
                                Help: "Distribution of review sentiments",
                        },
                        []string{"provider", "sentiment", "rating_range"},
                ),

                // Business KPIs
                ReviewVelocity: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_velocity_per_hour",
                                Help: "Number of reviews processed per hour",
                        },
                        []string{"provider"},
                ),
                ReviewBacklog: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_backlog_count",
                                Help: "Number of reviews waiting to be processed",
                        },
                        []string{"provider", "priority"},
                ),
                DataFreshness: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_data_freshness_hours",
                                Help: "Age of the latest data in hours",
                        },
                        []string{"provider", "data_type"},
                ),
                CustomerSatisfactionScore: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_customer_satisfaction_score",
                                Help: "Customer satisfaction score based on reviews",
                        },
                        []string{"provider", "hotel_id", "time_period"},
                ),

                // Operational metrics
                ProcessingCapacity: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_processing_capacity",
                                Help: "Maximum processing capacity",
                        },
                        []string{"component", "resource_type"},
                ),
                ProcessingUtilization: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_processing_utilization",
                                Help: "Current processing utilization percentage",
                        },
                        []string{"component", "resource_type"},
                ),
                QueueDepth: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_queue_depth",
                                Help: "Current queue depth",
                        },
                        []string{"queue_type", "priority"},
                ),
                ErrorRate: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_error_rate",
                                Help: "Error rate percentage",
                        },
                        []string{"component", "error_type"},
                ),

                logger: logger,
        }
}</span>

// RecordReviewIngestion records review ingestion metrics
func (m *BusinessMetrics) RecordReviewIngestion(provider, hotelID, source string) <span class="cov10" title="101">{
        m.ReviewsIngested.WithLabelValues(provider, hotelID, source).Inc()
}</span>

// RecordReviewValidation records review validation metrics
func (m *BusinessMetrics) RecordReviewValidation(provider, validationStatus string) <span class="cov0" title="0">{
        m.ReviewsValidated.WithLabelValues(provider, validationStatus).Inc()
}</span>

// RecordReviewStorage records review storage metrics
func (m *BusinessMetrics) RecordReviewStorage(provider, hotelID string) <span class="cov0" title="0">{
        m.ReviewsStored.WithLabelValues(provider, hotelID).Inc()
}</span>

// RecordReviewRejection records review rejection metrics
func (m *BusinessMetrics) RecordReviewRejection(provider, rejectionReason string) <span class="cov0" title="0">{
        m.ReviewsRejected.WithLabelValues(provider, rejectionReason).Inc()
}</span>

// RecordFileProcessing records file processing metrics
func (m *BusinessMetrics) RecordFileProcessing(provider, fileType, status string, duration time.Duration, fileSize int64, recordCount int) <span class="cov0" title="0">{
        m.FilesProcessed.WithLabelValues(provider, fileType, status).Inc()
        m.FileProcessingTime.WithLabelValues(provider, fileType).Observe(duration.Seconds())
        m.FileSize.WithLabelValues(provider, fileType).Observe(float64(fileSize))
        m.RecordsPerFile.WithLabelValues(provider, fileType).Observe(float64(recordCount))
}</span>

// RecordProviderRequest records provider request metrics
func (m *BusinessMetrics) RecordProviderRequest(provider, operation, status string, duration time.Duration) <span class="cov0" title="0">{
        m.ProviderRequestsTotal.WithLabelValues(provider, operation, status).Inc()
        m.ProviderResponseTime.WithLabelValues(provider, operation).Observe(duration.Seconds())
}</span>

// RecordProviderError records provider error metrics
func (m *BusinessMetrics) RecordProviderError(provider, errorType string) <span class="cov0" title="0">{
        m.ProviderErrors.WithLabelValues(provider, errorType).Inc()
}</span>

// UpdateDataQuality updates data quality metrics
func (m *BusinessMetrics) UpdateDataQuality(provider, dimension string, score float64) <span class="cov0" title="0">{
        m.DataQualityScore.WithLabelValues(provider, dimension).Set(score)
}</span>

// RecordMissingField records missing field metrics
func (m *BusinessMetrics) RecordMissingField(provider, fieldName string) <span class="cov0" title="0">{
        m.MissingFieldsCount.WithLabelValues(provider, fieldName).Inc()
}</span>

// RecordInvalidData records invalid data metrics
func (m *BusinessMetrics) RecordInvalidData(provider, fieldName, validationRule string) <span class="cov0" title="0">{
        m.InvalidDataCount.WithLabelValues(provider, fieldName, validationRule).Inc()
}</span>

// UpdateDataCompleteness updates data completeness metrics
func (m *BusinessMetrics) UpdateDataCompleteness(provider, fieldName string, completeness float64) <span class="cov0" title="0">{
        m.DataCompleteness.WithLabelValues(provider, fieldName).Set(completeness)
}</span>

// UpdateHotelMetrics updates hotel-related metrics
func (m *BusinessMetrics) UpdateHotelMetrics(provider, hotelID, location string, totalHotels, hotelsWithReviews int, avgRating float64, reviewCount int) <span class="cov0" title="0">{
        m.HotelsTotal.WithLabelValues(provider, location).Set(float64(totalHotels))
        m.HotelsWithReviews.WithLabelValues(provider, location).Set(float64(hotelsWithReviews))
        m.AverageRatingByHotel.WithLabelValues(provider, hotelID).Set(avgRating)
        m.ReviewCountByHotel.WithLabelValues(provider, hotelID).Set(float64(reviewCount))
}</span>

// RecordUserActivity records user activity metrics
func (m *BusinessMetrics) RecordUserActivity(provider, timePeriod, activityType string) <span class="cov0" title="0">{
        m.UserActivityPattern.WithLabelValues(provider, timePeriod, activityType).Inc()
}</span>

// RecordReviewSentiment records review sentiment metrics
func (m *BusinessMetrics) RecordReviewSentiment(provider, sentiment, ratingRange string) <span class="cov0" title="0">{
        m.ReviewSentimentDistribution.WithLabelValues(provider, sentiment, ratingRange).Inc()
}</span>

// UpdateBusinessKPIs updates business KPI metrics
func (m *BusinessMetrics) UpdateBusinessKPIs(provider, hotelID, timePeriod string, velocity, backlog, freshness, satisfaction float64) <span class="cov0" title="0">{
        m.ReviewVelocity.WithLabelValues(provider).Set(velocity)
        m.ReviewBacklog.WithLabelValues(provider, "normal").Set(backlog)
        m.DataFreshness.WithLabelValues(provider, "reviews").Set(freshness)
        m.CustomerSatisfactionScore.WithLabelValues(provider, hotelID, timePeriod).Set(satisfaction)
}</span>

// UpdateOperationalMetrics updates operational metrics
func (m *BusinessMetrics) UpdateOperationalMetrics(component, resourceType string, capacity, utilization float64) <span class="cov0" title="0">{
        m.ProcessingCapacity.WithLabelValues(component, resourceType).Set(capacity)
        m.ProcessingUtilization.WithLabelValues(component, resourceType).Set(utilization)
}</span>

// UpdateQueueDepth updates queue depth metrics
func (m *BusinessMetrics) UpdateQueueDepth(queueType, priority string, depth float64) <span class="cov0" title="0">{
        m.QueueDepth.WithLabelValues(queueType, priority).Set(depth)
}</span>

// UpdateErrorRate updates error rate metrics
func (m *BusinessMetrics) UpdateErrorRate(component, errorType string, rate float64) <span class="cov0" title="0">{
        m.ErrorRate.WithLabelValues(component, errorType).Set(rate)
}</span>

// StartBusinessMetricsCollection starts periodic collection of business metrics
func (m *BusinessMetrics) StartBusinessMetricsCollection(ctx context.Context) <span class="cov1" title="1">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        go func() </span><span class="cov1" title="1">{
                for </span><span class="cov1" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                m.collectBusinessMetrics(ctx)</span>
                        }
                }
        }()
}

// collectBusinessMetrics collects business metrics from the system
func (m *BusinessMetrics) collectBusinessMetrics(ctx context.Context) <span class="cov0" title="0">{
        // This would typically query the database and other systems
        // to collect current business metrics

        // For demonstration, we'll update some sample metrics
        m.logger.Debug("Collecting business metrics")

        // Update some sample operational metrics
        m.UpdateOperationalMetrics("processing_engine", "cpu", 100.0, 75.0)
        m.UpdateOperationalMetrics("processing_engine", "memory", 8192.0, 6144.0)
        m.UpdateQueueDepth("file_processing", "normal", 50.0)
        m.UpdateQueueDepth("file_processing", "high", 10.0)

        // Update some sample data quality metrics
        m.UpdateDataQuality("booking", "completeness", 0.95)
        m.UpdateDataQuality("booking", "accuracy", 0.92)
        m.UpdateDataQuality("expedia", "completeness", 0.88)
        m.UpdateDataQuality("expedia", "accuracy", 0.90)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package monitoring

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

// HealthStatus represents the health status of a component
type HealthStatus string

const (
        HealthStatusHealthy   HealthStatus = "healthy"
        HealthStatusUnhealthy HealthStatus = "unhealthy"
        HealthStatusUnknown   HealthStatus = "unknown"
)

// HealthCheckResult represents the result of a health check
type HealthCheckResult struct {
        Status       HealthStatus           `json:"status"`
        Message      string                 `json:"message"`
        Timestamp    time.Time              `json:"timestamp"`
        ResponseTime time.Duration          `json:"response_time"`
        Details      map[string]interface{} `json:"details,omitempty"`
}

// HealthChecker interface for health checks
type HealthChecker interface {
        Check(ctx context.Context) HealthCheckResult
        Name() string
}

// DatabaseHealthChecker checks database health
type DatabaseHealthChecker struct {
        db     *gorm.DB
        name   string
        logger *logrus.Logger
}

// NewDatabaseHealthChecker creates a new database health checker
func NewDatabaseHealthChecker(db *gorm.DB, name string, logger *logrus.Logger) *DatabaseHealthChecker <span class="cov3" title="2">{
        return &amp;DatabaseHealthChecker{
                db:     db,
                name:   name,
                logger: logger,
        }
}</span>

// Name returns the name of the health checker
func (h *DatabaseHealthChecker) Name() string <span class="cov1" title="1">{
        return h.name
}</span>

// Check performs the health check
func (h *DatabaseHealthChecker) Check(ctx context.Context) HealthCheckResult <span class="cov1" title="1">{
        start := time.Now()

        if h.db == nil </span><span class="cov1" title="1">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      "database connection is nil",
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("failed to get database connection: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        // Check if database is alive
        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("database ping failed: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        // Get database stats
        <span class="cov0" title="0">stats := sqlDB.Stats()
        details := map[string]interface{}{
                "open_connections":     stats.OpenConnections,
                "in_use_connections":   stats.InUse,
                "idle_connections":     stats.Idle,
                "max_open_connections": stats.MaxOpenConnections,
                "wait_count":           stats.WaitCount,
                "wait_duration":        stats.WaitDuration,
        }

        return HealthCheckResult{
                Status:       HealthStatusHealthy,
                Message:      "database is healthy",
                Timestamp:    time.Now(),
                ResponseTime: time.Since(start),
                Details:      details,
        }</span>
}

// RedisHealthChecker checks Redis health
type RedisHealthChecker struct {
        client *redis.Client
        name   string
        logger *logrus.Logger
}

// NewRedisHealthChecker creates a new Redis health checker
func NewRedisHealthChecker(client *redis.Client, name string, logger *logrus.Logger) *RedisHealthChecker <span class="cov3" title="2">{
        return &amp;RedisHealthChecker{
                client: client,
                name:   name,
                logger: logger,
        }
}</span>

// Name returns the name of the health checker
func (h *RedisHealthChecker) Name() string <span class="cov1" title="1">{
        return h.name
}</span>

// Check performs the health check
func (h *RedisHealthChecker) Check(ctx context.Context) HealthCheckResult <span class="cov1" title="1">{
        start := time.Now()

        if h.client == nil </span><span class="cov1" title="1">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      "redis client is nil",
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        // Ping Redis
        <span class="cov0" title="0">if err := h.client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("redis ping failed: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        // Get Redis info
        <span class="cov0" title="0">info := h.client.Info(ctx, "server", "memory", "stats")
        details := map[string]interface{}{
                "redis_version":     "unknown",
                "used_memory":       "unknown",
                "connected_clients": "unknown",
        }

        if info.Err() == nil </span><span class="cov0" title="0">{
                // Parse info for key metrics (simplified)
                details["info_available"] = true
        }</span>

        <span class="cov0" title="0">return HealthCheckResult{
                Status:       HealthStatusHealthy,
                Message:      "redis is healthy",
                Timestamp:    time.Now(),
                ResponseTime: time.Since(start),
                Details:      details,
        }</span>
}

// S3HealthChecker checks S3 health
type S3HealthChecker struct {
        bucketName string
        name       string
        logger     *logrus.Logger
        // We'll use a simple HTTP check for now
        httpClient *http.Client
}

// NewS3HealthChecker creates a new S3 health checker
func NewS3HealthChecker(bucketName, name string, logger *logrus.Logger) *S3HealthChecker <span class="cov7" title="10">{
        return &amp;S3HealthChecker{
                bucketName: bucketName,
                name:       name,
                logger:     logger,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

// Name returns the name of the health checker
func (h *S3HealthChecker) Name() string <span class="cov6" title="7">{
        return h.name
}</span>

// Check performs the health check
func (h *S3HealthChecker) Check(ctx context.Context) HealthCheckResult <span class="cov5" title="4">{
        start := time.Now()

        // For now, we'll just check if we can reach S3
        // In a real implementation, you would use the AWS SDK to check bucket access
        req, err := http.NewRequestWithContext(ctx, "HEAD", "https://s3.amazonaws.com", nil)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("failed to create request: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        <span class="cov5" title="4">resp, err := h.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("s3 health check failed: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>
        <span class="cov5" title="4">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov5" title="4">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("s3 returned status %d", resp.StatusCode),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        <span class="cov0" title="0">return HealthCheckResult{
                Status:       HealthStatusHealthy,
                Message:      "s3 is healthy",
                Timestamp:    time.Now(),
                ResponseTime: time.Since(start),
                Details: map[string]interface{}{
                        "bucket":      h.bucketName,
                        "status_code": resp.StatusCode,
                },
        }</span>
}

// HTTPHealthChecker checks HTTP endpoint health
type HTTPHealthChecker struct {
        url        string
        name       string
        logger     *logrus.Logger
        httpClient *http.Client
}

// NewHTTPHealthChecker creates a new HTTP health checker
func NewHTTPHealthChecker(url, name string, logger *logrus.Logger) *HTTPHealthChecker <span class="cov4" title="3">{
        return &amp;HTTPHealthChecker{
                url:    url,
                name:   name,
                logger: logger,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

// Name returns the name of the health checker
func (h *HTTPHealthChecker) Name() string <span class="cov1" title="1">{
        return h.name
}</span>

// Check performs the health check
func (h *HTTPHealthChecker) Check(ctx context.Context) HealthCheckResult <span class="cov4" title="3">{
        start := time.Now()

        req, err := http.NewRequestWithContext(ctx, "GET", h.url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("failed to create request: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        <span class="cov4" title="3">resp, err := h.httpClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("http health check failed: %v", err),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>
        <span class="cov3" title="2">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov1" title="1">{
                return HealthCheckResult{
                        Status:       HealthStatusUnhealthy,
                        Message:      fmt.Sprintf("http endpoint returned status %d", resp.StatusCode),
                        Timestamp:    time.Now(),
                        ResponseTime: time.Since(start),
                }
        }</span>

        <span class="cov1" title="1">return HealthCheckResult{
                Status:       HealthStatusHealthy,
                Message:      "http endpoint is healthy",
                Timestamp:    time.Now(),
                ResponseTime: time.Since(start),
                Details: map[string]interface{}{
                        "url":         h.url,
                        "status_code": resp.StatusCode,
                },
        }</span>
}

// HealthService manages health checks for all dependencies
type HealthService struct {
        checkers []HealthChecker
        logger   *logrus.Logger
        mu       sync.RWMutex
        results  map[string]HealthCheckResult
}

// NewHealthService creates a new health service
func NewHealthService(logger *logrus.Logger) *HealthService <span class="cov9" title="18">{
        return &amp;HealthService{
                checkers: make([]HealthChecker, 0),
                logger:   logger,
                results:  make(map[string]HealthCheckResult),
        }
}</span>

// AddChecker adds a health checker
func (s *HealthService) AddChecker(checker HealthChecker) <span class="cov10" title="20">{
        s.checkers = append(s.checkers, checker)
}</span>

// CheckAll runs all health checks
func (s *HealthService) CheckAll(ctx context.Context) map[string]HealthCheckResult <span class="cov8" title="12">{
        results := make(map[string]HealthCheckResult)

        for _, checker := range s.checkers </span><span class="cov9" title="15">{
                result := checker.Check(ctx)
                results[checker.Name()] = result

                s.mu.Lock()
                s.results[checker.Name()] = result
                s.mu.Unlock()
        }</span>

        <span class="cov8" title="12">return results</span>
}

// GetLastResults returns the last health check results
func (s *HealthService) GetLastResults() map[string]HealthCheckResult <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        results := make(map[string]HealthCheckResult)
        for name, result := range s.results </span><span class="cov1" title="1">{
                results[name] = result
        }</span>

        <span class="cov1" title="1">return results</span>
}

// IsHealthy returns true if all health checks are passing
func (s *HealthService) IsHealthy() bool <span class="cov5" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        for _, result := range s.results </span><span class="cov6" title="7">{
                if result.Status != HealthStatusHealthy </span><span class="cov3" title="2">{
                        return false
                }</span>
        }

        <span class="cov3" title="2">return true</span>
}

// StartPeriodicHealthChecks starts periodic health checks
func (s *HealthService) StartPeriodicHealthChecks(ctx context.Context, interval time.Duration) <span class="cov3" title="2">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        go func() </span><span class="cov3" title="2">{
                for </span><span class="cov3" title="2">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov3" title="2">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.CheckAll(ctx)</span>
                        }
                }
        }()
}

// GetHTTPHandler returns an HTTP handler for health checks
func (s *HealthService) GetHTTPHandler() http.Handler <span class="cov5" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="3">{
                ctx := r.Context()
                results := s.CheckAll(ctx)

                // Determine overall health
                overall := HealthStatusHealthy
                for _, result := range results </span><span class="cov4" title="3">{
                        if result.Status != HealthStatusHealthy </span><span class="cov3" title="2">{
                                overall = HealthStatusUnhealthy
                                break</span>
                        }
                }

                // Set appropriate status code
                <span class="cov4" title="3">if overall == HealthStatusHealthy </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusOK)
                }</span> else<span class="cov3" title="2"> {
                        w.WriteHeader(http.StatusServiceUnavailable)
                }</span>

                // Return JSON response
                <span class="cov4" title="3">w.Header().Set("Content-Type", "application/json")

                response := map[string]interface{}{
                        "status":    overall,
                        "timestamp": time.Now(),
                        "checks":    results,
                }

                // Encode response as JSON
                json.NewEncoder(w).Encode(response)</span>
        })
}

// HealthzHandler returns a simple healthz handler
func (s *HealthService) HealthzHandler() http.Handler <span class="cov4" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                if s.IsHealthy() </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusOK)
                        w.Write([]byte("OK"))
                }</span> else<span class="cov1" title="1"> {
                        w.WriteHeader(http.StatusServiceUnavailable)
                        w.Write([]byte("Service Unavailable"))
                }</span>
        })
}

// ReadinessHandler returns a readiness handler
func (s *HealthService) ReadinessHandler() http.Handler <span class="cov5" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="3">{
                // Check if critical dependencies are ready
                ctx := r.Context()
                results := s.CheckAll(ctx)

                // For readiness, we might be more strict about which checks must pass
                ready := true
                for name, result := range results </span><span class="cov4" title="3">{
                        // Consider database as critical for readiness
                        if name == "database" &amp;&amp; result.Status != HealthStatusHealthy </span><span class="cov1" title="1">{
                                ready = false
                                break</span>
                        }
                }

                <span class="cov4" title="3">if ready </span><span class="cov3" title="2">{
                        w.WriteHeader(http.StatusOK)
                        w.Write([]byte("Ready"))
                }</span> else<span class="cov1" title="1"> {
                        w.WriteHeader(http.StatusServiceUnavailable)
                        w.Write([]byte("Not Ready"))
                }</span>
        })
}

// LivenessHandler returns a liveness handler
func (s *HealthService) LivenessHandler() http.Handler <span class="cov4" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                // Liveness check is typically more lenient
                // It should only fail if the application is completely broken
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("Alive"))
        }</span>)
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package monitoring

import "github.com/sirupsen/logrus"

// Logger defines the interface for logging operations
type Logger interface {
        Debug(msg string, fields ...interface{})
        Info(msg string, fields ...interface{})
        Warn(msg string, fields ...interface{})
        Error(msg string, fields ...interface{})
}

// LogrusAdapter adapts logrus.Logger to the Logger interface
type LogrusAdapter struct {
        logger *logrus.Logger
}

// NewLogrusAdapter creates a new logrus adapter
func NewLogrusAdapter(logger *logrus.Logger) Logger <span class="cov0" title="0">{
        return &amp;LogrusAdapter{logger: logger}
}</span>

// NewLogger creates a new logger with the specified level
func NewLogger(name, level string) Logger <span class="cov0" title="0">{
        logger := logrus.New()

        // Set log level
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                logger.SetLevel(logrus.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                logger.SetLevel(logrus.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                logger.SetLevel(logrus.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                logger.SetLevel(logrus.ErrorLevel)</span>
        default:<span class="cov0" title="0">
                logger.SetLevel(logrus.InfoLevel)</span>
        }

        // Set JSON formatter for structured logging
        <span class="cov0" title="0">logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: "2006-01-02T15:04:05.000Z07:00",
                FieldMap: logrus.FieldMap{
                        logrus.FieldKeyTime:  "timestamp",
                        logrus.FieldKeyLevel: "level",
                        logrus.FieldKeyMsg:   "message",
                },
        })

        return &amp;LogrusAdapter{logger: logger}</span>
}

// Debug logs a debug message
func (l *LogrusAdapter) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        entry := l.logger.WithFields(l.fieldsToLogrusFields(fields))
        entry.Debug(msg)
}</span>

// Info logs an info message
func (l *LogrusAdapter) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        entry := l.logger.WithFields(l.fieldsToLogrusFields(fields))
        entry.Info(msg)
}</span>

// Warn logs a warning message
func (l *LogrusAdapter) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        entry := l.logger.WithFields(l.fieldsToLogrusFields(fields))
        entry.Warn(msg)
}</span>

// Error logs an error message
func (l *LogrusAdapter) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        entry := l.logger.WithFields(l.fieldsToLogrusFields(fields))
        entry.Error(msg)
}</span>

// fieldsToLogrusFields converts key-value pairs to logrus.Fields
func (l *LogrusAdapter) fieldsToLogrusFields(fields []interface{}) logrus.Fields <span class="cov0" title="0">{
        logrusFields := make(logrus.Fields)

        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                        if key, ok := fields[i].(string); ok </span><span class="cov0" title="0">{
                                logrusFields[key] = fields[i+1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return logrusFields</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/sirupsen/logrus"
)

// MetricsRegistry holds all Prometheus metrics
type MetricsRegistry struct {
        // HTTP metrics
        HTTPRequestsTotal    *prometheus.CounterVec
        HTTPRequestDuration  *prometheus.HistogramVec
        HTTPResponseSize     *prometheus.HistogramVec
        HTTPRequestsInFlight *prometheus.GaugeVec

        // Business metrics
        ReviewsProcessed   *prometheus.CounterVec
        ReviewsTotal       *prometheus.GaugeVec
        ProcessingErrors   *prometheus.CounterVec
        ProcessingDuration *prometheus.HistogramVec
        FileProcessingJobs *prometheus.GaugeVec

        // Database metrics
        DatabaseConnections   *prometheus.GaugeVec
        DatabaseQueries       *prometheus.CounterVec
        DatabaseQueryDuration *prometheus.HistogramVec
        DatabaseErrors        *prometheus.CounterVec

        // Cache metrics
        CacheHits       *prometheus.CounterVec
        CacheMisses     *prometheus.CounterVec
        CacheOperations *prometheus.CounterVec
        CacheSize       *prometheus.GaugeVec

        // S3 metrics
        S3Operations        *prometheus.CounterVec
        S3OperationDuration *prometheus.HistogramVec
        S3Errors            *prometheus.CounterVec
        S3ObjectSize        *prometheus.HistogramVec

        // System metrics
        GoRoutines  *prometheus.GaugeVec
        MemoryUsage *prometheus.GaugeVec
        CPUUsage    *prometheus.GaugeVec
        GCPauses    *prometheus.HistogramVec

        // Circuit breaker metrics
        CircuitBreakerState    *prometheus.GaugeVec
        CircuitBreakerRequests *prometheus.CounterVec
        CircuitBreakerFailures *prometheus.CounterVec

        // SLI/SLO metrics
        SLIAvailability *prometheus.GaugeVec
        SLILatency      *prometheus.HistogramVec
        SLIErrorRate    *prometheus.GaugeVec
        SLIThroughput   *prometheus.GaugeVec

        registry *prometheus.Registry
}

// NewMetricsRegistry creates a new metrics registry
func NewMetricsRegistry() *MetricsRegistry <span class="cov5" title="27">{
        registry := prometheus.NewRegistry()
        factory := promauto.With(registry)

        // Create custom metrics
        m := &amp;MetricsRegistry{
                // HTTP metrics
                HTTPRequestsTotal: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_http_requests_total",
                                Help: "Total number of HTTP requests",
                        },
                        []string{"method", "endpoint", "status_code"},
                ),
                HTTPRequestDuration: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_http_request_duration_seconds",
                                Help:    "Duration of HTTP requests in seconds",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"method", "endpoint"},
                ),
                HTTPResponseSize: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_http_response_size_bytes",
                                Help:    "Size of HTTP responses in bytes",
                                Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                        },
                        []string{"method", "endpoint"},
                ),
                HTTPRequestsInFlight: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_http_requests_in_flight",
                                Help: "Number of HTTP requests currently being processed",
                        },
                        []string{"method", "endpoint"},
                ),

                // Business metrics
                ReviewsProcessed: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_processed_total",
                                Help: "Total number of reviews processed",
                        },
                        []string{"provider", "status"},
                ),
                ReviewsTotal: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_total",
                                Help: "Total number of reviews in the system",
                        },
                        []string{"provider", "hotel_id"},
                ),
                ProcessingErrors: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_processing_errors_total",
                                Help: "Total number of processing errors",
                        },
                        []string{"provider", "error_type"},
                ),
                ProcessingDuration: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_processing_duration_seconds",
                                Help:    "Duration of review processing in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.1, 2, 10),
                        },
                        []string{"provider", "operation"},
                ),
                FileProcessingJobs: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_file_processing_jobs",
                                Help: "Number of file processing jobs by status",
                        },
                        []string{"status"},
                ),

                // Database metrics
                DatabaseConnections: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_database_connections",
                                Help: "Number of database connections",
                        },
                        []string{"state"},
                ),
                DatabaseQueries: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_database_queries_total",
                                Help: "Total number of database queries",
                        },
                        []string{"table", "operation"},
                ),
                DatabaseQueryDuration: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_database_query_duration_seconds",
                                Help:    "Duration of database queries in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.001, 2, 10),
                        },
                        []string{"table", "operation"},
                ),
                DatabaseErrors: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_database_errors_total",
                                Help: "Total number of database errors",
                        },
                        []string{"table", "operation", "error_type"},
                ),

                // Cache metrics
                CacheHits: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_cache_hits_total",
                                Help: "Total number of cache hits",
                        },
                        []string{"cache_type", "key_type"},
                ),
                CacheMisses: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_cache_misses_total",
                                Help: "Total number of cache misses",
                        },
                        []string{"cache_type", "key_type"},
                ),
                CacheOperations: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_cache_operations_total",
                                Help: "Total number of cache operations",
                        },
                        []string{"cache_type", "operation"},
                ),
                CacheSize: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_cache_size_bytes",
                                Help: "Size of cache in bytes",
                        },
                        []string{"cache_type"},
                ),

                // S3 metrics
                S3Operations: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_s3_operations_total",
                                Help: "Total number of S3 operations",
                        },
                        []string{"operation", "bucket", "status"},
                ),
                S3OperationDuration: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_s3_operation_duration_seconds",
                                Help:    "Duration of S3 operations in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.1, 2, 10),
                        },
                        []string{"operation", "bucket"},
                ),
                S3Errors: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_s3_errors_total",
                                Help: "Total number of S3 errors",
                        },
                        []string{"operation", "bucket", "error_type"},
                ),
                S3ObjectSize: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_s3_object_size_bytes",
                                Help:    "Size of S3 objects in bytes",
                                Buckets: prometheus.ExponentialBuckets(1024, 10, 8),
                        },
                        []string{"operation", "bucket"},
                ),

                // System metrics
                GoRoutines: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_goroutines",
                                Help: "Number of goroutines",
                        },
                        []string{"component"},
                ),
                MemoryUsage: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_memory_usage_bytes",
                                Help: "Memory usage in bytes",
                        },
                        []string{"type"},
                ),
                CPUUsage: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_cpu_usage_percent",
                                Help: "CPU usage percentage",
                        },
                        []string{"component"},
                ),
                GCPauses: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_gc_pause_duration_seconds",
                                Help:    "GC pause duration in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.00001, 2, 15),
                        },
                        []string{"type"},
                ),

                // Circuit breaker metrics
                CircuitBreakerState: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_circuit_breaker_state",
                                Help: "Circuit breaker state (0=closed, 1=open, 2=half-open)",
                        },
                        []string{"component"},
                ),
                CircuitBreakerRequests: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_circuit_breaker_requests_total",
                                Help: "Total number of circuit breaker requests",
                        },
                        []string{"component", "state"},
                ),
                CircuitBreakerFailures: factory.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "hotel_reviews_circuit_breaker_failures_total",
                                Help: "Total number of circuit breaker failures",
                        },
                        []string{"component", "failure_type"},
                ),

                // SLI/SLO metrics
                SLIAvailability: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_sli_availability",
                                Help: "Service availability SLI (0-1)",
                        },
                        []string{"service", "endpoint"},
                ),
                SLILatency: factory.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "hotel_reviews_sli_latency_seconds",
                                Help:    "Service latency SLI in seconds",
                                Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0},
                        },
                        []string{"service", "endpoint"},
                ),
                SLIErrorRate: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_sli_error_rate",
                                Help: "Service error rate SLI (0-1)",
                        },
                        []string{"service", "endpoint"},
                ),
                SLIThroughput: factory.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "hotel_reviews_sli_throughput_requests_per_second",
                                Help: "Service throughput SLI in requests per second",
                        },
                        []string{"service", "endpoint"},
                ),

                registry: registry,
        }

        // Metrics are automatically registered with the registry by promauto.With(registry)
        return m
}</span>

// GetRegistry returns the Prometheus registry
func (m *MetricsRegistry) GetRegistry() *prometheus.Registry <span class="cov3" title="7">{
        return m.registry
}</span>

// GetHandler returns the Prometheus HTTP handler
func (m *MetricsRegistry) GetHandler() http.Handler <span class="cov1" title="1">{
        return promhttp.HandlerFor(m.registry, promhttp.HandlerOpts{
                EnableOpenMetrics: true,
                Registry:          m.registry,
        })
}</span>

// MonitoringService provides monitoring functionality
type MonitoringService struct {
        metrics *MetricsRegistry
        logger  *logrus.Logger
}

// NewMonitoringService creates a new monitoring service
func NewMonitoringService(logger *logrus.Logger) *MonitoringService <span class="cov4" title="22">{
        return &amp;MonitoringService{
                metrics: NewMetricsRegistry(),
                logger:  logger,
        }
}</span>

// GetMetrics returns the metrics registry
func (s *MonitoringService) GetMetrics() *MetricsRegistry <span class="cov4" title="13">{
        return s.metrics
}</span>

// RecordHTTPRequest records HTTP request metrics
func (s *MonitoringService) RecordHTTPRequest(method, endpoint, statusCode string, duration time.Duration, responseSize int64) <span class="cov9" title="1104">{
        s.metrics.HTTPRequestsTotal.WithLabelValues(method, endpoint, statusCode).Inc()
        s.metrics.HTTPRequestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
        s.metrics.HTTPResponseSize.WithLabelValues(method, endpoint).Observe(float64(responseSize))
}</span>

// RecordReviewProcessed records review processing metrics
func (s *MonitoringService) RecordReviewProcessed(provider, status string, duration time.Duration) <span class="cov9" title="1104">{
        s.metrics.ReviewsProcessed.WithLabelValues(provider, status).Inc()
        s.metrics.ProcessingDuration.WithLabelValues(provider, "process").Observe(duration.Seconds())
}</span>

// RecordDatabaseQuery records database query metrics
func (s *MonitoringService) RecordDatabaseQuery(table, operation string, duration time.Duration, err error) <span class="cov10" title="1105">{
        s.metrics.DatabaseQueries.WithLabelValues(table, operation).Inc()
        s.metrics.DatabaseQueryDuration.WithLabelValues(table, operation).Observe(duration.Seconds())

        if err != nil </span><span class="cov1" title="2">{
                errorType := "unknown"
                if err != nil </span><span class="cov1" title="2">{
                        errorType = fmt.Sprintf("%T", err)
                }</span>
                <span class="cov1" title="2">s.metrics.DatabaseErrors.WithLabelValues(table, operation, errorType).Inc()</span>
        }
}

// RecordCacheOperation records cache operation metrics
func (s *MonitoringService) RecordCacheOperation(cacheType, operation string, hit bool) <span class="cov9" title="1004">{
        s.metrics.CacheOperations.WithLabelValues(cacheType, operation).Inc()

        if hit </span><span class="cov9" title="1003">{
                s.metrics.CacheHits.WithLabelValues(cacheType, operation).Inc()
        }</span> else<span class="cov1" title="1"> {
                s.metrics.CacheMisses.WithLabelValues(cacheType, operation).Inc()
        }</span>
}

// RecordS3Operation records S3 operation metrics
func (s *MonitoringService) RecordS3Operation(operation, bucket, status string, duration time.Duration, objectSize int64) <span class="cov9" title="1104">{
        s.metrics.S3Operations.WithLabelValues(operation, bucket, status).Inc()
        s.metrics.S3OperationDuration.WithLabelValues(operation, bucket).Observe(duration.Seconds())

        if objectSize &gt; 0 </span><span class="cov9" title="1103">{
                s.metrics.S3ObjectSize.WithLabelValues(operation, bucket).Observe(float64(objectSize))
        }</span>
}

// RecordCircuitBreakerState records circuit breaker state
func (s *MonitoringService) RecordCircuitBreakerState(component string, state int) <span class="cov9" title="1003">{
        s.metrics.CircuitBreakerState.WithLabelValues(component).Set(float64(state))
}</span>

// RecordSLI records SLI metrics
func (s *MonitoringService) RecordSLI(service, endpoint string, availability, errorRate, throughput float64, latency time.Duration) <span class="cov9" title="1002">{
        s.metrics.SLIAvailability.WithLabelValues(service, endpoint).Set(availability)
        s.metrics.SLIErrorRate.WithLabelValues(service, endpoint).Set(errorRate)
        s.metrics.SLIThroughput.WithLabelValues(service, endpoint).Set(throughput)
        s.metrics.SLILatency.WithLabelValues(service, endpoint).Observe(latency.Seconds())
}</span>

// StartSystemMetricsCollector starts collecting system metrics
func (s *MonitoringService) StartSystemMetricsCollector(ctx context.Context) <span class="cov1" title="2">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        go func() </span><span class="cov1" title="2">{
                for </span><span class="cov1" title="2">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="2">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.collectSystemMetrics()</span>
                        }
                }
        }()
}

// collectSystemMetrics collects system-level metrics
func (s *MonitoringService) collectSystemMetrics() <span class="cov1" title="1">{
        // This would typically collect real system metrics
        // For now, we'll just record some placeholder values
        s.metrics.GoRoutines.WithLabelValues("total").Set(float64(100))              // placeholder
        s.metrics.MemoryUsage.WithLabelValues("heap").Set(float64(1024 * 1024 * 50)) // placeholder
        s.metrics.CPUUsage.WithLabelValues("application").Set(float64(25.0))         // placeholder
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package monitoring

import (
        "context"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

// HTTPMiddleware provides monitoring middleware for HTTP handlers
type HTTPMiddleware struct {
        service *Service
}

// NewHTTPMiddleware creates a new HTTP monitoring middleware
func NewHTTPMiddleware(service *Service) *HTTPMiddleware <span class="cov0" title="0">{
        return &amp;HTTPMiddleware{
                service: service,
        }
}</span>

// MetricsMiddleware records HTTP metrics for incoming requests
func (m *HTTPMiddleware) MetricsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if m.service.metricsService == nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()

                // Get route template if available
                route := mux.CurrentRoute(r)
                endpoint := r.URL.Path
                if route != nil </span><span class="cov0" title="0">{
                        if template, err := route.GetPathTemplate(); err == nil </span><span class="cov0" title="0">{
                                endpoint = template
                        }</span>
                }

                // Record request in flight
                <span class="cov0" title="0">m.service.metricsService.metrics.HTTPRequestsInFlight.WithLabelValues(r.Method, endpoint).Inc()
                defer m.service.metricsService.metrics.HTTPRequestsInFlight.WithLabelValues(r.Method, endpoint).Dec()

                // Wrap response writer to capture status code and response size
                wrappedWriter := &amp;responseWriter{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                        responseSize:   0,
                }

                // Process request
                next.ServeHTTP(wrappedWriter, r)

                // Record metrics
                duration := time.Since(start)
                statusCode := strconv.Itoa(wrappedWriter.statusCode)

                m.service.RecordHTTPRequest(r.Method, endpoint, statusCode, duration, wrappedWriter.responseSize)</span>
        })
}

// TracingMiddleware adds distributed tracing to HTTP requests
func (m *HTTPMiddleware) TracingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if m.service.tracingService == nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()

                // Extract trace context from headers
                ctx = m.service.tracingService.ExtractTraceContext(ctx, &amp;HTTPHeaderCarrier{headers: r.Header})

                // Get route template if available
                route := mux.CurrentRoute(r)
                endpoint := r.URL.Path
                if route != nil </span><span class="cov0" title="0">{
                        if template, err := route.GetPathTemplate(); err == nil </span><span class="cov0" title="0">{
                                endpoint = template
                        }</span>
                }

                // Start span
                <span class="cov0" title="0">ctx, span := m.service.tracingService.StartSpan(ctx, r.Method+" "+endpoint,
                        trace.WithAttributes(
                                attribute.String("http.method", r.Method),
                                attribute.String("http.url", r.URL.String()),
                                attribute.String("http.scheme", r.URL.Scheme),
                                attribute.String("http.host", r.Host),
                                attribute.String("http.user_agent", r.UserAgent()),
                                attribute.String("http.remote_addr", r.RemoteAddr),
                        ),
                )
                defer span.End()

                // Add trace context to response headers
                m.service.tracingService.InjectTraceContext(ctx, &amp;HTTPHeaderCarrier{headers: w.Header()})

                // Process request with tracing context
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// HealthCheckMiddleware provides health check functionality
func (m *HTTPMiddleware) HealthCheckMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip health check for monitoring endpoints
                if r.URL.Path == "/health" || r.URL.Path == "/healthz" ||
                        r.URL.Path == "/readiness" || r.URL.Path == "/liveness" ||
                        r.URL.Path == "/metrics" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check if service is healthy
                <span class="cov0" title="0">if m.service.healthService != nil &amp;&amp; !m.service.healthService.IsHealthy() </span><span class="cov0" title="0">{
                        // Log the unhealthy state but don't fail requests
                        m.service.logger.Warn("Service is not healthy but processing request")
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// BusinessMetricsMiddleware records business-specific metrics
func (m *HTTPMiddleware) BusinessMetricsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if m.service.businessMetrics == nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()

                // Process request
                next.ServeHTTP(w, r)

                // Record business metrics based on the endpoint
                duration := time.Since(start)

                // Example: Record different metrics based on the endpoint
                switch r.URL.Path </span>{
                case "/api/v1/reviews":<span class="cov0" title="0">
                        if r.Method == "POST" </span><span class="cov0" title="0">{
                                // This would be a review creation/ingestion
                                m.service.businessMetrics.RecordReviewIngestion("api", "", "api")
                        }</span>
                case "/api/v1/process":<span class="cov0" title="0">
                        if r.Method == "POST" </span><span class="cov0" title="0">{
                                // This would be file processing
                                m.service.businessMetrics.RecordFileProcessing("api", "manual", "success", duration, 0, 0)
                        }</span>
                }
        })
}

// CombinedMiddleware combines all monitoring middleware
func (m *HTTPMiddleware) CombinedMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Chain middleware in order: health -&gt; tracing -&gt; metrics -&gt; business metrics
        return m.HealthCheckMiddleware(
                m.TracingMiddleware(
                        m.MetricsMiddleware(
                                m.BusinessMetricsMiddleware(next),
                        ),
                ),
        )
}</span>

// responseWriter wraps http.ResponseWriter to capture status code and response size
type responseWriter struct {
        http.ResponseWriter
        statusCode   int
        responseSize int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.Write(b)
        rw.responseSize += int64(size)
        return size, err
}</span>

// HTTPHeaderCarrier implements the TextMapCarrier interface for HTTP headers
type HTTPHeaderCarrier struct {
        headers http.Header
}

// Get returns the value for the given key
func (h *HTTPHeaderCarrier) Get(key string) string <span class="cov0" title="0">{
        return h.headers.Get(key)
}</span>

// Set sets the value for the given key
func (h *HTTPHeaderCarrier) Set(key, value string) <span class="cov0" title="0">{
        h.headers.Set(key, value)
}</span>

// Keys returns all keys in the carrier
func (h *HTTPHeaderCarrier) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(h.headers))
        for k := range h.headers </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// DatabaseMiddleware provides database monitoring for GORM
type DatabaseMiddleware struct {
        service *Service
}

// NewDatabaseMiddleware creates a new database monitoring middleware
func NewDatabaseMiddleware(service *Service) *DatabaseMiddleware <span class="cov0" title="0">{
        return &amp;DatabaseMiddleware{
                service: service,
        }
}</span>

// GORMCallback provides GORM callback for database monitoring
func (m *DatabaseMiddleware) GORMCallback(tableName string) func(interface{}) <span class="cov0" title="0">{
        return func(tx interface{}) </span><span class="cov0" title="0">{
                // This would be implemented with actual GORM callback logic
                // For now, it's a placeholder
                start := time.Now()

                // After the query executes, record metrics
                duration := time.Since(start)
                m.service.RecordDatabaseQuery(tableName, "query", duration, nil)
        }</span>
}

// FileProcessingMiddleware provides monitoring for file processing operations
type FileProcessingMiddleware struct {
        service *Service
}

// NewFileProcessingMiddleware creates a new file processing monitoring middleware
func NewFileProcessingMiddleware(service *Service) *FileProcessingMiddleware <span class="cov0" title="0">{
        return &amp;FileProcessingMiddleware{
                service: service,
        }
}</span>

// WrapFileProcessor wraps file processing operations with monitoring
func (m *FileProcessingMiddleware) WrapFileProcessor(provider, fileURL string, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        ctx := context.Background()

        return m.service.TraceFileProcessing(ctx, provider, fileURL, func(ctx context.Context) error </span><span class="cov0" title="0">{
                start := time.Now()

                err := fn(ctx)

                duration := time.Since(start)
                status := "success"
                if err != nil </span><span class="cov0" title="0">{
                        status = "error"
                }</span>

                // Record metrics
                <span class="cov0" title="0">m.service.RecordReviewProcessed(provider, status, duration)

                if m.service.businessMetrics != nil </span><span class="cov0" title="0">{
                        m.service.businessMetrics.RecordFileProcessing(provider, "jsonl", status, duration, 0, 0)
                }</span>

                <span class="cov0" title="0">return err</span>
        })
}

// S3OperationMiddleware provides monitoring for S3 operations
type S3OperationMiddleware struct {
        service *Service
}

// NewS3OperationMiddleware creates a new S3 operation monitoring middleware
func NewS3OperationMiddleware(service *Service) *S3OperationMiddleware <span class="cov0" title="0">{
        return &amp;S3OperationMiddleware{
                service: service,
        }
}</span>

// WrapS3Operation wraps S3 operations with monitoring
func (m *S3OperationMiddleware) WrapS3Operation(ctx context.Context, operation, bucket, key string, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return m.service.TraceS3Operation(ctx, operation, bucket, key, func(ctx context.Context) error </span><span class="cov0" title="0">{
                start := time.Now()

                err := fn(ctx)

                duration := time.Since(start)
                status := "success"
                if err != nil </span><span class="cov0" title="0">{
                        status = "error"
                }</span>

                // Record metrics
                <span class="cov0" title="0">m.service.RecordS3Operation(operation, bucket, status, duration, 0)

                return err</span>
        })
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
        "go.opentelemetry.io/otel/trace"
        "gorm.io/gorm"
)

// Config holds configuration for monitoring services
type Config struct {
        // Metrics configuration
        MetricsEnabled bool
        MetricsPath    string

        // Tracing configuration
        TracingEnabled      bool
        TracingServiceName  string
        TracingVersion      string
        TracingEnvironment  string
        JaegerEndpoint      string
        TracingSamplingRate float64

        // Health check configuration
        HealthEnabled       bool
        HealthPath          string
        HealthCheckInterval time.Duration

        // Business metrics configuration
        BusinessMetricsEnabled  bool
        BusinessMetricsInterval time.Duration

        // SLO monitoring configuration
        SLOMonitoringEnabled  bool
        SLOMonitoringInterval time.Duration
}

// Service represents the main monitoring service
type Service struct {
        config *Config
        logger *logrus.Logger

        // Core monitoring services
        metricsService  *MonitoringService
        tracingService  *TracingService
        healthService   *HealthService
        businessMetrics *BusinessMetrics
        sloManager      *SLOManager

        // Dependencies
        db          *gorm.DB
        redisClient *redis.Client
}

// NewService creates a new monitoring service
func NewService(config *Config, logger *logrus.Logger, db *gorm.DB, redisClient *redis.Client) (*Service, error) <span class="cov7" title="27">{
        service := &amp;Service{
                config:      config,
                logger:      logger,
                db:          db,
                redisClient: redisClient,
        }

        // Initialize monitoring services
        if err := service.initializeServices(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to initialize monitoring services: %w", err)
        }</span>

        <span class="cov7" title="26">return service, nil</span>
}

// initializeServices initializes all monitoring services
func (s *Service) initializeServices() error <span class="cov7" title="27">{
        // Initialize metrics service
        if s.config.MetricsEnabled </span><span class="cov5" title="11">{
                s.metricsService = NewMonitoringService(s.logger)
                s.logger.Info("Metrics service initialized")
        }</span>

        // Initialize tracing service
        <span class="cov7" title="27">if s.config.TracingEnabled </span><span class="cov1" title="1">{
                tracingConfig := &amp;TracingConfig{
                        ServiceName:    s.config.TracingServiceName,
                        ServiceVersion: s.config.TracingVersion,
                        Environment:    s.config.TracingEnvironment,
                        JaegerEndpoint: s.config.JaegerEndpoint,
                        SamplingRate:   s.config.TracingSamplingRate,
                        Enabled:        s.config.TracingEnabled,
                }

                var err error
                s.tracingService, err = NewTracingService(tracingConfig, s.logger)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to initialize tracing service: %w", err)
                }</span>
                <span class="cov0" title="0">s.logger.Info("Tracing service initialized")</span>
        }

        // Initialize health service
        <span class="cov7" title="26">if s.config.HealthEnabled </span><span class="cov5" title="8">{
                s.healthService = NewHealthService(s.logger)

                // Add health checkers
                if s.db != nil </span><span class="cov0" title="0">{
                        dbChecker := NewDatabaseHealthChecker(s.db, "database", s.logger)
                        s.healthService.AddChecker(dbChecker)
                }</span>

                <span class="cov5" title="8">if s.redisClient != nil </span><span class="cov0" title="0">{
                        redisChecker := NewRedisHealthChecker(s.redisClient, "redis", s.logger)
                        s.healthService.AddChecker(redisChecker)
                }</span>

                // Add S3 health checker (placeholder)
                <span class="cov5" title="8">s3Checker := NewS3HealthChecker("hotel-reviews-files", "s3", s.logger)
                s.healthService.AddChecker(s3Checker)

                s.logger.Info("Health service initialized")</span>
        }

        // Initialize business metrics
        <span class="cov7" title="26">if s.config.BusinessMetricsEnabled </span><span class="cov4" title="6">{
                // Use the same registry as the metrics service
                var registry *prometheus.Registry
                if s.metricsService != nil </span><span class="cov4" title="6">{
                        registry = s.metricsService.GetMetrics().GetRegistry()
                }</span> else<span class="cov0" title="0"> {
                        registry = prometheus.NewRegistry()
                }</span>
                <span class="cov4" title="6">s.businessMetrics = NewBusinessMetrics(s.logger, registry)
                s.logger.Info("Business metrics service initialized")</span>
        }

        // Initialize SLO manager
        <span class="cov7" title="26">if s.config.SLOMonitoringEnabled &amp;&amp; s.metricsService != nil </span><span class="cov4" title="6">{
                s.sloManager = NewSLOManager(s.metricsService.GetMetrics(), s.logger)
                s.logger.Info("SLO manager initialized")
        }</span>

        <span class="cov7" title="26">return nil</span>
}

// Start starts all monitoring services
func (s *Service) Start(ctx context.Context) error <span class="cov1" title="1">{
        // Start system metrics collection
        if s.metricsService != nil </span><span class="cov1" title="1">{
                s.metricsService.StartSystemMetricsCollector(ctx)
                s.logger.Info("System metrics collection started")
        }</span>

        // Start periodic health checks
        <span class="cov1" title="1">if s.healthService != nil </span><span class="cov1" title="1">{
                s.healthService.StartPeriodicHealthChecks(ctx, s.config.HealthCheckInterval)
                s.logger.Info("Periodic health checks started")
        }</span>

        // Start business metrics collection
        <span class="cov1" title="1">if s.businessMetrics != nil </span><span class="cov1" title="1">{
                s.businessMetrics.StartBusinessMetricsCollection(ctx)
                s.logger.Info("Business metrics collection started")
        }</span>

        // Start SLO monitoring
        <span class="cov1" title="1">if s.sloManager != nil </span><span class="cov1" title="1">{
                s.sloManager.StartSLOMonitoring(ctx, s.config.SLOMonitoringInterval)
                s.logger.Info("SLO monitoring started")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Stop gracefully stops all monitoring services
func (s *Service) Stop(ctx context.Context) error <span class="cov2" title="2">{
        // Stop tracing service
        if s.tracingService != nil </span><span class="cov0" title="0">{
                if err := s.tracingService.Close(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("Failed to close tracing service")
                }</span>
        }

        <span class="cov2" title="2">s.logger.Info("Monitoring services stopped")
        return nil</span>
}

// GetMetricsService returns the metrics service
func (s *Service) GetMetricsService() *MonitoringService <span class="cov1" title="1">{
        return s.metricsService
}</span>

// GetTracingService returns the tracing service
func (s *Service) GetTracingService() *TracingService <span class="cov1" title="1">{
        return s.tracingService
}</span>

// GetHealthService returns the health service
func (s *Service) GetHealthService() *HealthService <span class="cov1" title="1">{
        return s.healthService
}</span>

// GetBusinessMetrics returns the business metrics service
func (s *Service) GetBusinessMetrics() *BusinessMetrics <span class="cov1" title="1">{
        return s.businessMetrics
}</span>

// GetSLOManager returns the SLO manager
func (s *Service) GetSLOManager() *SLOManager <span class="cov1" title="1">{
        return s.sloManager
}</span>

// RegisterHTTPHandlers registers HTTP handlers for monitoring endpoints
func (s *Service) RegisterHTTPHandlers(router interface{}) <span class="cov2" title="2">{
        // Support both http.ServeMux and gorilla mux
        switch r := router.(type) </span>{
        case *http.ServeMux:<span class="cov1" title="1">
                s.registerWithServeMux(r)</span>
        default:<span class="cov1" title="1">
                // Assume it's a gorilla mux router
                s.registerWithGorillaMux(router)</span>
        }
}

// registerWithServeMux registers handlers with http.ServeMux
func (s *Service) registerWithServeMux(mux *http.ServeMux) <span class="cov1" title="1">{
        // Metrics endpoint
        if s.metricsService != nil </span><span class="cov1" title="1">{
                mux.Handle(s.config.MetricsPath, promhttp.Handler())
                s.logger.Info("Metrics endpoint registered", "path", s.config.MetricsPath)
        }</span>

        // Health endpoints
        <span class="cov1" title="1">if s.healthService != nil </span><span class="cov1" title="1">{
                mux.Handle(s.config.HealthPath, s.healthService.GetHTTPHandler())
                mux.Handle("/healthz", s.healthService.HealthzHandler())
                mux.Handle("/readiness", s.healthService.ReadinessHandler())
                mux.Handle("/liveness", s.healthService.LivenessHandler())
                s.logger.Info("Health endpoints registered", "path", s.config.HealthPath)
        }</span>

        // SLO report endpoint
        <span class="cov1" title="1">if s.sloManager != nil </span><span class="cov1" title="1">{
                mux.HandleFunc("/slo-report", s.handleSLOReport)
                s.logger.Info("SLO report endpoint registered", "path", "/slo-report")
        }</span>
}

// registerWithGorillaMux registers handlers with gorilla mux
func (s *Service) registerWithGorillaMux(router interface{}) <span class="cov1" title="1">{
        // Use reflection or type assertion to work with gorilla mux
        // For now, we'll use a simple approach
        if r, ok := router.(interface {
                Handle(string, http.Handler)
                HandleFunc(string, func(http.ResponseWriter, *http.Request))
        }); ok </span><span class="cov1" title="1">{
                // Metrics endpoint
                if s.metricsService != nil </span><span class="cov1" title="1">{
                        r.Handle(s.config.MetricsPath, promhttp.Handler())
                        s.logger.Info("Metrics endpoint registered", "path", s.config.MetricsPath)
                }</span>

                // Health endpoints
                <span class="cov1" title="1">if s.healthService != nil </span><span class="cov1" title="1">{
                        r.Handle(s.config.HealthPath, s.healthService.GetHTTPHandler())
                        r.Handle("/healthz", s.healthService.HealthzHandler())
                        r.Handle("/readiness", s.healthService.ReadinessHandler())
                        r.Handle("/liveness", s.healthService.LivenessHandler())
                        s.logger.Info("Health endpoints registered", "path", s.config.HealthPath)
                }</span>

                // SLO report endpoint
                <span class="cov1" title="1">if s.sloManager != nil </span><span class="cov1" title="1">{
                        r.HandleFunc("/slo-report", s.handleSLOReport)
                        s.logger.Info("SLO report endpoint registered", "path", "/slo-report")
                }</span>
        }
}

// handleSLOReport handles SLO report requests
func (s *Service) handleSLOReport(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        ctx := r.Context()

        if s.sloManager == nil </span><span class="cov1" title="1">{
                http.Error(w, "SLO manager not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">report, err := s.sloManager.GetSLOReport(ctx)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to generate SLO report: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")

        // Simple JSON response (in production, use a proper JSON library)
        fmt.Fprintf(w, `{
                "total_slos": %v,
                "violated_slos": %v,
                "slo_success_rate": %v,
                "timestamp": "%v"
        }`,
                report["total_slos"],
                report["violated_slos"],
                report["slo_success_rate"],
                report["timestamp"])</span>
}

// RecordHTTPRequest records HTTP request metrics
func (s *Service) RecordHTTPRequest(method, endpoint, statusCode string, duration time.Duration, responseSize int64) <span class="cov9" title="102">{
        if s.metricsService != nil </span><span class="cov9" title="101">{
                s.metricsService.RecordHTTPRequest(method, endpoint, statusCode, duration, responseSize)
        }</span>
}

// RecordReviewProcessed records review processing metrics
func (s *Service) RecordReviewProcessed(provider, status string, duration time.Duration) <span class="cov9" title="102">{
        if s.metricsService != nil </span><span class="cov9" title="101">{
                s.metricsService.RecordReviewProcessed(provider, status, duration)
        }</span>
        <span class="cov9" title="102">if s.businessMetrics != nil </span><span class="cov9" title="101">{
                s.businessMetrics.RecordReviewIngestion(provider, "", "file")
        }</span>
}

// RecordDatabaseQuery records database query metrics
func (s *Service) RecordDatabaseQuery(table, operation string, duration time.Duration, err error) <span class="cov10" title="103">{
        if s.metricsService != nil </span><span class="cov9" title="102">{
                s.metricsService.RecordDatabaseQuery(table, operation, duration, err)
        }</span>
}

// RecordS3Operation records S3 operation metrics
func (s *Service) RecordS3Operation(operation, bucket, status string, duration time.Duration, objectSize int64) <span class="cov9" title="102">{
        if s.metricsService != nil </span><span class="cov9" title="101">{
                s.metricsService.RecordS3Operation(operation, bucket, status, duration, objectSize)
        }</span>
}

// TraceHTTPRequest traces an HTTP request
func (s *Service) TraceHTTPRequest(ctx context.Context, method, path, userAgent string, fn func(ctx context.Context) error) error <span class="cov9" title="102">{
        if s.tracingService != nil </span><span class="cov0" title="0">{
                return s.tracingService.TraceHTTPRequest(ctx, method, path, userAgent, func(ctx context.Context, span trace.Span) error </span><span class="cov0" title="0">{
                        return fn(ctx)
                }</span>)
        }
        <span class="cov9" title="102">return fn(ctx)</span>
}

// TraceDatabaseQuery traces a database query
func (s *Service) TraceDatabaseQuery(ctx context.Context, table, operation, query string, fn func(ctx context.Context) error) error <span class="cov1" title="1">{
        if s.tracingService != nil </span><span class="cov0" title="0">{
                return s.tracingService.TraceDatabaseQuery(ctx, table, operation, query, func(ctx context.Context, span trace.Span) error </span><span class="cov0" title="0">{
                        return fn(ctx)
                }</span>)
        }
        <span class="cov1" title="1">return fn(ctx)</span>
}

// TraceS3Operation traces an S3 operation
func (s *Service) TraceS3Operation(ctx context.Context, operation, bucket, key string, fn func(ctx context.Context) error) error <span class="cov1" title="1">{
        if s.tracingService != nil </span><span class="cov0" title="0">{
                return s.tracingService.TraceS3Operation(ctx, operation, bucket, key, func(ctx context.Context, span trace.Span) error </span><span class="cov0" title="0">{
                        return fn(ctx)
                }</span>)
        }
        <span class="cov1" title="1">return fn(ctx)</span>
}

// TraceFileProcessing traces file processing operations
func (s *Service) TraceFileProcessing(ctx context.Context, provider, fileURL string, fn func(ctx context.Context) error) error <span class="cov1" title="1">{
        if s.tracingService != nil </span><span class="cov0" title="0">{
                return s.tracingService.TraceFileProcessing(ctx, provider, fileURL, func(ctx context.Context, span trace.Span) error </span><span class="cov0" title="0">{
                        return fn(ctx)
                }</span>)
        }
        <span class="cov1" title="1">return fn(ctx)</span>
}

// GetDefaultConfig returns default monitoring configuration
func GetDefaultConfig() *Config <span class="cov3" title="3">{
        return &amp;Config{
                MetricsEnabled:          true,
                MetricsPath:             "/metrics",
                TracingEnabled:          true,
                TracingServiceName:      "hotel-reviews-api",
                TracingVersion:          "1.0.0",
                TracingEnvironment:      "development",
                JaegerEndpoint:          "http://localhost:14268/api/traces",
                TracingSamplingRate:     0.1,
                HealthEnabled:           true,
                HealthPath:              "/health",
                HealthCheckInterval:     30 * time.Second,
                BusinessMetricsEnabled:  true,
                BusinessMetricsInterval: 1 * time.Minute,
                SLOMonitoringEnabled:    true,
                SLOMonitoringInterval:   1 * time.Minute,
        }
}</span>

// LoadConfigFromEnv loads monitoring configuration from environment variables
func LoadConfigFromEnv() *Config <span class="cov1" title="1">{
        config := GetDefaultConfig()

        // This would typically read from environment variables
        // For now, return default config
        return config
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package monitoring

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
)

// SLIType represents the type of SLI
type SLIType string

const (
        SLITypeAvailability SLIType = "availability"
        SLITypeLatency      SLIType = "latency"
        SLITypeErrorRate    SLIType = "error_rate"
        SLITypeThroughput   SLIType = "throughput"
)

// SLOSeverity represents the severity of SLO violations
type SLOSeverity string

const (
        SLOSeverityInfo     SLOSeverity = "info"
        SLOSeverityWarning  SLOSeverity = "warning"
        SLOSeverityCritical SLOSeverity = "critical"
)

// SLI represents a Service Level Indicator
type SLI struct {
        Name        string  `json:"name"`
        Type        SLIType `json:"type"`
        Description string  `json:"description"`
        Query       string  `json:"query"`
        Unit        string  `json:"unit"`
        Service     string  `json:"service"`
        Endpoint    string  `json:"endpoint,omitempty"`
}

// SLO represents a Service Level Objective
type SLO struct {
        Name         string      `json:"name"`
        Description  string      `json:"description"`
        Service      string      `json:"service"`
        SLI          SLI         `json:"sli"`
        Target       float64     `json:"target"`
        Window       string      `json:"window"`
        Severity     SLOSeverity `json:"severity"`
        AlertEnabled bool        `json:"alert_enabled"`
}

// SLIResult represents the result of an SLI measurement
type SLIResult struct {
        SLI       SLI       `json:"sli"`
        Value     float64   `json:"value"`
        Timestamp time.Time `json:"timestamp"`
}

// SLOViolation represents an SLO violation
type SLOViolation struct {
        SLO          SLO         `json:"slo"`
        CurrentValue float64     `json:"current_value"`
        Target       float64     `json:"target"`
        Timestamp    time.Time   `json:"timestamp"`
        Severity     SLOSeverity `json:"severity"`
}

// SLOManager manages SLIs and SLOs
type SLOManager struct {
        slis    []SLI
        slos    []SLO
        logger  *logrus.Logger
        metrics *MetricsRegistry
}

// NewSLOManager creates a new SLO manager
func NewSLOManager(metrics *MetricsRegistry, logger *logrus.Logger) *SLOManager <span class="cov3" title="6">{
        manager := &amp;SLOManager{
                slis:    []SLI{},
                slos:    []SLO{},
                logger:  logger,
                metrics: metrics,
        }

        // Initialize default SLIs and SLOs
        manager.initializeDefaultSLIs()
        manager.initializeDefaultSLOs()

        return manager
}</span>

// initializeDefaultSLIs initializes the default SLIs for the hotel reviews service
func (m *SLOManager) initializeDefaultSLIs() <span class="cov3" title="6">{
        m.slis = []SLI{
                // API Availability SLIs
                {
                        Name:        "api_availability",
                        Type:        SLITypeAvailability,
                        Description: "API availability measured by successful requests",
                        Query:       "rate(hotel_reviews_http_requests_total{status_code!~\"5..\"}[5m]) / rate(hotel_reviews_http_requests_total[5m])",
                        Unit:        "percent",
                        Service:     "hotel-reviews-api",
                },
                {
                        Name:        "health_check_availability",
                        Type:        SLITypeAvailability,
                        Description: "Health check endpoint availability",
                        Query:       "rate(hotel_reviews_http_requests_total{endpoint=\"/health\",status_code=\"200\"}[5m]) / rate(hotel_reviews_http_requests_total{endpoint=\"/health\"}[5m])",
                        Unit:        "percent",
                        Service:     "hotel-reviews-api",
                        Endpoint:    "/health",
                },

                // API Latency SLIs
                {
                        Name:        "api_latency_p95",
                        Type:        SLITypeLatency,
                        Description: "95th percentile API response time",
                        Query:       "histogram_quantile(0.95, rate(hotel_reviews_http_request_duration_seconds_bucket[5m]))",
                        Unit:        "seconds",
                        Service:     "hotel-reviews-api",
                },
                {
                        Name:        "api_latency_p99",
                        Type:        SLITypeLatency,
                        Description: "99th percentile API response time",
                        Query:       "histogram_quantile(0.99, rate(hotel_reviews_http_request_duration_seconds_bucket[5m]))",
                        Unit:        "seconds",
                        Service:     "hotel-reviews-api",
                },
                {
                        Name:        "review_processing_latency",
                        Type:        SLITypeLatency,
                        Description: "Review processing latency",
                        Query:       "histogram_quantile(0.95, rate(hotel_reviews_processing_duration_seconds_bucket{operation=\"process\"}[5m]))",
                        Unit:        "seconds",
                        Service:     "review-processor",
                },

                // Error Rate SLIs
                {
                        Name:        "api_error_rate",
                        Type:        SLITypeErrorRate,
                        Description: "API error rate (4xx and 5xx responses)",
                        Query:       "rate(hotel_reviews_http_requests_total{status_code=~\"4..|5..\"}[5m]) / rate(hotel_reviews_http_requests_total[5m])",
                        Unit:        "percent",
                        Service:     "hotel-reviews-api",
                },
                {
                        Name:        "processing_error_rate",
                        Type:        SLITypeErrorRate,
                        Description: "Review processing error rate",
                        Query:       "rate(hotel_reviews_processing_errors_total[5m]) / rate(hotel_reviews_processed_total[5m])",
                        Unit:        "percent",
                        Service:     "review-processor",
                },
                {
                        Name:        "database_error_rate",
                        Type:        SLITypeErrorRate,
                        Description: "Database operation error rate",
                        Query:       "rate(hotel_reviews_database_errors_total[5m]) / rate(hotel_reviews_database_queries_total[5m])",
                        Unit:        "percent",
                        Service:     "database",
                },

                // Throughput SLIs
                {
                        Name:        "api_throughput",
                        Type:        SLITypeThroughput,
                        Description: "API requests per second",
                        Query:       "rate(hotel_reviews_http_requests_total[5m])",
                        Unit:        "requests/second",
                        Service:     "hotel-reviews-api",
                },
                {
                        Name:        "review_processing_throughput",
                        Type:        SLITypeThroughput,
                        Description: "Reviews processed per second",
                        Query:       "rate(hotel_reviews_processed_total[5m])",
                        Unit:        "reviews/second",
                        Service:     "review-processor",
                },
                {
                        Name:        "file_processing_throughput",
                        Type:        SLITypeThroughput,
                        Description: "Files processed per hour",
                        Query:       "rate(hotel_reviews_files_processed_total{status=\"success\"}[1h]) * 3600",
                        Unit:        "files/hour",
                        Service:     "file-processor",
                },
        }
}</span>

// initializeDefaultSLOs initializes the default SLOs for the hotel reviews service
func (m *SLOManager) initializeDefaultSLOs() <span class="cov3" title="6">{
        m.slos = []SLO{
                // Availability SLOs
                {
                        Name:         "api_availability_slo",
                        Description:  "API should be available 99.5% of the time over 30 days",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("api_availability"),
                        Target:       0.995,
                        Window:       "30d",
                        Severity:     SLOSeverityCritical,
                        AlertEnabled: true,
                },
                {
                        Name:         "health_check_availability_slo",
                        Description:  "Health check should be available 99.9% of the time over 7 days",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("health_check_availability"),
                        Target:       0.999,
                        Window:       "7d",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },

                // Latency SLOs
                {
                        Name:         "api_latency_p95_slo",
                        Description:  "95% of API requests should complete within 500ms",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("api_latency_p95"),
                        Target:       0.5,
                        Window:       "1h",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },
                {
                        Name:         "api_latency_p99_slo",
                        Description:  "99% of API requests should complete within 2 seconds",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("api_latency_p99"),
                        Target:       2.0,
                        Window:       "1h",
                        Severity:     SLOSeverityCritical,
                        AlertEnabled: true,
                },
                {
                        Name:         "review_processing_latency_slo",
                        Description:  "95% of reviews should be processed within 10 seconds",
                        Service:      "review-processor",
                        SLI:          m.getSLIByName("review_processing_latency"),
                        Target:       10.0,
                        Window:       "1h",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },

                // Error Rate SLOs
                {
                        Name:         "api_error_rate_slo",
                        Description:  "API error rate should be less than 1% over 1 hour",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("api_error_rate"),
                        Target:       0.01,
                        Window:       "1h",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },
                {
                        Name:         "processing_error_rate_slo",
                        Description:  "Review processing error rate should be less than 0.5% over 1 hour",
                        Service:      "review-processor",
                        SLI:          m.getSLIByName("processing_error_rate"),
                        Target:       0.005,
                        Window:       "1h",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },
                {
                        Name:         "database_error_rate_slo",
                        Description:  "Database error rate should be less than 0.1% over 1 hour",
                        Service:      "database",
                        SLI:          m.getSLIByName("database_error_rate"),
                        Target:       0.001,
                        Window:       "1h",
                        Severity:     SLOSeverityCritical,
                        AlertEnabled: true,
                },

                // Throughput SLOs
                {
                        Name:         "api_throughput_slo",
                        Description:  "API should handle at least 100 requests per second",
                        Service:      "hotel-reviews-api",
                        SLI:          m.getSLIByName("api_throughput"),
                        Target:       100.0,
                        Window:       "5m",
                        Severity:     SLOSeverityInfo,
                        AlertEnabled: false,
                },
                {
                        Name:         "review_processing_throughput_slo",
                        Description:  "System should process at least 1000 reviews per second",
                        Service:      "review-processor",
                        SLI:          m.getSLIByName("review_processing_throughput"),
                        Target:       1000.0,
                        Window:       "5m",
                        Severity:     SLOSeverityInfo,
                        AlertEnabled: false,
                },
                {
                        Name:         "file_processing_throughput_slo",
                        Description:  "System should process at least 10 files per hour",
                        Service:      "file-processor",
                        SLI:          m.getSLIByName("file_processing_throughput"),
                        Target:       10.0,
                        Window:       "1h",
                        Severity:     SLOSeverityWarning,
                        AlertEnabled: true,
                },
        }
}</span>

// getSLIByName returns an SLI by its name
func (m *SLOManager) getSLIByName(name string) SLI <span class="cov7" title="66">{
        for _, sli := range m.slis </span><span class="cov10" title="396">{
                if sli.Name == name </span><span class="cov7" title="66">{
                        return sli
                }</span>
        }
        <span class="cov0" title="0">return SLI{}</span>
}

// GetSLIs returns all SLIs
func (m *SLOManager) GetSLIs() []SLI <span class="cov0" title="0">{
        return m.slis
}</span>

// GetSLOs returns all SLOs
func (m *SLOManager) GetSLOs() []SLO <span class="cov0" title="0">{
        return m.slos
}</span>

// GetSLOsByService returns SLOs for a specific service
func (m *SLOManager) GetSLOsByService(service string) []SLO <span class="cov0" title="0">{
        var slos []SLO
        for _, slo := range m.slos </span><span class="cov0" title="0">{
                if slo.Service == service </span><span class="cov0" title="0">{
                        slos = append(slos, slo)
                }</span>
        }
        <span class="cov0" title="0">return slos</span>
}

// GetSLOsBySeverity returns SLOs with a specific severity
func (m *SLOManager) GetSLOsBySeverity(severity SLOSeverity) []SLO <span class="cov0" title="0">{
        var slos []SLO
        for _, slo := range m.slos </span><span class="cov0" title="0">{
                if slo.Severity == severity </span><span class="cov0" title="0">{
                        slos = append(slos, slo)
                }</span>
        }
        <span class="cov0" title="0">return slos</span>
}

// AddSLI adds a new SLI
func (m *SLOManager) AddSLI(sli SLI) <span class="cov0" title="0">{
        m.slis = append(m.slis, sli)
}</span>

// AddSLO adds a new SLO
func (m *SLOManager) AddSLO(slo SLO) <span class="cov0" title="0">{
        m.slos = append(m.slos, slo)
}</span>

// EvaluateSLI evaluates an SLI and returns its current value
func (m *SLOManager) EvaluateSLI(ctx context.Context, sli SLI) (SLIResult, error) <span class="cov4" title="11">{
        // This is a placeholder implementation
        // In a real implementation, you would query Prometheus or another metrics system

        // For demonstration, return mock values
        var value float64
        switch sli.Type </span>{
        case SLITypeAvailability:<span class="cov2" title="2">
                value = 0.998</span> // 99.8% availability
        case SLITypeLatency:<span class="cov2" title="3">
                value = 0.3</span> // 300ms
        case SLITypeErrorRate:<span class="cov2" title="3">
                value = 0.002</span> // 0.2% error rate
        case SLITypeThroughput:<span class="cov2" title="3">
                value = 150.0</span> // 150 requests/second
        }

        <span class="cov4" title="11">return SLIResult{
                SLI:       sli,
                Value:     value,
                Timestamp: time.Now(),
        }, nil</span>
}

// EvaluateSLO evaluates an SLO and returns whether it's being met
func (m *SLOManager) EvaluateSLO(ctx context.Context, slo SLO) (bool, SLIResult, error) <span class="cov4" title="11">{
        result, err := m.EvaluateSLI(ctx, slo.SLI)
        if err != nil </span><span class="cov0" title="0">{
                return false, result, err
        }</span>

        <span class="cov4" title="11">var met bool
        switch slo.SLI.Type </span>{
        case SLITypeAvailability, SLITypeThroughput:<span class="cov3" title="5">
                met = result.Value &gt;= slo.Target</span>
        case SLITypeLatency, SLITypeErrorRate:<span class="cov3" title="6">
                met = result.Value &lt;= slo.Target</span>
        }

        <span class="cov4" title="11">return met, result, nil</span>
}

// CheckSLOViolations checks for SLO violations and returns them
func (m *SLOManager) CheckSLOViolations(ctx context.Context) ([]SLOViolation, error) <span class="cov0" title="0">{
        var violations []SLOViolation

        for _, slo := range m.slos </span><span class="cov0" title="0">{
                if !slo.AlertEnabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">met, result, err := m.EvaluateSLO(ctx, slo)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.WithError(err).WithField("slo", slo.Name).Error("Failed to evaluate SLO")
                        continue</span>
                }

                <span class="cov0" title="0">if !met </span><span class="cov0" title="0">{
                        violations = append(violations, SLOViolation{
                                SLO:          slo,
                                CurrentValue: result.Value,
                                Target:       slo.Target,
                                Timestamp:    time.Now(),
                                Severity:     slo.Severity,
                        })
                }</span>
        }

        <span class="cov0" title="0">return violations, nil</span>
}

// StartSLOMonitoring starts continuous SLO monitoring
func (m *SLOManager) StartSLOMonitoring(ctx context.Context, interval time.Duration) <span class="cov1" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        go func() </span><span class="cov1" title="1">{
                for </span><span class="cov1" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                violations, err := m.CheckSLOViolations(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.logger.WithError(err).Error("Failed to check SLO violations")
                                        continue</span>
                                }

                                <span class="cov0" title="0">for _, violation := range violations </span><span class="cov0" title="0">{
                                        m.logger.WithFields(logrus.Fields{
                                                "slo":           violation.SLO.Name,
                                                "service":       violation.SLO.Service,
                                                "current_value": violation.CurrentValue,
                                                "target":        violation.Target,
                                                "severity":      violation.Severity,
                                        }).Warn("SLO violation detected")

                                        // Update SLO metrics
                                        m.updateSLOMetrics(violation)
                                }</span>
                        }
                }
        }()
}

// updateSLOMetrics updates SLO-related metrics
func (m *SLOManager) updateSLOMetrics(violation SLOViolation) <span class="cov0" title="0">{
        slo := violation.SLO

        // Update SLI metrics
        switch slo.SLI.Type </span>{
        case SLITypeAvailability:<span class="cov0" title="0">
                m.metrics.SLIAvailability.WithLabelValues(slo.Service, slo.SLI.Endpoint).Set(violation.CurrentValue)</span>
        case SLITypeLatency:<span class="cov0" title="0">
                m.metrics.SLILatency.WithLabelValues(slo.Service, slo.SLI.Endpoint).Observe(violation.CurrentValue)</span>
        case SLITypeErrorRate:<span class="cov0" title="0">
                m.metrics.SLIErrorRate.WithLabelValues(slo.Service, slo.SLI.Endpoint).Set(violation.CurrentValue)</span>
        case SLITypeThroughput:<span class="cov0" title="0">
                m.metrics.SLIThroughput.WithLabelValues(slo.Service, slo.SLI.Endpoint).Set(violation.CurrentValue)</span>
        }
}

// GetSLOReport generates a report of all SLO statuses
func (m *SLOManager) GetSLOReport(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="1">{
        report := make(map[string]interface{})

        var totalSLOs, violatedSLOs int
        var sloResults []map[string]interface{}

        for _, slo := range m.slos </span><span class="cov4" title="11">{
                met, result, err := m.EvaluateSLO(ctx, slo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="11">totalSLOs++
                if !met </span><span class="cov2" title="3">{
                        violatedSLOs++
                }</span>

                <span class="cov4" title="11">sloResult := map[string]interface{}{
                        "name":          slo.Name,
                        "service":       slo.Service,
                        "type":          slo.SLI.Type,
                        "target":        slo.Target,
                        "current_value": result.Value,
                        "met":           met,
                        "severity":      slo.Severity,
                        "window":        slo.Window,
                }

                sloResults = append(sloResults, sloResult)</span>
        }

        <span class="cov1" title="1">report["total_slos"] = totalSLOs
        report["violated_slos"] = violatedSLOs
        report["slo_success_rate"] = float64(totalSLOs-violatedSLOs) / float64(totalSLOs)
        report["slos"] = sloResults
        report["timestamp"] = time.Now()

        return report, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "net/url"
        "time"

        "github.com/sirupsen/logrus"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
        "go.opentelemetry.io/otel/trace"
)

// TracingConfig holds configuration for tracing
type TracingConfig struct {
        ServiceName    string
        ServiceVersion string
        Environment    string
        JaegerEndpoint string
        SamplingRate   float64
        Enabled        bool
}

// TracingService provides distributed tracing functionality
type TracingService struct {
        tracer trace.Tracer
        config *TracingConfig
        logger *logrus.Logger
}

// NewTracingService creates a new tracing service
func NewTracingService(config *TracingConfig, logger *logrus.Logger) (*TracingService, error) <span class="cov9" title="32">{
        if !config.Enabled </span><span class="cov9" title="30">{
                logger.Info("Tracing is disabled")
                return &amp;TracingService{
                        tracer: trace.NewNoopTracerProvider().Tracer("noop"),
                        config: config,
                        logger: logger,
                }, nil
        }</span>

        // Validate Jaeger endpoint URL
        <span class="cov2" title="2">parsedURL, err := url.Parse(config.JaegerEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Jaeger exporter: invalid endpoint URL: %w", err)
        }</span>
        <span class="cov2" title="2">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to create Jaeger exporter: invalid URL scheme '%s', expected 'http' or 'https'", parsedURL.Scheme)
        }</span>

        // Create Jaeger exporter
        <span class="cov0" title="0">exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(config.JaegerEndpoint)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Jaeger exporter: %w", err)
        }</span>

        // Create resource
        <span class="cov0" title="0">res, err := resource.New(
                context.Background(),
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(config.ServiceName),
                        semconv.ServiceVersionKey.String(config.ServiceVersion),
                        semconv.DeploymentEnvironmentKey.String(config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Create trace provider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
                sdktrace.WithSampler(sdktrace.TraceIDRatioBased(config.SamplingRate)),
        )

        // Set global trace provider
        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        tracer := otel.Tracer(config.ServiceName)

        logger.Info("Tracing initialized successfully",
                logrus.Fields{
                        "service":         config.ServiceName,
                        "version":         config.ServiceVersion,
                        "environment":     config.Environment,
                        "jaeger_endpoint": config.JaegerEndpoint,
                        "sampling_rate":   config.SamplingRate,
                },
        )

        return &amp;TracingService{
                tracer: tracer,
                config: config,
                logger: logger,
        }, nil</span>
}

// StartSpan starts a new span
func (s *TracingService) StartSpan(ctx context.Context, name string, opts ...trace.SpanStartOption) (context.Context, trace.Span) <span class="cov10" title="34">{
        return s.tracer.Start(ctx, name, opts...)
}</span>

// SpanFromContext returns the current span from context
func (s *TracingService) SpanFromContext(ctx context.Context) trace.Span <span class="cov1" title="1">{
        return trace.SpanFromContext(ctx)
}</span>

// WithSpan executes a function with a new span
func (s *TracingService) WithSpan(ctx context.Context, name string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov8" title="21">{
        ctx, span := s.StartSpan(ctx, name)
        defer span.End()

        if err := fn(ctx, span); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov8" title="20">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// TraceHTTPRequest traces an HTTP request
func (s *TracingService) TraceHTTPRequest(ctx context.Context, method, path, userAgent string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, fmt.Sprintf("HTTP %s %s", method, path), func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("http.method", method),
                        attribute.String("http.path", path),
                        attribute.String("http.user_agent", userAgent),
                        attribute.String("component", "http"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceDatabaseQuery traces a database query
func (s *TracingService) TraceDatabaseQuery(ctx context.Context, table, operation, query string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, fmt.Sprintf("DB %s %s", operation, table), func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("db.table", table),
                        attribute.String("db.operation", operation),
                        attribute.String("db.statement", query),
                        attribute.String("component", "database"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceS3Operation traces an S3 operation
func (s *TracingService) TraceS3Operation(ctx context.Context, operation, bucket, key string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, fmt.Sprintf("S3 %s", operation), func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("s3.operation", operation),
                        attribute.String("s3.bucket", bucket),
                        attribute.String("s3.key", key),
                        attribute.String("component", "s3"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceFileProcessing traces file processing operations
func (s *TracingService) TraceFileProcessing(ctx context.Context, provider, fileURL string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, "File Processing", func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("file.provider", provider),
                        attribute.String("file.url", fileURL),
                        attribute.String("component", "file_processor"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceReviewProcessing traces review processing
func (s *TracingService) TraceReviewProcessing(ctx context.Context, provider, hotelID string, reviewCount int, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, "Review Processing", func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("review.provider", provider),
                        attribute.String("review.hotel_id", hotelID),
                        attribute.Int("review.count", reviewCount),
                        attribute.String("component", "review_processor"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceCacheOperation traces cache operations
func (s *TracingService) TraceCacheOperation(ctx context.Context, operation, key string, hit bool, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, fmt.Sprintf("Cache %s", operation), func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("cache.operation", operation),
                        attribute.String("cache.key", key),
                        attribute.Bool("cache.hit", hit),
                        attribute.String("component", "cache"),
                )
                return fn(ctx, span)
        }</span>)
}

// TraceCircuitBreakerOperation traces circuit breaker operations
func (s *TracingService) TraceCircuitBreakerOperation(ctx context.Context, component, state string, fn func(ctx context.Context, span trace.Span) error) error <span class="cov1" title="1">{
        return s.WithSpan(ctx, fmt.Sprintf("Circuit Breaker %s", component), func(ctx context.Context, span trace.Span) error </span><span class="cov1" title="1">{
                span.SetAttributes(
                        attribute.String("circuit_breaker.component", component),
                        attribute.String("circuit_breaker.state", state),
                        attribute.String("component", "circuit_breaker"),
                )
                return fn(ctx, span)
        }</span>)
}

// AddSpanAttributes adds attributes to the current span
func (s *TracingService) AddSpanAttributes(ctx context.Context, attrs ...attribute.KeyValue) <span class="cov7" title="12">{
        span := trace.SpanFromContext(ctx)
        span.SetAttributes(attrs...)
}</span>

// AddSpanEvent adds an event to the current span
func (s *TracingService) AddSpanEvent(ctx context.Context, name string, attrs ...attribute.KeyValue) <span class="cov1" title="1">{
        span := trace.SpanFromContext(ctx)
        span.AddEvent(name, trace.WithAttributes(attrs...))
}</span>

// RecordError records an error in the current span
func (s *TracingService) RecordError(ctx context.Context, err error) <span class="cov1" title="1">{
        span := trace.SpanFromContext(ctx)
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
}</span>

// SetSpanStatus sets the status of the current span
func (s *TracingService) SetSpanStatus(ctx context.Context, code codes.Code, description string) <span class="cov2" title="2">{
        span := trace.SpanFromContext(ctx)
        span.SetStatus(code, description)
}</span>

// InjectTraceContext injects trace context into headers
func (s *TracingService) InjectTraceContext(ctx context.Context, carrier propagation.TextMapCarrier) <span class="cov1" title="1">{
        otel.GetTextMapPropagator().Inject(ctx, carrier)
}</span>

// ExtractTraceContext extracts trace context from headers
func (s *TracingService) ExtractTraceContext(ctx context.Context, carrier propagation.TextMapCarrier) context.Context <span class="cov1" title="1">{
        return otel.GetTextMapPropagator().Extract(ctx, carrier)
}</span>

// Close closes the tracing service
func (s *TracingService) Close(ctx context.Context) error <span class="cov1" title="1">{
        if !s.config.Enabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Get the trace provider and shut it down
        <span class="cov0" title="0">if tp, ok := otel.GetTracerProvider().(*sdktrace.TracerProvider); ok </span><span class="cov0" title="0">{
                return tp.Shutdown(ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TraceableFunction is a function that can be traced
type TraceableFunction func(ctx context.Context, span trace.Span) error

// TraceOperation is a generic tracing wrapper for operations
func (s *TracingService) TraceOperation(ctx context.Context, operationName string, attributes []attribute.KeyValue, fn TraceableFunction) error <span class="cov3" title="3">{
        ctx, span := s.StartSpan(ctx, operationName)
        defer span.End()

        if len(attributes) &gt; 0 </span><span class="cov2" title="2">{
                span.SetAttributes(attributes...)
        }</span>

        <span class="cov3" title="3">if err := fn(ctx, span); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov2" title="2">span.SetStatus(codes.Ok, "")
        return nil</span>
}

// MeasureLatency measures the latency of an operation and records it as a span attribute
func (s *TracingService) MeasureLatency(ctx context.Context, operationName string, fn func(ctx context.Context) error) error <span class="cov2" title="2">{
        start := time.Now()
        ctx, span := s.StartSpan(ctx, operationName)
        defer func() </span><span class="cov2" title="2">{
                latency := time.Since(start)
                span.SetAttributes(attribute.Float64("latency.seconds", latency.Seconds()))
                span.End()
        }</span>()

        <span class="cov2" title="2">if err := fn(ctx); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return err
        }</span>

        <span class="cov1" title="1">span.SetStatus(codes.Ok, "")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/redis/go-redis/v9"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/gkbiswas/hotel-reviews-microservice/internal/monitoring"
)

// ShutdownManager handles graceful shutdown of all application components
type ShutdownManager struct {
        logger   monitoring.Logger
        config   *ShutdownConfig
        hooks    []ShutdownHook
        mu       sync.RWMutex
        shutdown chan struct{}
        done     chan struct{}
}

// ShutdownConfig configures graceful shutdown behavior
type ShutdownConfig struct {
        // Timeout configuration
        GracefulTimeout time.Duration `json:"graceful_timeout" validate:"min=1s"`
        ServerTimeout   time.Duration `json:"server_timeout" validate:"min=1s"`
        DatabaseTimeout time.Duration `json:"database_timeout" validate:"min=1s"`
        WorkerTimeout   time.Duration `json:"worker_timeout" validate:"min=1s"`
        ExternalTimeout time.Duration `json:"external_timeout" validate:"min=1s"`

        // Signal handling
        Signals          []os.Signal   `json:"-"`
        ForceKillTimeout time.Duration `json:"force_kill_timeout" validate:"min=1s"`

        // Shutdown behavior
        EnablePreShutdownHook bool          `json:"enable_pre_shutdown_hook"`
        PreShutdownDelay      time.Duration `json:"pre_shutdown_delay"`
        LogShutdownProgress   bool          `json:"log_shutdown_progress"`

        // Health check during shutdown
        DisableHealthCheck     bool          `json:"disable_health_check"`
        HealthCheckGracePeriod time.Duration `json:"health_check_grace_period"`
}

// ShutdownHook represents a cleanup function to be called during shutdown
type ShutdownHook struct {
        Name     string
        Priority int // Lower numbers run first
        Timeout  time.Duration
        Cleanup  func(ctx context.Context) error
}

// ResourceManager tracks application resources for cleanup
type ResourceManager struct {
        httpServer    *http.Server
        dbPool        *pgxpool.Pool
        redisClient   *redis.Client
        workers       []Worker
        externalConns []ExternalConnection
        monitors      []interface{} // Generic monitors
        optimizers    []ResourceOptimizer
        watchers      []ConfigWatcher
}

// Worker represents a background worker that can be gracefully stopped
type Worker interface {
        Stop(ctx context.Context) error
        Name() string
}

// ExternalConnection represents an external service connection
type ExternalConnection interface {
        Close(ctx context.Context) error
        Name() string
}

// ResourceOptimizer represents a resource optimizer that needs cleanup
type ResourceOptimizer interface {
        Stop() error
        Name() string
}

// ConfigWatcher represents a configuration watcher
type ConfigWatcher interface {
        Stop() error
        Name() string
}

// DefaultShutdownConfig returns sensible defaults for shutdown configuration
func DefaultShutdownConfig() *ShutdownConfig <span class="cov8" title="11">{
        return &amp;ShutdownConfig{
                GracefulTimeout:        30 * time.Second,
                ServerTimeout:          10 * time.Second,
                DatabaseTimeout:        5 * time.Second,
                WorkerTimeout:          15 * time.Second,
                ExternalTimeout:        5 * time.Second,
                Signals:                []os.Signal{syscall.SIGINT, syscall.SIGTERM},
                ForceKillTimeout:       45 * time.Second,
                EnablePreShutdownHook:  true,
                PreShutdownDelay:       1 * time.Second,
                LogShutdownProgress:    true,
                DisableHealthCheck:     false,
                HealthCheckGracePeriod: 2 * time.Second,
        }
}</span>

// NewShutdownManager creates a new shutdown manager
func NewShutdownManager(logger monitoring.Logger, config *ShutdownConfig) *ShutdownManager <span class="cov8" title="11">{
        if config == nil </span><span class="cov6" title="6">{
                config = DefaultShutdownConfig()
        }</span>

        <span class="cov8" title="11">return &amp;ShutdownManager{
                logger:   logger,
                config:   config,
                hooks:    make([]ShutdownHook, 0),
                shutdown: make(chan struct{}),
                done:     make(chan struct{}),
        }</span>
}

// RegisterResource registers various application resources for cleanup
func (sm *ShutdownManager) RegisterResource(resource interface{}) error <span class="cov10" title="17">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        switch r := resource.(type) </span>{
        case *ResourceManager:<span class="cov1" title="1">
                // Register cleanup hooks for all resources in the manager
                return sm.registerResourceManager(r)</span>
        case *http.Server:<span class="cov1" title="1">
                return sm.registerHTTPServer(r)</span>
        case *pgxpool.Pool:<span class="cov0" title="0">
                return sm.registerDatabase(r)</span>
        case *redis.Client:<span class="cov0" title="0">
                return sm.registerRedis(r)</span>
        case Worker:<span class="cov8" title="11">
                return sm.registerWorker(r)</span>
        case ExternalConnection:<span class="cov3" title="2">
                return sm.registerExternalConnection(r)</span>
        case ResourceOptimizer:<span class="cov1" title="1">
                return sm.registerOptimizer(r)</span>
        case ConfigWatcher:<span class="cov0" title="0">
                return sm.registerWatcher(r)</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported resource type: %T", resource)</span>
        }
}

// registerResourceManager registers all resources from a resource manager
func (sm *ShutdownManager) registerResourceManager(rm *ResourceManager) error <span class="cov1" title="1">{
        // Register HTTP server
        if rm.httpServer != nil </span><span class="cov1" title="1">{
                if err := sm.registerHTTPServer(rm.httpServer); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register database pool
        <span class="cov1" title="1">if rm.dbPool != nil </span><span class="cov0" title="0">{
                if err := sm.registerDatabase(rm.dbPool); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register Redis client
        <span class="cov1" title="1">if rm.redisClient != nil </span><span class="cov0" title="0">{
                if err := sm.registerRedis(rm.redisClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register workers
        <span class="cov1" title="1">for _, worker := range rm.workers </span><span class="cov3" title="2">{
                if err := sm.registerWorker(worker); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register external connections
        <span class="cov1" title="1">for _, conn := range rm.externalConns </span><span class="cov1" title="1">{
                if err := sm.registerExternalConnection(conn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register optimizers
        <span class="cov1" title="1">for _, optimizer := range rm.optimizers </span><span class="cov1" title="1">{
                if err := sm.registerOptimizer(optimizer); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Register watchers
        <span class="cov1" title="1">for _, watcher := range rm.watchers </span><span class="cov1" title="1">{
                if err := sm.registerWatcher(watcher); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// registerHTTPServer registers HTTP server for graceful shutdown
func (sm *ShutdownManager) registerHTTPServer(server *http.Server) error <span class="cov3" title="2">{
        hook := ShutdownHook{
                Name:     "http_server",
                Priority: 1, // Shutdown HTTP server first
                Timeout:  sm.config.ServerTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        sm.logger.Info("Shutting down HTTP server")

                        // Create timeout context for server shutdown
                        shutdownCtx, cancel := context.WithTimeout(ctx, sm.config.ServerTimeout)
                        defer cancel()

                        return server.Shutdown(shutdownCtx)
                }</span>,
        }

        <span class="cov3" title="2">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerDatabase registers database pool for cleanup
func (sm *ShutdownManager) registerDatabase(pool *pgxpool.Pool) error <span class="cov0" title="0">{
        hook := ShutdownHook{
                Name:     "database_pool",
                Priority: 3, // Close database after workers
                Timeout:  sm.config.DatabaseTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        sm.logger.Info("Closing database connections")

                        // Wait for active connections to finish or timeout
                        done := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                pool.Close()
                                close(done)
                        }</span>()

                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sm.logger.Warn("Database shutdown timed out, forcing close")
                                pool.Close()
                                return ctx.Err()</span>
                        }
                },
        }

        <span class="cov0" title="0">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerRedis registers Redis client for cleanup
func (sm *ShutdownManager) registerRedis(client *redis.Client) error <span class="cov0" title="0">{
        hook := ShutdownHook{
                Name:     "redis_client",
                Priority: 3, // Close Redis after workers
                Timeout:  sm.config.ExternalTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        sm.logger.Info("Closing Redis connections")
                        return client.Close()
                }</span>,
        }

        <span class="cov0" title="0">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerWorker registers a background worker for shutdown
func (sm *ShutdownManager) registerWorker(worker Worker) error <span class="cov9" title="13">{
        hook := ShutdownHook{
                Name:     fmt.Sprintf("worker_%s", worker.Name()),
                Priority: 2, // Stop workers after HTTP server
                Timeout:  sm.config.WorkerTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov7" title="8">{
                        sm.logger.Info("Stopping background worker", "worker", worker.Name())
                        return worker.Stop(ctx)
                }</span>,
        }

        <span class="cov9" title="13">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerExternalConnection registers an external connection for cleanup
func (sm *ShutdownManager) registerExternalConnection(conn ExternalConnection) error <span class="cov4" title="3">{
        hook := ShutdownHook{
                Name:     fmt.Sprintf("external_%s", conn.Name()),
                Priority: 4, // Close external connections last
                Timeout:  sm.config.ExternalTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov1" title="1">{
                        sm.logger.Info("Closing external connection", "connection", conn.Name())
                        return conn.Close(ctx)
                }</span>,
        }

        <span class="cov4" title="3">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerOptimizer registers a resource optimizer for cleanup
func (sm *ShutdownManager) registerOptimizer(optimizer ResourceOptimizer) error <span class="cov3" title="2">{
        hook := ShutdownHook{
                Name:     fmt.Sprintf("optimizer_%s", optimizer.Name()),
                Priority: 2, // Stop optimizers with workers
                Timeout:  sm.config.WorkerTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov1" title="1">{
                        sm.logger.Info("Stopping optimizer", "optimizer", optimizer.Name())
                        return optimizer.Stop()
                }</span>,
        }

        <span class="cov3" title="2">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// registerWatcher registers a configuration watcher for cleanup
func (sm *ShutdownManager) registerWatcher(watcher ConfigWatcher) error <span class="cov1" title="1">{
        hook := ShutdownHook{
                Name:     fmt.Sprintf("watcher_%s", watcher.Name()),
                Priority: 2, // Stop watchers with workers
                Timeout:  sm.config.WorkerTimeout,
                Cleanup: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        sm.logger.Info("Stopping configuration watcher", "watcher", watcher.Name())
                        return watcher.Stop()
                }</span>,
        }

        <span class="cov1" title="1">sm.hooks = append(sm.hooks, hook)
        return nil</span>
}

// AddCustomHook adds a custom shutdown hook
func (sm *ShutdownManager) AddCustomHook(hook ShutdownHook) <span class="cov5" title="4">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        sm.hooks = append(sm.hooks, hook)
        sm.logger.Debug("Added custom shutdown hook", "name", hook.Name, "priority", hook.Priority)
}</span>

// WaitForShutdown blocks until shutdown signal is received
func (sm *ShutdownManager) WaitForShutdown() error <span class="cov5" title="4">{
        // Setup signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, sm.config.Signals...)

        sm.logger.Info("Shutdown manager started, waiting for signal...")

        // Wait for shutdown signal
        select </span>{
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                sm.logger.Info("Received shutdown signal", "signal", sig.String())
                return sm.initiateShutdown()</span>

        case &lt;-sm.shutdown:<span class="cov5" title="4">
                sm.logger.Info("Programmatic shutdown initiated")
                return sm.initiateShutdown()</span>
        }
}

// Shutdown initiates programmatic shutdown
func (sm *ShutdownManager) Shutdown() <span class="cov6" title="6">{
        select </span>{
        case sm.shutdown &lt;- struct{}{}:<span class="cov5" title="4"></span>
        default:<span class="cov3" title="2"></span>
                // Already shutting down
        }
}

// initiateShutdown performs the actual shutdown sequence
func (sm *ShutdownManager) initiateShutdown() error <span class="cov5" title="4">{
        defer close(sm.done)

        sm.logger.Info("Initiating graceful shutdown")

        // Pre-shutdown hook
        if sm.config.EnablePreShutdownHook </span><span class="cov5" title="4">{
                sm.logger.Info("Running pre-shutdown delay", "delay", sm.config.PreShutdownDelay)
                time.Sleep(sm.config.PreShutdownDelay)
        }</span>

        // Disable health checks if configured
        <span class="cov5" title="4">if sm.config.DisableHealthCheck </span><span class="cov0" title="0">{
                sm.logger.Info("Disabling health checks during shutdown")
                time.Sleep(sm.config.HealthCheckGracePeriod)
        }</span>

        // Create shutdown context with timeout
        <span class="cov5" title="4">ctx, cancel := context.WithTimeout(context.Background(), sm.config.GracefulTimeout)
        defer cancel()

        // Sort hooks by priority
        sm.sortHooksByPriority()

        // Execute shutdown hooks
        var wg sync.WaitGroup
        errorChan := make(chan error, len(sm.hooks))

        sm.logger.Info("Executing shutdown hooks", "count", len(sm.hooks))

        for _, hook := range sm.hooks </span><span class="cov8" title="10">{
                wg.Add(1)
                go sm.executeHook(ctx, hook, &amp;wg, errorChan)
        }</span>

        // Wait for all hooks to complete or timeout
        <span class="cov5" title="4">go func() </span><span class="cov5" title="4">{
                wg.Wait()
                close(errorChan)
        }</span>()

        // Collect errors
        <span class="cov5" title="4">var errors []error
        for err := range errorChan </span><span class="cov3" title="2">{
                if err != nil </span><span class="cov3" title="2">{
                        errors = append(errors, err)
                }</span>
        }

        // Force kill timeout as last resort
        <span class="cov5" title="4">go sm.forceKillTimer()

        if len(errors) &gt; 0 </span><span class="cov3" title="2">{
                sm.logger.Error("Shutdown completed with errors", "error_count", len(errors))
                for _, err := range errors </span><span class="cov3" title="2">{
                        sm.logger.Error("Shutdown error", "error", err)
                }</span>
                <span class="cov3" title="2">return fmt.Errorf("shutdown completed with %d errors", len(errors))</span>
        }

        <span class="cov3" title="2">sm.logger.Info("Graceful shutdown completed successfully")
        return nil</span>
}

// executeHook executes a single shutdown hook
func (sm *ShutdownManager) executeHook(ctx context.Context, hook ShutdownHook, wg *sync.WaitGroup, errorChan chan&lt;- error) <span class="cov8" title="10">{
        defer wg.Done()

        if sm.config.LogShutdownProgress </span><span class="cov8" title="10">{
                sm.logger.Debug("Executing shutdown hook", "name", hook.Name, "priority", hook.Priority)
        }</span>

        // Create timeout context for this specific hook
        <span class="cov8" title="10">hookCtx, cancel := context.WithTimeout(ctx, hook.Timeout)
        defer cancel()

        // Execute hook with timeout
        done := make(chan error, 1)
        go func() </span><span class="cov8" title="10">{
                done &lt;- hook.Cleanup(hookCtx)
        }</span>()

        <span class="cov8" title="10">select </span>{
        case err := &lt;-done:<span class="cov7" title="9">
                if err != nil </span><span class="cov1" title="1">{
                        sm.logger.Error("Shutdown hook failed", "name", hook.Name, "error", err)
                        errorChan &lt;- fmt.Errorf("hook %s failed: %w", hook.Name, err)
                }</span> else<span class="cov7" title="8"> if sm.config.LogShutdownProgress </span><span class="cov7" title="8">{
                        sm.logger.Debug("Shutdown hook completed", "name", hook.Name)
                }</span>

        case &lt;-hookCtx.Done():<span class="cov1" title="1">
                sm.logger.Warn("Shutdown hook timed out", "name", hook.Name, "timeout", hook.Timeout)
                errorChan &lt;- fmt.Errorf("hook %s timed out after %v", hook.Name, hook.Timeout)</span>
        }
}

// sortHooksByPriority sorts shutdown hooks by priority (lower numbers first)
func (sm *ShutdownManager) sortHooksByPriority() <span class="cov6" title="5">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Simple bubble sort by priority
        n := len(sm.hooks)
        for i := 0; i &lt; n-1; i++ </span><span class="cov7" title="8">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov9" title="16">{
                        if sm.hooks[j].Priority &gt; sm.hooks[j+1].Priority </span><span class="cov4" title="3">{
                                sm.hooks[j], sm.hooks[j+1] = sm.hooks[j+1], sm.hooks[j]
                        }</span>
                }
        }
}

// forceKillTimer implements force kill timeout as last resort
func (sm *ShutdownManager) forceKillTimer() <span class="cov5" title="4">{
        time.Sleep(sm.config.ForceKillTimeout)

        sm.logger.Error("Force kill timeout reached, terminating process")
        os.Exit(1)
}</span>

// GetShutdownMetrics returns metrics about the shutdown process
func (sm *ShutdownManager) GetShutdownMetrics() map[string]interface{} <span class="cov1" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        return map[string]interface{}{
                "registered_hooks":   len(sm.hooks),
                "graceful_timeout":   sm.config.GracefulTimeout,
                "force_kill_timeout": sm.config.ForceKillTimeout,
                "shutdown_initiated": sm.isShutdownInitiated(),
        }
}</span>

// isShutdownInitiated checks if shutdown has been initiated
func (sm *ShutdownManager) isShutdownInitiated() bool <span class="cov1" title="1">{
        select </span>{
        case &lt;-sm.done:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

// WaitForCompletion waits for shutdown to complete
func (sm *ShutdownManager) WaitForCompletion() <span class="cov0" title="0">{
        &lt;-sm.done
}</span>

// NewResourceManager creates a new resource manager
func NewResourceManager() *ResourceManager <span class="cov1" title="1">{
        return &amp;ResourceManager{
                workers:       make([]Worker, 0),
                externalConns: make([]ExternalConnection, 0),
                monitors:      make([]interface{}, 0),
                optimizers:    make([]ResourceOptimizer, 0),
                watchers:      make([]ConfigWatcher, 0),
        }
}</span>

// AddHTTPServer adds an HTTP server to the resource manager
func (rm *ResourceManager) AddHTTPServer(server *http.Server) <span class="cov1" title="1">{
        rm.httpServer = server
}</span>

// AddDatabase adds a database pool to the resource manager
func (rm *ResourceManager) AddDatabase(pool *pgxpool.Pool) <span class="cov0" title="0">{
        rm.dbPool = pool
}</span>

// AddRedis adds a Redis client to the resource manager
func (rm *ResourceManager) AddRedis(client *redis.Client) <span class="cov0" title="0">{
        rm.redisClient = client
}</span>

// AddWorker adds a worker to the resource manager
func (rm *ResourceManager) AddWorker(worker Worker) <span class="cov3" title="2">{
        rm.workers = append(rm.workers, worker)
}</span>

// AddExternalConnection adds an external connection to the resource manager
func (rm *ResourceManager) AddExternalConnection(conn ExternalConnection) <span class="cov1" title="1">{
        rm.externalConns = append(rm.externalConns, conn)
}</span>

// AddOptimizer adds a resource optimizer to the resource manager
func (rm *ResourceManager) AddOptimizer(optimizer ResourceOptimizer) <span class="cov1" title="1">{
        rm.optimizers = append(rm.optimizers, optimizer)
}</span>

// AddWatcher adds a configuration watcher to the resource manager
func (rm *ResourceManager) AddWatcher(watcher ConfigWatcher) <span class="cov1" title="1">{
        rm.watchers = append(rm.watchers, watcher)
}</span>

// DBOptimizerWrapper wraps infrastructure.DBOptimizer to implement ResourceOptimizer
type DBOptimizerWrapper struct {
        optimizer *infrastructure.DBOptimizer
}

// NewDBOptimizerWrapper creates a new wrapper for DBOptimizer
func NewDBOptimizerWrapper(optimizer *infrastructure.DBOptimizer) *DBOptimizerWrapper <span class="cov0" title="0">{
        return &amp;DBOptimizerWrapper{optimizer: optimizer}
}</span>

// Stop implements ResourceOptimizer interface
func (w *DBOptimizerWrapper) Stop() error <span class="cov1" title="1">{
        if w.optimizer == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("db optimizer is nil")
        }</span>
        <span class="cov0" title="0">return w.optimizer.Stop()</span>
}

// Name implements ResourceOptimizer interface
func (w *DBOptimizerWrapper) Name() string <span class="cov1" title="1">{
        return "db_optimizer"
}</span>

// ConfigWatcherWrapper wraps infrastructure.ConfigWatcher to implement ConfigWatcher
type ConfigWatcherWrapper struct {
        watcher *infrastructure.ConfigWatcher
}

// NewConfigWatcherWrapper creates a new wrapper for ConfigWatcher
func NewConfigWatcherWrapper(watcher *infrastructure.ConfigWatcher) *ConfigWatcherWrapper <span class="cov0" title="0">{
        return &amp;ConfigWatcherWrapper{watcher: watcher}
}</span>

// Stop implements ConfigWatcher interface
func (w *ConfigWatcherWrapper) Stop() error <span class="cov1" title="1">{
        if w.watcher == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("config watcher is nil")
        }</span>
        <span class="cov0" title="0">return w.watcher.Stop()</span>
}

// Name implements ConfigWatcher interface
func (w *ConfigWatcherWrapper) Name() string <span class="cov1" title="1">{
        return "config_watcher"
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package server

import (
        "context"

        "github.com/gkbiswas/hotel-reviews-microservice/internal/infrastructure"
        "github.com/segmentio/kafka-go"
)

// KafkaWriterWrapper wraps Kafka writer for graceful shutdown
type KafkaWriterWrapper struct {
        Writer *kafka.Writer
}

func (w *KafkaWriterWrapper) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return w.Writer.Close()
}</span>

func (w *KafkaWriterWrapper) Name() string <span class="cov0" title="0">{
        return "kafka_writer"
}</span>

// KafkaReaderWrapper wraps Kafka reader for graceful shutdown
type KafkaReaderWrapper struct {
        Reader *kafka.Reader
}

func (r *KafkaReaderWrapper) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return r.Reader.Close()
}</span>

func (r *KafkaReaderWrapper) Name() string <span class="cov0" title="0">{
        return "kafka_reader"
}</span>

// AsyncProcessorWrapper wraps async processor for graceful shutdown
type AsyncProcessorWrapper struct {
        Processor *infrastructure.AsyncProcessor
}

func (a *AsyncProcessorWrapper) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if a.Processor == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.Processor.Stop(ctx)</span>
}

func (a *AsyncProcessorWrapper) Name() string <span class="cov0" title="0">{
        return "async_processor"
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package config

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/spf13/viper"
)

// Config represents the main configuration structure
type Config struct {
        Database     DatabaseConfig     `mapstructure:"database" json:"database"`
        S3           S3Config           `mapstructure:"s3" json:"s3"`
        Server       ServerConfig       `mapstructure:"server" json:"server"`
        Log          LogConfig          `mapstructure:"log" json:"log"`
        Cache        CacheConfig        `mapstructure:"cache" json:"cache"`
        Metrics      MetricsConfig      `mapstructure:"metrics" json:"metrics"`
        Notification NotificationConfig `mapstructure:"notification" json:"notification"`
        Processing   ProcessingConfig   `mapstructure:"processing" json:"processing"`
        Security     SecurityConfig     `mapstructure:"security" json:"security"`
        Auth         AuthConfig         `mapstructure:"auth" json:"auth"`
        Kafka        KafkaConfig        `mapstructure:"kafka" json:"kafka"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Host            string        `mapstructure:"host" json:"host" validate:"required"`
        Port            int           `mapstructure:"port" json:"port" validate:"required,min=1,max=65535"`
        User            string        `mapstructure:"user" json:"user" validate:"required"`
        Password        string        `mapstructure:"password" json:"password" validate:"required"`
        Name            string        `mapstructure:"name" json:"name" validate:"required"`
        SSLMode         string        `mapstructure:"ssl_mode" json:"ssl_mode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns" json:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns" json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime" json:"conn_max_lifetime"`
        ConnMaxIdleTime time.Duration `mapstructure:"conn_max_idle_time" json:"conn_max_idle_time"`
        TimeZone        string        `mapstructure:"timezone" json:"timezone"`
        LogLevel        string        `mapstructure:"log_level" json:"log_level"`
}

// S3Config represents AWS S3 configuration
type S3Config struct {
        Region           string        `mapstructure:"region" json:"region" validate:"required"`
        AccessKeyID      string        `mapstructure:"access_key_id" json:"access_key_id" validate:"required"`
        SecretAccessKey  string        `mapstructure:"secret_access_key" json:"secret_access_key" validate:"required"`
        SessionToken     string        `mapstructure:"session_token" json:"session_token"`
        Bucket           string        `mapstructure:"bucket" json:"bucket" validate:"required"`
        Endpoint         string        `mapstructure:"endpoint" json:"endpoint"`
        UseSSL           bool          `mapstructure:"use_ssl" json:"use_ssl"`
        ForcePathStyle   bool          `mapstructure:"force_path_style" json:"force_path_style"`
        Timeout          time.Duration `mapstructure:"timeout" json:"timeout"`
        RetryCount       int           `mapstructure:"retry_count" json:"retry_count"`
        RetryDelay       time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        UploadPartSize   int64         `mapstructure:"upload_part_size" json:"upload_part_size"`
        DownloadPartSize int64         `mapstructure:"download_part_size" json:"download_part_size"`
}

// ServerConfig represents HTTP server configuration
type ServerConfig struct {
        Host            string        `mapstructure:"host" json:"host"`
        Port            int           `mapstructure:"port" json:"port" validate:"required,min=1,max=65535"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout" json:"write_timeout"`
        IdleTimeout     time.Duration `mapstructure:"idle_timeout" json:"idle_timeout"`
        ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout" json:"shutdown_timeout"`
        MaxHeaderBytes  int           `mapstructure:"max_header_bytes" json:"max_header_bytes"`
        EnableCORS      bool          `mapstructure:"enable_cors" json:"enable_cors"`
        EnableGzip      bool          `mapstructure:"enable_gzip" json:"enable_gzip"`
        EnableMetrics   bool          `mapstructure:"enable_metrics" json:"enable_metrics"`
        EnablePprof     bool          `mapstructure:"enable_pprof" json:"enable_pprof"`
        TLSCertFile     string        `mapstructure:"tls_cert_file" json:"tls_cert_file"`
        TLSKeyFile      string        `mapstructure:"tls_key_file" json:"tls_key_file"`
        TrustedProxies  []string      `mapstructure:"trusted_proxies" json:"trusted_proxies"`
}

// LogConfig represents logging configuration
type LogConfig struct {
        Level            string `mapstructure:"level" json:"level" validate:"required,oneof=debug info warn error"`
        Format           string `mapstructure:"format" json:"format" validate:"required,oneof=json text"`
        Output           string `mapstructure:"output" json:"output" validate:"required,oneof=stdout stderr file"`
        FilePath         string `mapstructure:"file_path" json:"file_path"`
        MaxSize          int    `mapstructure:"max_size" json:"max_size"`
        MaxBackups       int    `mapstructure:"max_backups" json:"max_backups"`
        MaxAge           int    `mapstructure:"max_age" json:"max_age"`
        Compress         bool   `mapstructure:"compress" json:"compress"`
        EnableCaller     bool   `mapstructure:"enable_caller" json:"enable_caller"`
        EnableStacktrace bool   `mapstructure:"enable_stacktrace" json:"enable_stacktrace"`
}

// CacheConfig represents cache configuration
type CacheConfig struct {
        Type         string        `mapstructure:"type" json:"type" validate:"required,oneof=redis memory"`
        Host         string        `mapstructure:"host" json:"host"`
        Port         int           `mapstructure:"port" json:"port"`
        Password     string        `mapstructure:"password" json:"password"`
        Database     int           `mapstructure:"database" json:"database"`
        PoolSize     int           `mapstructure:"pool_size" json:"pool_size"`
        MinIdleConns int           `mapstructure:"min_idle_conns" json:"min_idle_conns"`
        DialTimeout  time.Duration `mapstructure:"dial_timeout" json:"dial_timeout"`
        ReadTimeout  time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
        WriteTimeout time.Duration `mapstructure:"write_timeout" json:"write_timeout"`
        TTL          time.Duration `mapstructure:"ttl" json:"ttl"`
        MaxMemory    int64         `mapstructure:"max_memory" json:"max_memory"`
}

// MetricsConfig represents metrics configuration
type MetricsConfig struct {
        Enabled     bool   `mapstructure:"enabled" json:"enabled"`
        Type        string `mapstructure:"type" json:"type" validate:"oneof=prometheus jaeger"`
        Host        string `mapstructure:"host" json:"host"`
        Port        int    `mapstructure:"port" json:"port"`
        Path        string `mapstructure:"path" json:"path"`
        Namespace   string `mapstructure:"namespace" json:"namespace"`
        ServiceName string `mapstructure:"service_name" json:"service_name"`
        Environment string `mapstructure:"environment" json:"environment"`
        Version     string `mapstructure:"version" json:"version"`
}

// NotificationConfig represents notification configuration
type NotificationConfig struct {
        Email EmailConfig `mapstructure:"email" json:"email"`
        Slack SlackConfig `mapstructure:"slack" json:"slack"`
}

// EmailConfig represents email notification configuration
type EmailConfig struct {
        Enabled  bool   `mapstructure:"enabled" json:"enabled"`
        Host     string `mapstructure:"host" json:"host"`
        Port     int    `mapstructure:"port" json:"port"`
        Username string `mapstructure:"username" json:"username"`
        Password string `mapstructure:"password" json:"password"`
        From     string `mapstructure:"from" json:"from"`
        UseTLS   bool   `mapstructure:"use_tls" json:"use_tls"`
}

// SlackConfig represents Slack notification configuration
type SlackConfig struct {
        Enabled    bool   `mapstructure:"enabled" json:"enabled"`
        WebhookURL string `mapstructure:"webhook_url" json:"webhook_url"`
        Channel    string `mapstructure:"channel" json:"channel"`
        Username   string `mapstructure:"username" json:"username"`
        IconEmoji  string `mapstructure:"icon_emoji" json:"icon_emoji"`
        IconURL    string `mapstructure:"icon_url" json:"icon_url"`
}

// ProcessingConfig represents file processing configuration
type ProcessingConfig struct {
        BatchSize            int           `mapstructure:"batch_size" json:"batch_size"`
        WorkerCount          int           `mapstructure:"worker_count" json:"worker_count"`
        MaxFileSize          int64         `mapstructure:"max_file_size" json:"max_file_size"`
        ProcessingTimeout    time.Duration `mapstructure:"processing_timeout" json:"processing_timeout"`
        MaxRetries           int           `mapstructure:"max_retries" json:"max_retries"`
        RetryDelay           time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        EnableValidation     bool          `mapstructure:"enable_validation" json:"enable_validation"`
        EnableDuplicateCheck bool          `mapstructure:"enable_duplicate_check" json:"enable_duplicate_check"`
        TempDirectory        string        `mapstructure:"temp_directory" json:"temp_directory"`
}

// SecurityConfig represents security configuration
type SecurityConfig struct {
        JWTSecret        string        `mapstructure:"jwt_secret" json:"jwt_secret" validate:"required"`
        JWTExpiration    time.Duration `mapstructure:"jwt_expiration" json:"jwt_expiration"`
        RateLimit        int           `mapstructure:"rate_limit" json:"rate_limit"`
        RateLimitWindow  time.Duration `mapstructure:"rate_limit_window" json:"rate_limit_window"`
        EnableAPIKey     bool          `mapstructure:"enable_api_key" json:"enable_api_key"`
        APIKeyHeader     string        `mapstructure:"api_key_header" json:"api_key_header"`
        EnableEncryption bool          `mapstructure:"enable_encryption" json:"enable_encryption"`
        EncryptionKey    string        `mapstructure:"encryption_key" json:"encryption_key"`
}

// AuthConfig represents authentication configuration
type AuthConfig struct {
        JWTSecret               string        `mapstructure:"jwt_secret" json:"jwt_secret" validate:"required"`
        JWTIssuer               string        `mapstructure:"jwt_issuer" json:"jwt_issuer"`
        AccessTokenExpiry       time.Duration `mapstructure:"access_token_expiry" json:"access_token_expiry"`
        RefreshTokenExpiry      time.Duration `mapstructure:"refresh_token_expiry" json:"refresh_token_expiry"`
        MaxLoginAttempts        int           `mapstructure:"max_login_attempts" json:"max_login_attempts"`
        LoginAttemptWindow      time.Duration `mapstructure:"login_attempt_window" json:"login_attempt_window"`
        AccountLockDuration     time.Duration `mapstructure:"account_lock_duration" json:"account_lock_duration"`
        PasswordMinLength       int           `mapstructure:"password_min_length" json:"password_min_length"`
        PasswordMaxLength       int           `mapstructure:"password_max_length" json:"password_max_length"`
        RequireStrongPassword   bool          `mapstructure:"require_strong_password" json:"require_strong_password"`
        EnableTwoFactor         bool          `mapstructure:"enable_two_factor" json:"enable_two_factor"`
        EnableEmailVerification bool          `mapstructure:"enable_email_verification" json:"enable_email_verification"`
        EnablePasswordReset     bool          `mapstructure:"enable_password_reset" json:"enable_password_reset"`
        EnableSessionCleanup    bool          `mapstructure:"enable_session_cleanup" json:"enable_session_cleanup"`
        SessionCleanupInterval  time.Duration `mapstructure:"session_cleanup_interval" json:"session_cleanup_interval"`
        EnableAuditLogging      bool          `mapstructure:"enable_audit_logging" json:"enable_audit_logging"`
        EnableRateLimiting      bool          `mapstructure:"enable_rate_limiting" json:"enable_rate_limiting"`
        BCryptCost              int           `mapstructure:"bcrypt_cost" json:"bcrypt_cost"`
        ApiKeyLength            int           `mapstructure:"api_key_length" json:"api_key_length"`
        ApiKeyPrefix            string        `mapstructure:"api_key_prefix" json:"api_key_prefix"`
        DefaultRole             string        `mapstructure:"default_role" json:"default_role"`
}

// KafkaConfig represents Kafka configuration
type KafkaConfig struct {
        Brokers              []string      `mapstructure:"brokers" json:"brokers" validate:"required"`
        ReviewTopic          string        `mapstructure:"review_topic" json:"review_topic" validate:"required"`
        ProcessingTopic      string        `mapstructure:"processing_topic" json:"processing_topic" validate:"required"`
        DeadLetterTopic      string        `mapstructure:"dead_letter_topic" json:"dead_letter_topic"`
        ConsumerGroup        string        `mapstructure:"consumer_group" json:"consumer_group" validate:"required"`
        BatchSize            int           `mapstructure:"batch_size" json:"batch_size"`
        BatchTimeout         time.Duration `mapstructure:"batch_timeout" json:"batch_timeout"`
        MaxRetries           int           `mapstructure:"max_retries" json:"max_retries"`
        RetryDelay           time.Duration `mapstructure:"retry_delay" json:"retry_delay"`
        EnableSASL           bool          `mapstructure:"enable_sasl" json:"enable_sasl"`
        SASLUsername         string        `mapstructure:"sasl_username" json:"sasl_username"`
        SASLPassword         string        `mapstructure:"sasl_password" json:"sasl_password"`
        EnableTLS            bool          `mapstructure:"enable_tls" json:"enable_tls"`
        MaxMessageSize       int           `mapstructure:"max_message_size" json:"max_message_size"`
        CompressionType      string        `mapstructure:"compression_type" json:"compression_type"`
        ProducerFlushTimeout time.Duration `mapstructure:"producer_flush_timeout" json:"producer_flush_timeout"`
        ConsumerTimeout      time.Duration `mapstructure:"consumer_timeout" json:"consumer_timeout"`
        EnableIdempotence    bool          `mapstructure:"enable_idempotence" json:"enable_idempotence"`
        Partitions           int           `mapstructure:"partitions" json:"partitions"`
        ReplicationFactor    int           `mapstructure:"replication_factor" json:"replication_factor"`
}

// Load loads configuration from environment variables and config files
func Load() (*Config, error) <span class="cov7" title="29">{
        v := viper.New()

        // Set default values
        setDefaults(v)

        // Configure viper
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(".")
        v.AddConfigPath("./configs")
        v.AddConfigPath("/etc/hotel-reviews")
        v.AddConfigPath("$HOME/.hotel-reviews")

        // Enable environment variable support
        v.SetEnvPrefix("HOTEL_REVIEWS")
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // Explicitly bind environment variables for required fields
        bindEnvironmentVariables(v)

        // Read configuration file
        if err := v.ReadInConfig(); err != nil </span><span class="cov7" title="27">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
                // Config file not found, continue with environment variables and defaults
        }

        // Unmarshal configuration
        <span class="cov7" title="28">var config Config
        if err := v.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        // Validate configuration
        <span class="cov7" title="28">if err := validate(&amp;config); err != nil </span><span class="cov6" title="22">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov4" title="6">return &amp;config, nil</span>
}

// bindEnvironmentVariables explicitly binds environment variables to viper keys
func bindEnvironmentVariables(v *viper.Viper) <span class="cov7" title="29">{
        // Database configuration
        v.BindEnv("database.host", "HOTEL_REVIEWS_DATABASE_HOST")
        v.BindEnv("database.port", "HOTEL_REVIEWS_DATABASE_PORT")
        v.BindEnv("database.user", "HOTEL_REVIEWS_DATABASE_USER")
        v.BindEnv("database.password", "HOTEL_REVIEWS_DATABASE_PASSWORD")
        v.BindEnv("database.name", "HOTEL_REVIEWS_DATABASE_NAME")
        v.BindEnv("database.ssl_mode", "HOTEL_REVIEWS_DATABASE_SSL_MODE")
        v.BindEnv("database.max_open_conns", "HOTEL_REVIEWS_DATABASE_MAX_OPEN_CONNS")
        v.BindEnv("database.max_idle_conns", "HOTEL_REVIEWS_DATABASE_MAX_IDLE_CONNS")
        v.BindEnv("database.conn_max_lifetime", "HOTEL_REVIEWS_DATABASE_CONN_MAX_LIFETIME")
        v.BindEnv("database.conn_max_idle_time", "HOTEL_REVIEWS_DATABASE_CONN_MAX_IDLE_TIME")
        v.BindEnv("database.timezone", "HOTEL_REVIEWS_DATABASE_TIMEZONE")
        v.BindEnv("database.log_level", "HOTEL_REVIEWS_DATABASE_LOG_LEVEL")

        // S3 configuration
        v.BindEnv("s3.region", "HOTEL_REVIEWS_S3_REGION")
        v.BindEnv("s3.access_key_id", "HOTEL_REVIEWS_S3_ACCESS_KEY_ID")
        v.BindEnv("s3.secret_access_key", "HOTEL_REVIEWS_S3_SECRET_ACCESS_KEY")
        v.BindEnv("s3.session_token", "HOTEL_REVIEWS_S3_SESSION_TOKEN")
        v.BindEnv("s3.bucket", "HOTEL_REVIEWS_S3_BUCKET")
        v.BindEnv("s3.endpoint", "HOTEL_REVIEWS_S3_ENDPOINT")
        v.BindEnv("s3.use_ssl", "HOTEL_REVIEWS_S3_USE_SSL")
        v.BindEnv("s3.force_path_style", "HOTEL_REVIEWS_S3_FORCE_PATH_STYLE")
        v.BindEnv("s3.timeout", "HOTEL_REVIEWS_S3_TIMEOUT")
        v.BindEnv("s3.retry_count", "HOTEL_REVIEWS_S3_RETRY_COUNT")
        v.BindEnv("s3.retry_delay", "HOTEL_REVIEWS_S3_RETRY_DELAY")
        v.BindEnv("s3.upload_part_size", "HOTEL_REVIEWS_S3_UPLOAD_PART_SIZE")
        v.BindEnv("s3.download_part_size", "HOTEL_REVIEWS_S3_DOWNLOAD_PART_SIZE")

        // Server configuration
        v.BindEnv("server.host", "HOTEL_REVIEWS_SERVER_HOST")
        v.BindEnv("server.port", "HOTEL_REVIEWS_SERVER_PORT")
        v.BindEnv("server.read_timeout", "HOTEL_REVIEWS_SERVER_READ_TIMEOUT")
        v.BindEnv("server.write_timeout", "HOTEL_REVIEWS_SERVER_WRITE_TIMEOUT")
        v.BindEnv("server.idle_timeout", "HOTEL_REVIEWS_SERVER_IDLE_TIMEOUT")
        v.BindEnv("server.shutdown_timeout", "HOTEL_REVIEWS_SERVER_SHUTDOWN_TIMEOUT")
        v.BindEnv("server.max_header_bytes", "HOTEL_REVIEWS_SERVER_MAX_HEADER_BYTES")
        v.BindEnv("server.enable_cors", "HOTEL_REVIEWS_SERVER_ENABLE_CORS")
        v.BindEnv("server.enable_gzip", "HOTEL_REVIEWS_SERVER_ENABLE_GZIP")
        v.BindEnv("server.enable_metrics", "HOTEL_REVIEWS_SERVER_ENABLE_METRICS")
        v.BindEnv("server.enable_pprof", "HOTEL_REVIEWS_SERVER_ENABLE_PPROF")
        v.BindEnv("server.tls_cert_file", "HOTEL_REVIEWS_SERVER_TLS_CERT_FILE")
        v.BindEnv("server.tls_key_file", "HOTEL_REVIEWS_SERVER_TLS_KEY_FILE")
        v.BindEnv("server.trusted_proxies", "HOTEL_REVIEWS_SERVER_TRUSTED_PROXIES")

        // Log configuration
        v.BindEnv("log.level", "HOTEL_REVIEWS_LOG_LEVEL")
        v.BindEnv("log.format", "HOTEL_REVIEWS_LOG_FORMAT")
        v.BindEnv("log.output", "HOTEL_REVIEWS_LOG_OUTPUT")
        v.BindEnv("log.file_path", "HOTEL_REVIEWS_LOG_FILE_PATH")
        v.BindEnv("log.max_size", "HOTEL_REVIEWS_LOG_MAX_SIZE")
        v.BindEnv("log.max_backups", "HOTEL_REVIEWS_LOG_MAX_BACKUPS")
        v.BindEnv("log.max_age", "HOTEL_REVIEWS_LOG_MAX_AGE")
        v.BindEnv("log.compress", "HOTEL_REVIEWS_LOG_COMPRESS")
        v.BindEnv("log.enable_caller", "HOTEL_REVIEWS_LOG_ENABLE_CALLER")
        v.BindEnv("log.enable_stacktrace", "HOTEL_REVIEWS_LOG_ENABLE_STACKTRACE")

        // Cache configuration
        v.BindEnv("cache.type", "HOTEL_REVIEWS_CACHE_TYPE")
        v.BindEnv("cache.host", "HOTEL_REVIEWS_CACHE_HOST")
        v.BindEnv("cache.port", "HOTEL_REVIEWS_CACHE_PORT")
        v.BindEnv("cache.password", "HOTEL_REVIEWS_CACHE_PASSWORD")
        v.BindEnv("cache.database", "HOTEL_REVIEWS_CACHE_DATABASE")
        v.BindEnv("cache.pool_size", "HOTEL_REVIEWS_CACHE_POOL_SIZE")
        v.BindEnv("cache.min_idle_conns", "HOTEL_REVIEWS_CACHE_MIN_IDLE_CONNS")
        v.BindEnv("cache.dial_timeout", "HOTEL_REVIEWS_CACHE_DIAL_TIMEOUT")
        v.BindEnv("cache.read_timeout", "HOTEL_REVIEWS_CACHE_READ_TIMEOUT")
        v.BindEnv("cache.write_timeout", "HOTEL_REVIEWS_CACHE_WRITE_TIMEOUT")
        v.BindEnv("cache.ttl", "HOTEL_REVIEWS_CACHE_TTL")
        v.BindEnv("cache.max_memory", "HOTEL_REVIEWS_CACHE_MAX_MEMORY")

        // Metrics configuration
        v.BindEnv("metrics.enabled", "HOTEL_REVIEWS_METRICS_ENABLED")
        v.BindEnv("metrics.type", "HOTEL_REVIEWS_METRICS_TYPE")
        v.BindEnv("metrics.host", "HOTEL_REVIEWS_METRICS_HOST")
        v.BindEnv("metrics.port", "HOTEL_REVIEWS_METRICS_PORT")
        v.BindEnv("metrics.path", "HOTEL_REVIEWS_METRICS_PATH")
        v.BindEnv("metrics.namespace", "HOTEL_REVIEWS_METRICS_NAMESPACE")
        v.BindEnv("metrics.service_name", "HOTEL_REVIEWS_METRICS_SERVICE_NAME")
        v.BindEnv("metrics.environment", "HOTEL_REVIEWS_METRICS_ENVIRONMENT")
        v.BindEnv("metrics.version", "HOTEL_REVIEWS_METRICS_VERSION")

        // Notification configuration
        v.BindEnv("notification.email.enabled", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_ENABLED")
        v.BindEnv("notification.email.host", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_HOST")
        v.BindEnv("notification.email.port", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_PORT")
        v.BindEnv("notification.email.username", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_USERNAME")
        v.BindEnv("notification.email.password", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_PASSWORD")
        v.BindEnv("notification.email.from", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_FROM")
        v.BindEnv("notification.email.use_tls", "HOTEL_REVIEWS_NOTIFICATION_EMAIL_USE_TLS")
        v.BindEnv("notification.slack.enabled", "HOTEL_REVIEWS_NOTIFICATION_SLACK_ENABLED")
        v.BindEnv("notification.slack.webhook_url", "HOTEL_REVIEWS_NOTIFICATION_SLACK_WEBHOOK_URL")
        v.BindEnv("notification.slack.channel", "HOTEL_REVIEWS_NOTIFICATION_SLACK_CHANNEL")
        v.BindEnv("notification.slack.username", "HOTEL_REVIEWS_NOTIFICATION_SLACK_USERNAME")
        v.BindEnv("notification.slack.icon_emoji", "HOTEL_REVIEWS_NOTIFICATION_SLACK_ICON_EMOJI")
        v.BindEnv("notification.slack.icon_url", "HOTEL_REVIEWS_NOTIFICATION_SLACK_ICON_URL")

        // Processing configuration
        v.BindEnv("processing.batch_size", "HOTEL_REVIEWS_PROCESSING_BATCH_SIZE")
        v.BindEnv("processing.worker_count", "HOTEL_REVIEWS_PROCESSING_WORKER_COUNT")
        v.BindEnv("processing.max_file_size", "HOTEL_REVIEWS_PROCESSING_MAX_FILE_SIZE")
        v.BindEnv("processing.processing_timeout", "HOTEL_REVIEWS_PROCESSING_PROCESSING_TIMEOUT")
        v.BindEnv("processing.max_retries", "HOTEL_REVIEWS_PROCESSING_MAX_RETRIES")
        v.BindEnv("processing.retry_delay", "HOTEL_REVIEWS_PROCESSING_RETRY_DELAY")
        v.BindEnv("processing.enable_validation", "HOTEL_REVIEWS_PROCESSING_ENABLE_VALIDATION")
        v.BindEnv("processing.enable_duplicate_check", "HOTEL_REVIEWS_PROCESSING_ENABLE_DUPLICATE_CHECK")
        v.BindEnv("processing.temp_directory", "HOTEL_REVIEWS_PROCESSING_TEMP_DIRECTORY")

        // Security configuration
        v.BindEnv("security.jwt_secret", "HOTEL_REVIEWS_SECURITY_JWT_SECRET")
        v.BindEnv("security.jwt_expiration", "HOTEL_REVIEWS_SECURITY_JWT_EXPIRATION")
        v.BindEnv("security.rate_limit", "HOTEL_REVIEWS_SECURITY_RATE_LIMIT")
        v.BindEnv("security.rate_limit_window", "HOTEL_REVIEWS_SECURITY_RATE_LIMIT_WINDOW")
        v.BindEnv("security.enable_api_key", "HOTEL_REVIEWS_SECURITY_ENABLE_API_KEY")
        v.BindEnv("security.api_key_header", "HOTEL_REVIEWS_SECURITY_API_KEY_HEADER")
        v.BindEnv("security.enable_encryption", "HOTEL_REVIEWS_SECURITY_ENABLE_ENCRYPTION")
        v.BindEnv("security.encryption_key", "HOTEL_REVIEWS_SECURITY_ENCRYPTION_KEY")

        // Authentication configuration
        v.BindEnv("auth.jwt_secret", "HOTEL_REVIEWS_AUTH_JWT_SECRET")
        v.BindEnv("auth.jwt_issuer", "HOTEL_REVIEWS_AUTH_JWT_ISSUER")
        v.BindEnv("auth.access_token_expiry", "HOTEL_REVIEWS_AUTH_ACCESS_TOKEN_EXPIRY")
        v.BindEnv("auth.refresh_token_expiry", "HOTEL_REVIEWS_AUTH_REFRESH_TOKEN_EXPIRY")
        v.BindEnv("auth.max_login_attempts", "HOTEL_REVIEWS_AUTH_MAX_LOGIN_ATTEMPTS")
        v.BindEnv("auth.login_attempt_window", "HOTEL_REVIEWS_AUTH_LOGIN_ATTEMPT_WINDOW")
        v.BindEnv("auth.account_lock_duration", "HOTEL_REVIEWS_AUTH_ACCOUNT_LOCK_DURATION")
        v.BindEnv("auth.password_min_length", "HOTEL_REVIEWS_AUTH_PASSWORD_MIN_LENGTH")
        v.BindEnv("auth.password_max_length", "HOTEL_REVIEWS_AUTH_PASSWORD_MAX_LENGTH")
        v.BindEnv("auth.require_strong_password", "HOTEL_REVIEWS_AUTH_REQUIRE_STRONG_PASSWORD")
        v.BindEnv("auth.enable_two_factor", "HOTEL_REVIEWS_AUTH_ENABLE_TWO_FACTOR")
        v.BindEnv("auth.enable_email_verification", "HOTEL_REVIEWS_AUTH_ENABLE_EMAIL_VERIFICATION")
        v.BindEnv("auth.enable_password_reset", "HOTEL_REVIEWS_AUTH_ENABLE_PASSWORD_RESET")
        v.BindEnv("auth.enable_session_cleanup", "HOTEL_REVIEWS_AUTH_ENABLE_SESSION_CLEANUP")
        v.BindEnv("auth.session_cleanup_interval", "HOTEL_REVIEWS_AUTH_SESSION_CLEANUP_INTERVAL")
        v.BindEnv("auth.enable_audit_logging", "HOTEL_REVIEWS_AUTH_ENABLE_AUDIT_LOGGING")
        v.BindEnv("auth.enable_rate_limiting", "HOTEL_REVIEWS_AUTH_ENABLE_RATE_LIMITING")
        v.BindEnv("auth.bcrypt_cost", "HOTEL_REVIEWS_AUTH_BCRYPT_COST")
        v.BindEnv("auth.api_key_length", "HOTEL_REVIEWS_AUTH_API_KEY_LENGTH")
        v.BindEnv("auth.api_key_prefix", "HOTEL_REVIEWS_AUTH_API_KEY_PREFIX")
        v.BindEnv("auth.default_role", "HOTEL_REVIEWS_AUTH_DEFAULT_ROLE")

        // Kafka configuration
        v.BindEnv("kafka.brokers", "HOTEL_REVIEWS_KAFKA_BROKERS")
        v.BindEnv("kafka.review_topic", "HOTEL_REVIEWS_KAFKA_REVIEW_TOPIC")
        v.BindEnv("kafka.processing_topic", "HOTEL_REVIEWS_KAFKA_PROCESSING_TOPIC")
        v.BindEnv("kafka.dead_letter_topic", "HOTEL_REVIEWS_KAFKA_DEAD_LETTER_TOPIC")
        v.BindEnv("kafka.consumer_group", "HOTEL_REVIEWS_KAFKA_CONSUMER_GROUP")
        v.BindEnv("kafka.batch_size", "HOTEL_REVIEWS_KAFKA_BATCH_SIZE")
        v.BindEnv("kafka.batch_timeout", "HOTEL_REVIEWS_KAFKA_BATCH_TIMEOUT")
        v.BindEnv("kafka.max_retries", "HOTEL_REVIEWS_KAFKA_MAX_RETRIES")
        v.BindEnv("kafka.retry_delay", "HOTEL_REVIEWS_KAFKA_RETRY_DELAY")
        v.BindEnv("kafka.enable_sasl", "HOTEL_REVIEWS_KAFKA_ENABLE_SASL")
        v.BindEnv("kafka.sasl_username", "HOTEL_REVIEWS_KAFKA_SASL_USERNAME")
        v.BindEnv("kafka.sasl_password", "HOTEL_REVIEWS_KAFKA_SASL_PASSWORD")
        v.BindEnv("kafka.enable_tls", "HOTEL_REVIEWS_KAFKA_ENABLE_TLS")
        v.BindEnv("kafka.max_message_size", "HOTEL_REVIEWS_KAFKA_MAX_MESSAGE_SIZE")
        v.BindEnv("kafka.compression_type", "HOTEL_REVIEWS_KAFKA_COMPRESSION_TYPE")
        v.BindEnv("kafka.producer_flush_timeout", "HOTEL_REVIEWS_KAFKA_PRODUCER_FLUSH_TIMEOUT")
        v.BindEnv("kafka.consumer_timeout", "HOTEL_REVIEWS_KAFKA_CONSUMER_TIMEOUT")
        v.BindEnv("kafka.enable_idempotence", "HOTEL_REVIEWS_KAFKA_ENABLE_IDEMPOTENCE")
        v.BindEnv("kafka.partitions", "HOTEL_REVIEWS_KAFKA_PARTITIONS")
        v.BindEnv("kafka.replication_factor", "HOTEL_REVIEWS_KAFKA_REPLICATION_FACTOR")
}</span>

// setDefaults sets default configuration values
func setDefaults(v *viper.Viper) <span class="cov7" title="29">{
        // Database defaults (required fields have no defaults)
        v.SetDefault("database.port", 5432)
        v.SetDefault("database.ssl_mode", "disable")
        v.SetDefault("database.max_open_conns", 25)
        v.SetDefault("database.max_idle_conns", 25)
        v.SetDefault("database.conn_max_lifetime", "5m")
        v.SetDefault("database.conn_max_idle_time", "5m")
        v.SetDefault("database.timezone", "UTC")
        v.SetDefault("database.log_level", "warn")

        // S3 defaults (required fields have no defaults)
        v.SetDefault("s3.use_ssl", true)
        v.SetDefault("s3.force_path_style", false)
        v.SetDefault("s3.timeout", "30s")
        v.SetDefault("s3.retry_count", 3)
        v.SetDefault("s3.retry_delay", "1s")
        v.SetDefault("s3.upload_part_size", 5*1024*1024)   // 5MB
        v.SetDefault("s3.download_part_size", 5*1024*1024) // 5MB

        // Server defaults
        v.SetDefault("server.host", "0.0.0.0")
        v.SetDefault("server.port", 8080)
        v.SetDefault("server.read_timeout", "10s")
        v.SetDefault("server.write_timeout", "10s")
        v.SetDefault("server.idle_timeout", "60s")
        v.SetDefault("server.shutdown_timeout", "30s")
        v.SetDefault("server.max_header_bytes", 1&lt;&lt;20) // 1MB
        v.SetDefault("server.enable_cors", true)
        v.SetDefault("server.enable_gzip", true)
        v.SetDefault("server.enable_metrics", true)
        v.SetDefault("server.enable_pprof", false)
        v.SetDefault("server.trusted_proxies", []string{})

        // Log defaults
        v.SetDefault("log.level", "info")
        v.SetDefault("log.format", "json")
        v.SetDefault("log.output", "stdout")
        v.SetDefault("log.max_size", 100)
        v.SetDefault("log.max_backups", 3)
        v.SetDefault("log.max_age", 28)
        v.SetDefault("log.compress", true)
        v.SetDefault("log.enable_caller", true)
        v.SetDefault("log.enable_stacktrace", false)

        // Cache defaults
        v.SetDefault("cache.type", "redis")
        v.SetDefault("cache.host", "localhost")
        v.SetDefault("cache.port", 6379)
        v.SetDefault("cache.database", 0)
        v.SetDefault("cache.pool_size", 10)
        v.SetDefault("cache.min_idle_conns", 5)
        v.SetDefault("cache.dial_timeout", "5s")
        v.SetDefault("cache.read_timeout", "3s")
        v.SetDefault("cache.write_timeout", "3s")
        v.SetDefault("cache.ttl", "1h")
        v.SetDefault("cache.max_memory", 100*1024*1024) // 100MB

        // Metrics defaults
        v.SetDefault("metrics.enabled", true)
        v.SetDefault("metrics.type", "prometheus")
        v.SetDefault("metrics.host", "localhost")
        v.SetDefault("metrics.port", 9090)
        v.SetDefault("metrics.path", "/metrics")
        v.SetDefault("metrics.namespace", "hotel_reviews")
        v.SetDefault("metrics.service_name", "hotel-reviews-api")
        v.SetDefault("metrics.environment", "development")
        v.SetDefault("metrics.version", "1.0.0")

        // Notification defaults
        v.SetDefault("notification.email.enabled", false)
        v.SetDefault("notification.email.port", 587)
        v.SetDefault("notification.email.use_tls", true)
        v.SetDefault("notification.slack.enabled", false)
        v.SetDefault("notification.slack.username", "Hotel Reviews Bot")
        v.SetDefault("notification.slack.icon_emoji", ":hotel:")

        // Processing defaults
        v.SetDefault("processing.batch_size", 1000)
        v.SetDefault("processing.worker_count", 4)
        v.SetDefault("processing.max_file_size", 100*1024*1024) // 100MB
        v.SetDefault("processing.processing_timeout", "30m")
        v.SetDefault("processing.max_retries", 3)
        v.SetDefault("processing.retry_delay", "5s")
        v.SetDefault("processing.enable_validation", true)
        v.SetDefault("processing.enable_duplicate_check", true)
        v.SetDefault("processing.temp_directory", "/tmp/hotel-reviews")

        // Security defaults
        v.SetDefault("security.jwt_expiration", "24h")
        v.SetDefault("security.rate_limit", 1000)
        v.SetDefault("security.rate_limit_window", "1h")
        v.SetDefault("security.enable_api_key", false)
        v.SetDefault("security.api_key_header", "X-API-Key")
        v.SetDefault("security.enable_encryption", false)

        // Authentication defaults
        v.SetDefault("auth.jwt_issuer", "hotel-reviews-api")
        v.SetDefault("auth.access_token_expiry", "15m")
        v.SetDefault("auth.refresh_token_expiry", "168h") // 7 days = 7 * 24 hours
        v.SetDefault("auth.max_login_attempts", 5)
        v.SetDefault("auth.login_attempt_window", "15m")
        v.SetDefault("auth.account_lock_duration", "30m")
        v.SetDefault("auth.password_min_length", 8)
        v.SetDefault("auth.password_max_length", 128)
        v.SetDefault("auth.require_strong_password", true)
        v.SetDefault("auth.enable_two_factor", false)
        v.SetDefault("auth.enable_email_verification", false)
        v.SetDefault("auth.enable_password_reset", true)
        v.SetDefault("auth.enable_session_cleanup", true)
        v.SetDefault("auth.session_cleanup_interval", "1h")
        v.SetDefault("auth.enable_audit_logging", true)
        v.SetDefault("auth.enable_rate_limiting", true)
        v.SetDefault("auth.bcrypt_cost", 12)
        v.SetDefault("auth.api_key_length", 32)
        v.SetDefault("auth.api_key_prefix", "hr_")
        v.SetDefault("auth.default_role", "user")

        // Kafka defaults
        v.SetDefault("kafka.brokers", []string{"localhost:9092"})
        v.SetDefault("kafka.review_topic", "hotel-reviews")
        v.SetDefault("kafka.processing_topic", "hotel-reviews-processing")
        v.SetDefault("kafka.dead_letter_topic", "hotel-reviews-dlq")
        v.SetDefault("kafka.consumer_group", "hotel-reviews-consumer")
        v.SetDefault("kafka.batch_size", 100)
        v.SetDefault("kafka.batch_timeout", "1s")
        v.SetDefault("kafka.max_retries", 3)
        v.SetDefault("kafka.retry_delay", "1s")
        v.SetDefault("kafka.enable_sasl", false)
        v.SetDefault("kafka.enable_tls", false)
        v.SetDefault("kafka.max_message_size", 1*1024*1024) // 1MB
        v.SetDefault("kafka.compression_type", "snappy")
        v.SetDefault("kafka.producer_flush_timeout", "10s")
        v.SetDefault("kafka.consumer_timeout", "10s")
        v.SetDefault("kafka.enable_idempotence", true)
        v.SetDefault("kafka.partitions", 3)
        v.SetDefault("kafka.replication_factor", 1)
}</span>

// validate validates the configuration
func validate(config *Config) error <span class="cov7" title="28">{
        // Validate database configuration
        if config.Database.Host == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("database host is required")
        }</span>
        <span class="cov7" title="27">if config.Database.Port &lt;= 0 || config.Database.Port &gt; 65535 </span><span class="cov2" title="2">{
                return fmt.Errorf("database port must be between 1 and 65535")
        }</span>
        <span class="cov7" title="25">if config.Database.User == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("database user is required")
        }</span>
        <span class="cov6" title="24">if config.Database.Password == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("database password is required")
        }</span>
        <span class="cov6" title="23">if config.Database.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("database name is required")
        }</span>

        // Validate S3 configuration
        <span class="cov6" title="22">if config.S3.Region == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("S3 region is required")
        }</span>
        <span class="cov6" title="21">if config.S3.AccessKeyID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("S3 access key ID is required")
        }</span>
        <span class="cov6" title="20">if config.S3.SecretAccessKey == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("S3 secret access key is required")
        }</span>
        <span class="cov6" title="19">if config.S3.Bucket == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("S3 bucket is required")
        }</span>

        // Validate server configuration
        <span class="cov6" title="18">if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov2" title="2">{
                return fmt.Errorf("server port must be between 1 and 65535")
        }</span>

        // Validate log configuration
        <span class="cov6" title="16">validLogLevels := []string{"debug", "info", "warn", "error"}
        if !contains(validLogLevels, config.Log.Level) </span><span class="cov1" title="1">{
                return fmt.Errorf("log level must be one of: %s", strings.Join(validLogLevels, ", "))
        }</span>

        <span class="cov6" title="15">validLogFormats := []string{"json", "text"}
        if !contains(validLogFormats, config.Log.Format) </span><span class="cov1" title="1">{
                return fmt.Errorf("log format must be one of: %s", strings.Join(validLogFormats, ", "))
        }</span>

        <span class="cov5" title="14">validLogOutputs := []string{"stdout", "stderr", "file"}
        if !contains(validLogOutputs, config.Log.Output) </span><span class="cov1" title="1">{
                return fmt.Errorf("log output must be one of: %s", strings.Join(validLogOutputs, ", "))
        }</span>

        <span class="cov5" title="13">if config.Log.Output == "file" &amp;&amp; config.Log.FilePath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("log file path is required when output is file")
        }</span>

        // Validate cache configuration
        <span class="cov5" title="12">validCacheTypes := []string{"redis", "memory"}
        if !contains(validCacheTypes, config.Cache.Type) </span><span class="cov1" title="1">{
                return fmt.Errorf("cache type must be one of: %s", strings.Join(validCacheTypes, ", "))
        }</span>

        // Validate security configuration
        <span class="cov5" title="11">if config.Security.JWTSecret == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("JWT secret is required")
        }</span>

        // Validate authentication configuration
        <span class="cov5" title="10">if config.Auth.JWTSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication JWT secret is required")
        }</span>
        <span class="cov5" title="10">if config.Auth.JWTIssuer == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication JWT issuer is required")
        }</span>
        <span class="cov5" title="10">if config.Auth.AccessTokenExpiry &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("access token expiry must be positive")
        }</span>
        <span class="cov5" title="10">if config.Auth.RefreshTokenExpiry &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("refresh token expiry must be positive")
        }</span>
        <span class="cov5" title="10">if config.Auth.MaxLoginAttempts &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max login attempts must be positive")
        }</span>
        <span class="cov5" title="10">if config.Auth.LoginAttemptWindow &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("login attempt window must be positive")
        }</span>
        <span class="cov5" title="10">if config.Auth.AccountLockDuration &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("account lock duration must be positive")
        }</span>
        <span class="cov5" title="10">if config.Auth.PasswordMinLength &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("password min length must be at least 4")
        }</span>
        <span class="cov5" title="10">if config.Auth.PasswordMaxLength &lt; config.Auth.PasswordMinLength </span><span class="cov0" title="0">{
                return fmt.Errorf("password max length must be greater than or equal to min length")
        }</span>
        <span class="cov5" title="10">if config.Auth.BCryptCost &lt; 4 || config.Auth.BCryptCost &gt; 31 </span><span class="cov0" title="0">{
                return fmt.Errorf("bcrypt cost must be between 4 and 31")
        }</span>
        <span class="cov5" title="10">if config.Auth.ApiKeyLength &lt; 16 </span><span class="cov0" title="0">{
                return fmt.Errorf("API key length must be at least 16")
        }</span>
        <span class="cov5" title="10">if config.Auth.ApiKeyPrefix == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("API key prefix is required")
        }</span>
        <span class="cov5" title="10">if config.Auth.DefaultRole == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("default role is required")
        }</span>

        // Validate TLS configuration
        <span class="cov5" title="10">if config.Server.TLSCertFile != "" &amp;&amp; config.Server.TLSKeyFile == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("TLS key file is required when TLS cert file is provided")
        }</span>
        <span class="cov5" title="9">if config.Server.TLSKeyFile != "" &amp;&amp; config.Server.TLSCertFile == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("TLS cert file is required when TLS key file is provided")
        }</span>

        // Validate file paths exist
        <span class="cov4" title="8">if config.Server.TLSCertFile != "" </span><span class="cov3" title="3">{
                if _, err := os.Stat(config.Server.TLSCertFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return fmt.Errorf("TLS cert file does not exist: %s", config.Server.TLSCertFile)
                }</span>
        }
        <span class="cov4" title="7">if config.Server.TLSKeyFile != "" </span><span class="cov2" title="2">{
                if _, err := os.Stat(config.Server.TLSKeyFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return fmt.Errorf("TLS key file does not exist: %s", config.Server.TLSKeyFile)
                }</span>
        }

        // Validate Kafka configuration
        <span class="cov4" title="6">if len(config.Kafka.Brokers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one Kafka broker is required")
        }</span>
        <span class="cov4" title="6">if config.Kafka.ReviewTopic == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka review topic is required")
        }</span>
        <span class="cov4" title="6">if config.Kafka.ProcessingTopic == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka processing topic is required")
        }</span>
        <span class="cov4" title="6">if config.Kafka.ConsumerGroup == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka consumer group is required")
        }</span>
        <span class="cov4" title="6">if config.Kafka.BatchSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka batch size must be positive")
        }</span>
        <span class="cov4" title="6">if config.Kafka.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka max retries must be non-negative")
        }</span>
        <span class="cov4" title="6">if config.Kafka.MaxMessageSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka max message size must be positive")
        }</span>
        <span class="cov4" title="6">if config.Kafka.Partitions &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka partitions must be positive")
        }</span>
        <span class="cov4" title="6">if config.Kafka.ReplicationFactor &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka replication factor must be positive")
        }</span>

        // Validate Kafka compression type
        <span class="cov4" title="6">validCompressionTypes := []string{"gzip", "snappy", "lz4", "zstd", "none"}
        if !contains(validCompressionTypes, config.Kafka.CompressionType) </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka compression type must be one of: %s", strings.Join(validCompressionTypes, ", "))
        }</span>

        // Validate SASL configuration
        <span class="cov4" title="6">if config.Kafka.EnableSASL </span><span class="cov0" title="0">{
                if config.Kafka.SASLUsername == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("SASL username is required when SASL is enabled")
                }</span>
                <span class="cov0" title="0">if config.Kafka.SASLPassword == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("SASL password is required when SASL is enabled")
                }</span>
        }

        <span class="cov4" title="6">return nil</span>
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov9" title="76">{
        for _, s := range slice </span><span class="cov10" title="125">{
                if s == item </span><span class="cov8" title="66">{
                        return true
                }</span>
        }
        <span class="cov5" title="10">return false</span>
}

// GetDatabaseURL returns the database connection URL
func (c *Config) GetDatabaseURL() string <span class="cov1" title="1">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s&amp;timezone=%s",
                c.Database.User,
                c.Database.Password,
                c.Database.Host,
                c.Database.Port,
                c.Database.Name,
                c.Database.SSLMode,
                c.Database.TimeZone,
        )
}</span>

// GetServerAddress returns the server address
func (c *Config) GetServerAddress() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetCacheAddress returns the cache address
func (c *Config) GetCacheAddress() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s:%d", c.Cache.Host, c.Cache.Port)
}</span>

// IsProduction returns true if the environment is production
func (c *Config) IsProduction() bool <span class="cov3" title="4">{
        return c.Metrics.Environment == "production"
}</span>

// IsDevelopment returns true if the environment is development
func (c *Config) IsDevelopment() bool <span class="cov3" title="4">{
        return c.Metrics.Environment == "development"
}</span>

// IsTestEnvironment returns true if the environment is test
func (c *Config) IsTestEnvironment() bool <span class="cov3" title="4">{
        return c.Metrics.Environment == "test"
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package logger

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/google/uuid"
        "gopkg.in/natefinch/lumberjack.v2"
)

// ContextKey represents a key for context values
type ContextKey string

const (
        // ContextKeyRequestID is the key for request ID in context
        ContextKeyRequestID ContextKey = "request_id"
        // ContextKeyUserID is the key for user ID in context
        ContextKeyUserID ContextKey = "user_id"
        // ContextKeyCorrelationID is the key for correlation ID in context
        ContextKeyCorrelationID ContextKey = "correlation_id"
        // ContextKeyTraceID is the key for trace ID in context
        ContextKeyTraceID ContextKey = "trace_id"
        // ContextKeySpanID is the key for span ID in context
        ContextKeySpanID ContextKey = "span_id"
)

// Config represents logger configuration
type Config struct {
        Level            string `json:"level"`
        Format           string `json:"format"`
        Output           string `json:"output"`
        FilePath         string `json:"file_path"`
        MaxSize          int    `json:"max_size"`
        MaxBackups       int    `json:"max_backups"`
        MaxAge           int    `json:"max_age"`
        Compress         bool   `json:"compress"`
        EnableCaller     bool   `json:"enable_caller"`
        EnableStacktrace bool   `json:"enable_stacktrace"`
}

// Logger wraps slog.Logger with additional functionality
type Logger struct {
        *slog.Logger
        config *Config
}

// New creates a new logger instance
func New(config *Config) (*Logger, error) <span class="cov6" title="50">{
        // Parse log level
        level, err := parseLogLevel(config.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create writer based on output configuration
        <span class="cov6" title="50">writer, err := createWriter(config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Create handler options
        <span class="cov6" title="49">opts := &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: config.EnableCaller,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov10" title="422">{
                        // Customize source attribute
                        if a.Key == slog.SourceKey </span><span class="cov6" title="34">{
                                if src, ok := a.Value.Any().(*slog.Source); ok </span><span class="cov6" title="34">{
                                        // Shorten file path
                                        src.File = shortenFilePath(src.File)
                                        return slog.Attr{Key: a.Key, Value: slog.AnyValue(src)}
                                }</span>
                        }

                        // Customize time format
                        <span class="cov9" title="388">if a.Key == slog.TimeKey </span><span class="cov6" title="37">{
                                return slog.Attr{Key: a.Key, Value: slog.StringValue(a.Value.Time().Format(time.RFC3339Nano))}
                        }</span>

                        <span class="cov9" title="351">return a</span>
                },
        }

        // Create handler based on format
        <span class="cov6" title="49">var handler slog.Handler
        switch config.Format </span>{
        case "json":<span class="cov6" title="47">
                handler = slog.NewJSONHandler(writer, opts)</span>
        case "text":<span class="cov1" title="1">
                handler = slog.NewTextHandler(writer, opts)</span>
        default:<span class="cov1" title="1">
                handler = slog.NewJSONHandler(writer, opts)</span>
        }

        // Create logger
        <span class="cov6" title="49">logger := &amp;Logger{
                Logger: slog.New(handler),
                config: config,
        }

        return logger, nil</span>
}

// NewDefault creates a logger with default configuration
func NewDefault() *Logger <span class="cov6" title="30">{
        config := &amp;Config{
                Level:            "info",
                Format:           "json",
                Output:           "stdout",
                EnableCaller:     true,
                EnableStacktrace: false,
        }

        logger, err := New(config)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to basic logger
                return &amp;Logger{
                        Logger: slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                                Level:     slog.LevelInfo,
                                AddSource: true,
                        })),
                        config: config,
                }
        }</span>

        <span class="cov6" title="30">return logger</span>
}

// Context-aware logging methods
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov6" title="43">{
        attrs := l.extractContextAttributes(ctx)
        if len(attrs) == 0 </span><span class="cov3" title="5">{
                return l
        }</span>

        <span class="cov6" title="38">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

func (l *Logger) extractContextAttributes(ctx context.Context) []any <span class="cov6" title="45">{
        var attrs []any

        if requestID := ctx.Value(ContextKeyRequestID); requestID != nil </span><span class="cov6" title="29">{
                attrs = append(attrs, "request_id", requestID)
        }</span>

        <span class="cov6" title="45">if userID := ctx.Value(ContextKeyUserID); userID != nil </span><span class="cov5" title="19">{
                attrs = append(attrs, "user_id", userID)
        }</span>

        <span class="cov6" title="45">if correlationID := ctx.Value(ContextKeyCorrelationID); correlationID != nil </span><span class="cov5" title="21">{
                attrs = append(attrs, "correlation_id", correlationID)
        }</span>

        <span class="cov6" title="45">if traceID := ctx.Value(ContextKeyTraceID); traceID != nil </span><span class="cov3" title="6">{
                attrs = append(attrs, "trace_id", traceID)
        }</span>

        <span class="cov6" title="45">if spanID := ctx.Value(ContextKeySpanID); spanID != nil </span><span class="cov3" title="6">{
                attrs = append(attrs, "span_id", spanID)
        }</span>

        <span class="cov6" title="45">return attrs</span>
}

// Enhanced logging methods with context support
func (l *Logger) DebugContext(ctx context.Context, msg string, args ...any) <span class="cov2" title="3">{
        l.WithContext(ctx).Debug(msg, args...)
}</span>

func (l *Logger) InfoContext(ctx context.Context, msg string, args ...any) <span class="cov3" title="6">{
        l.WithContext(ctx).Info(msg, args...)
}</span>

func (l *Logger) WarnContext(ctx context.Context, msg string, args ...any) <span class="cov2" title="3">{
        l.WithContext(ctx).Warn(msg, args...)
}</span>

func (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov3" title="5">{
        if l.config.EnableStacktrace </span><span class="cov2" title="3">{
                args = append(args, "stacktrace", getStackTrace())
        }</span>
        <span class="cov3" title="5">l.WithContext(ctx).Error(msg, args...)</span>
}

// Structured logging methods
func (l *Logger) WithFields(fields map[string]any) *Logger <span class="cov2" title="2">{
        attrs := make([]any, 0, len(fields)*2)
        for k, v := range fields </span><span class="cov2" title="3">{
                attrs = append(attrs, k, v)
        }</span>
        <span class="cov2" title="2">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

func (l *Logger) WithField(key string, value any) *Logger <span class="cov1" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(key, value),
                config: l.config,
        }
}</span>

func (l *Logger) WithError(err error) *Logger <span class="cov2" title="3">{
        if err == nil </span><span class="cov1" title="1">{
                return l
        }</span>

        <span class="cov2" title="2">attrs := []any{"error", err.Error()}
        if l.config.EnableStacktrace </span><span class="cov1" title="1">{
                attrs = append(attrs, "stacktrace", getStackTrace())
        }</span>

        <span class="cov2" title="2">return &amp;Logger{
                Logger: l.Logger.With(attrs...),
                config: l.config,
        }</span>
}

// Business domain specific logging methods
func (l *Logger) LogRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration, size int64) <span class="cov3" title="4">{
        l.WithContext(ctx).Info("HTTP request completed",
                "method", method,
                "path", path,
                "status_code", statusCode,
                "duration_ms", duration.Milliseconds(),
                "response_size", size,
        )
}</span>

func (l *Logger) LogDatabaseQuery(ctx context.Context, query string, duration time.Duration, rowsAffected int64) <span class="cov2" title="2">{
        l.WithContext(ctx).Debug("Database query executed",
                "query", query,
                "duration_ms", duration.Milliseconds(),
                "rows_affected", rowsAffected,
        )
}</span>

func (l *Logger) LogFileProcessing(ctx context.Context, filename string, recordsProcessed int, duration time.Duration) <span class="cov2" title="2">{
        l.WithContext(ctx).Info("File processing completed",
                "filename", filename,
                "records_processed", recordsProcessed,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogCacheOperation(ctx context.Context, operation, key string, hit bool, duration time.Duration) <span class="cov2" title="2">{
        l.WithContext(ctx).Debug("Cache operation",
                "operation", operation,
                "key", key,
                "hit", hit,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogS3Operation(ctx context.Context, operation, bucket, key string, size int64, duration time.Duration) <span class="cov2" title="2">{
        l.WithContext(ctx).Debug("S3 operation",
                "operation", operation,
                "bucket", bucket,
                "key", key,
                "size", size,
                "duration_ms", duration.Milliseconds(),
        )
}</span>

func (l *Logger) LogMetric(ctx context.Context, name string, value float64, labels map[string]string) <span class="cov2" title="3">{
        attrs := []any{
                "metric_name", name,
                "metric_value", value,
        }

        for k, v := range labels </span><span class="cov3" title="4">{
                attrs = append(attrs, "label_"+k, v)
        }</span>

        <span class="cov2" title="3">l.WithContext(ctx).Debug("Metric recorded", attrs...)</span>
}

func (l *Logger) LogBusinessEvent(ctx context.Context, event string, entityType string, entityID string, details map[string]any) <span class="cov2" title="3">{
        attrs := []any{
                "event", event,
                "entity_type", entityType,
                "entity_id", entityID,
        }

        for k, v := range details </span><span class="cov3" title="4">{
                attrs = append(attrs, k, v)
        }</span>

        <span class="cov2" title="3">l.WithContext(ctx).Info("Business event", attrs...)</span>
}

// Error handling methods
func (l *Logger) LogError(ctx context.Context, err error, msg string, args ...any) <span class="cov3" title="4">{
        if err == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="3">attrs := append(args, "error", err.Error())
        if l.config.EnableStacktrace </span><span class="cov2" title="2">{
                attrs = append(attrs, "stacktrace", getStackTrace())
        }</span>

        <span class="cov2" title="3">l.WithContext(ctx).Error(msg, attrs...)</span>
}

func (l *Logger) LogPanic(ctx context.Context, recovered any, msg string, args ...any) <span class="cov2" title="3">{
        attrs := append(args, "panic", recovered, "stacktrace", getStackTrace())
        l.WithContext(ctx).Error(msg, attrs...)
}</span>

// Utility methods
func (l *Logger) IsDebugEnabled() bool <span class="cov2" title="2">{
        return l.Logger.Enabled(context.Background(), slog.LevelDebug)
}</span>

func (l *Logger) IsInfoEnabled() bool <span class="cov2" title="2">{
        return l.Logger.Enabled(context.Background(), slog.LevelInfo)
}</span>

func (l *Logger) IsWarnEnabled() bool <span class="cov2" title="2">{
        return l.Logger.Enabled(context.Background(), slog.LevelWarn)
}</span>

func (l *Logger) IsErrorEnabled() bool <span class="cov1" title="1">{
        return l.Logger.Enabled(context.Background(), slog.LevelError)
}</span>

// Helper functions
func parseLogLevel(level string) (slog.Level, error) <span class="cov7" title="57">{
        switch level </span>{
        case "debug":<span class="cov3" title="5">
                return slog.LevelDebug, nil</span>
        case "info":<span class="cov6" title="38">
                return slog.LevelInfo, nil</span>
        case "warn":<span class="cov3" title="4">
                return slog.LevelWarn, nil</span>
        case "error":<span class="cov3" title="7">
                return slog.LevelError, nil</span>
        default:<span class="cov2" title="3">
                return slog.LevelInfo, nil</span>
        }
}

func createWriter(config *Config) (io.Writer, error) <span class="cov6" title="55">{
        switch config.Output </span>{
        case "stdout":<span class="cov6" title="46">
                return os.Stdout, nil</span>
        case "stderr":<span class="cov2" title="2">
                return os.Stderr, nil</span>
        case "file":<span class="cov3" title="5">
                if config.FilePath == "" </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("file path is required for file output")
                }</span>

                <span class="cov2" title="3">return &amp;lumberjack.Logger{
                        Filename:   config.FilePath,
                        MaxSize:    config.MaxSize,
                        MaxBackups: config.MaxBackups,
                        MaxAge:     config.MaxAge,
                        Compress:   config.Compress,
                }, nil</span>
        default:<span class="cov2" title="2">
                return os.Stdout, nil</span>
        }
}

func shortenFilePath(path string) string <span class="cov6" title="40">{
        // Extract just the filename and parent directory
        parts := strings.Split(path, "/")
        if len(parts) &gt; 2 </span><span class="cov6" title="37">{
                return strings.Join(parts[len(parts)-2:], "/")
        }</span>
        <span class="cov2" title="3">return path</span>
}

func getStackTrace() string <span class="cov4" title="11">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        return string(buf[:n])
}</span>

// Context helpers
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov4" title="13">{
        return context.WithValue(ctx, ContextKeyRequestID, requestID)
}</span>

func WithUserID(ctx context.Context, userID string) context.Context <span class="cov4" title="9">{
        return context.WithValue(ctx, ContextKeyUserID, userID)
}</span>

func WithCorrelationID(ctx context.Context, correlationID string) context.Context <span class="cov4" title="9">{
        return context.WithValue(ctx, ContextKeyCorrelationID, correlationID)
}</span>

func WithTraceID(ctx context.Context, traceID string) context.Context <span class="cov3" title="7">{
        return context.WithValue(ctx, ContextKeyTraceID, traceID)
}</span>

func WithSpanID(ctx context.Context, spanID string) context.Context <span class="cov3" title="7">{
        return context.WithValue(ctx, ContextKeySpanID, spanID)
}</span>

func GetRequestID(ctx context.Context) string <span class="cov3" title="4">{
        if id := ctx.Value(ContextKeyRequestID); id != nil </span><span class="cov2" title="3">{
                return id.(string)
        }</span>
        <span class="cov1" title="1">return ""</span>
}

func GetUserID(ctx context.Context) string <span class="cov2" title="2">{
        if id := ctx.Value(ContextKeyUserID); id != nil </span><span class="cov1" title="1">{
                return id.(string)
        }</span>
        <span class="cov1" title="1">return ""</span>
}

func GetCorrelationID(ctx context.Context) string <span class="cov3" title="4">{
        if id := ctx.Value(ContextKeyCorrelationID); id != nil </span><span class="cov2" title="3">{
                return id.(string)
        }</span>
        <span class="cov1" title="1">return ""</span>
}

func GetTraceID(ctx context.Context) string <span class="cov2" title="3">{
        if id := ctx.Value(ContextKeyTraceID); id != nil </span><span class="cov2" title="2">{
                return id.(string)
        }</span>
        <span class="cov1" title="1">return ""</span>
}

func GetSpanID(ctx context.Context) string <span class="cov2" title="3">{
        if id := ctx.Value(ContextKeySpanID); id != nil </span><span class="cov2" title="2">{
                return id.(string)
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// GenerateRequestID generates a new request ID
func GenerateRequestID() string <span class="cov2" title="2">{
        return uuid.New().String()
}</span>

// GenerateCorrelationID generates a new correlation ID
func GenerateCorrelationID() string <span class="cov2" title="2">{
        return uuid.New().String()
}</span>

// Middleware for HTTP requests
func RequestLoggerMiddleware(logger *Logger) func(next http.Handler) http.Handler <span class="cov2" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov2" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov2" title="2">{
                        start := time.Now()

                        // Generate request ID if not present
                        requestID := r.Header.Get("X-Request-ID")
                        if requestID == "" </span><span class="cov1" title="1">{
                                requestID = GenerateRequestID()
                        }</span>

                        // Generate correlation ID if not present
                        <span class="cov2" title="2">correlationID := r.Header.Get("X-Correlation-ID")
                        if correlationID == "" </span><span class="cov1" title="1">{
                                correlationID = GenerateCorrelationID()
                        }</span>

                        // Add IDs to context
                        <span class="cov2" title="2">ctx := WithRequestID(r.Context(), requestID)
                        ctx = WithCorrelationID(ctx, correlationID)

                        // Add trace information if available
                        if traceID := r.Header.Get("X-Trace-ID"); traceID != "" </span><span class="cov1" title="1">{
                                ctx = WithTraceID(ctx, traceID)
                        }</span>
                        <span class="cov2" title="2">if spanID := r.Header.Get("X-Span-ID"); spanID != "" </span><span class="cov1" title="1">{
                                ctx = WithSpanID(ctx, spanID)
                        }</span>

                        // Update request with new context
                        <span class="cov2" title="2">r = r.WithContext(ctx)

                        // Set response headers
                        w.Header().Set("X-Request-ID", requestID)
                        w.Header().Set("X-Correlation-ID", correlationID)

                        // Wrap response writer to capture status code and size
                        ww := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                        // Log request start
                        logger.InfoContext(ctx, "HTTP request started",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.UserAgent(),
                        )

                        // Process request
                        next.ServeHTTP(ww, r)

                        // Log request completion
                        duration := time.Since(start)
                        logger.LogRequest(ctx, r.Method, r.URL.Path, ww.statusCode, duration, ww.size)</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture status code and response size
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int64
}

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov2" title="3">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov3" title="4">{
        n, err := w.ResponseWriter.Write(data)
        w.size += int64(n)
        return n, err
}</span>

// Recovery middleware for panic handling
func RecoveryMiddleware(logger *Logger) func(next http.Handler) http.Handler <span class="cov2" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov2" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov2" title="2">{
                        defer func() </span><span class="cov2" title="2">{
                                if recovered := recover(); recovered != nil </span><span class="cov1" title="1">{
                                        logger.LogPanic(r.Context(), recovered, "HTTP request panic")

                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusInternalServerError)
                                        w.Write([]byte(`{"error": "Internal server error"}`))
                                }</span>
                        }()

                        <span class="cov2" title="2">next.ServeHTTP(w, r)</span>
                })
        }
}

// Global logger instance
var defaultLogger *Logger

func init() <span class="cov1" title="1">{
        defaultLogger = NewDefault()
}</span>

// Global logging functions
func Debug(msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.Debug(msg, args...)
}</span>

func Info(msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.Info(msg, args...)
}</span>

func Warn(msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.Warn(msg, args...)
}</span>

func Error(msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.Error(msg, args...)
}</span>

func DebugContext(ctx context.Context, msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.DebugContext(ctx, msg, args...)
}</span>

func InfoContext(ctx context.Context, msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.InfoContext(ctx, msg, args...)
}</span>

func WarnContext(ctx context.Context, msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.WarnContext(ctx, msg, args...)
}</span>

func ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov1" title="1">{
        defaultLogger.ErrorContext(ctx, msg, args...)
}</span>

// SetDefault sets the default logger
func SetDefault(logger *Logger) <span class="cov2" title="2">{
        defaultLogger = logger
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
